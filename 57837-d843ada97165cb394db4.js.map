{"version":3,"file":"57837-d843ada97165cb394db4.js","mappings":"yGAAA,SAAWA,GAGT,IAMIC,EAAgB,OAJF,oCAAoCC,OACtD,IAAM,oCAAoCA,OAC1C,IAAM,kCAAkCA,OACxC,IAAM,kCAAkCA,QACAC,QAAQ,SAN7B,0CAA0CD,QAMa,IAC1EF,EAAMI,UAAUC,IAAM,CACpB,QAAW,CACTC,QAAS,SACTC,QAAQ,GAEV,iBAAkB,CAEhBD,QAASE,OAAO,mBAAmBN,OAASD,EAAgB,aAAaC,QACzEO,YAAY,EACZF,QAAQ,EACRG,OAAQ,CAIN,OAAU,CACRJ,QAAS,iGACTC,QAAQ,EACRI,MAAO,UAET,cAAiB,CACfL,QAAS,qCACTC,QAAQ,EACRG,OAAQ,CACN,YAAe,cACf,WAAc,CACZJ,QAAS,UACTI,OAAQ,QAId,OAAU,YAGd,QAAW,CACTJ,QAAS,2DACTG,YAAY,GAEd,QAAW,CACTH,QAAS,oCACTG,YAAY,GAEd,QAAW,CACTH,QAAS,qGACTG,YAAY,GAEd,UAAa,CACXH,QAAS,mBACTK,MAAO,YAET,SAAY,CACVL,QAAS,oCACTG,YAAY,GAEd,OAAU,CACRH,QAAS,sMACTG,YAAY,GAEd,SAAY,+CACZ,YAAe,gBAEjBT,EAAMI,UAAUC,IAAI,kBAAkBK,OAAOE,cAAcF,OAAOG,WAAWH,OAASV,EAAMI,UAAUC,IAtExG,CAuEGL","sources":["webpack://zio-sample-site/./node_modules/prismjs/components/prism-cue.js"],"sourcesContent":["(function (Prism) {\n  // https://cuelang.org/docs/references/spec/\n  // eslint-disable-next-line regexp/strict\n  var stringEscape = /\\\\(?:(?!\\2)|\\2(?:[^()\\r\\n]|\\([^()]*\\)))/.source; // eslint-disable-next-line regexp/strict\n\n  var stringTypes = /\"\"\"(?:[^\\\\\"]|\"(?!\"\"\\2)|<esc>)*\"\"\"/.source + // eslint-disable-next-line regexp/strict\n  '|' + /'''(?:[^\\\\']|'(?!''\\2)|<esc>)*'''/.source + // eslint-disable-next-line regexp/strict\n  '|' + /\"(?:[^\\\\\\r\\n\"]|\"(?!\\2)|<esc>)*\"/.source + // eslint-disable-next-line regexp/strict\n  '|' + /'(?:[^\\\\\\r\\n']|'(?!\\2)|<esc>)*'/.source;\n  var stringLiteral = '(?:' + stringTypes.replace(/<esc>/g, stringEscape) + ')';\n  Prism.languages.cue = {\n    'comment': {\n      pattern: /\\/\\/.*/,\n      greedy: true\n    },\n    'string-literal': {\n      // eslint-disable-next-line regexp/strict\n      pattern: RegExp(/(^|[^#\"'\\\\])(#*)/.source + stringLiteral + /(?![\"'])\\2/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        // I'm using dirty hack here. We have to know the number hashes at the start of the string somehow,\n        // but we can't look back. So instead, we will use a lookahead, go to the end of the string, and\n        // capture the hashes at the end of the string.\n        'escape': {\n          pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1(?:U[a-fA-F0-9]{1,8}|u[a-fA-F0-9]{1,4}|x[a-fA-F0-9]{1,2}|\\d{2,3}|[^(])/,\n          greedy: true,\n          alias: 'string'\n        },\n        'interpolation': {\n          pattern: /(?=[\\s\\S]*[\"'](#*)$)\\\\\\1\\([^()]*\\)/,\n          greedy: true,\n          inside: {\n            'punctuation': /^\\\\#*\\(|\\)$/,\n            'expression': {\n              pattern: /[\\s\\S]+/,\n              inside: null\n            }\n          }\n        },\n        'string': /[\\s\\S]+/\n      }\n    },\n    'keyword': {\n      pattern: /(^|[^\\w$])(?:for|if|import|in|let|null|package)(?![\\w$])/,\n      lookbehind: true\n    },\n    'boolean': {\n      pattern: /(^|[^\\w$])(?:false|true)(?![\\w$])/,\n      lookbehind: true\n    },\n    'builtin': {\n      pattern: /(^|[^\\w$])(?:bool|bytes|float|float(?:32|64)|u?int(?:8|16|32|64|128)?|number|rune|string)(?![\\w$])/,\n      lookbehind: true\n    },\n    'attribute': {\n      pattern: /@[\\w$]+(?=\\s*\\()/,\n      alias: 'function'\n    },\n    'function': {\n      pattern: /(^|[^\\w$])[a-z_$][\\w$]*(?=\\s*\\()/i,\n      lookbehind: true\n    },\n    'number': {\n      pattern: /(^|[^\\w$.])(?:0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|0[xX][0-9A-Fa-f]+(?:_[0-9A-Fa-f]+)*|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[eE][+-]?\\d+(?:_\\d+)*)?(?:[KMGTP]i?)?)(?![\\w$])/,\n      lookbehind: true\n    },\n    'operator': /\\.{3}|_\\|_|&&?|\\|\\|?|[=!]~|[<>=!]=?|[+\\-*/?]/,\n    'punctuation': /[()[\\]{},.:]/\n  };\n  Prism.languages.cue['string-literal'].inside.interpolation.inside.expression.inside = Prism.languages.cue;\n})(Prism);"],"names":["Prism","stringLiteral","source","replace","languages","cue","pattern","greedy","RegExp","lookbehind","inside","alias","interpolation","expression"],"sourceRoot":""}