{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/2-0-0/overview/basic-operations","result":{"data":{"mdx":{"id":"ed7956ff-8a6c-52f8-a097-03bab4e4c619","slug":"overview/basic_operations","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"overview_basic_operations\",\n  \"title\": \"Basic Operations\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Mapping\"), mdx(\"p\", null, \"You can map over the success channel of an effect by calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#map\"), \" method. This lets you transform the success values of effects.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\n\\nval succeeded: UIO[Int] = ZIO.succeed(21).map(_ * 2)\\n\")), mdx(\"p\", null, \"You can map over the error channel of an effect by calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#mapError\"), \" method. This lets you transform the failure values of effects.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val failed: IO[Exception, Unit] = \\n  ZIO.fail(\\\"No no!\\\").mapError(msg => new Exception(msg))\\n\")), mdx(\"p\", null, \"Note that mapping over an effect's success or error channel does not change the success or failure of the effect, in the same way that mapping over an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \" does not change whether the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Left\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Right\"), \".\"), mdx(\"h2\", null, \"Chaining\"), mdx(\"p\", null, \"You can execute two effects sequentially with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" method; this requires that you pass a callback, which will receive the value of the first effect and can return a second effect that depends on this value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val sequenced: ZIO[Console, IOException, Unit] =\\n  readLine.flatMap(input => printLine(s\\\"You entered: $input\\\"))\\n\")), mdx(\"p\", null, \"If the first effect fails, the callback passed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" will never be invoked and the composed effect returned by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" will also fail.\"), mdx(\"p\", null, \"In \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" chain of effects, the first failure will short-circuit the whole chain, just like throwing an exception will prematurely exit a sequence of statements.\"), mdx(\"h2\", null, \"For Comprehensions\"), mdx(\"p\", null, \"Because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO\"), \" data type supports both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \", you can use Scala's \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"for comprehensions\"), \" to build sequential effects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val program: ZIO[Console, IOException, Unit] =\\n  for {\\n    _    <- printLine(\\\"Hello! What is your name?\\\")\\n    name <- readLine\\n    _    <- printLine(s\\\"Hello, ${name}, welcome to ZIO!\\\")\\n  } yield ()\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"For comprehensions\"), \" provide a more procedural syntax for composing chains of effects.\"), mdx(\"h2\", null, \"Zipping\"), mdx(\"p\", null, \"You can combine two effects into a single effect with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#zip\"), \" method. The resulting effect succeeds with a tuple that contains the success values of both effects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val zipped: UIO[(String, Int)] = \\n  ZIO.succeed(\\\"4\\\").zip(ZIO.succeed(2))\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zip\"), \" operates sequentially: the effect on the left side is executed before the effect on the right side.\"), mdx(\"p\", null, \"In any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zip\"), \" operation, if either the left or right-hand side fails, the composed effect will fail because \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"both\"), \" values are required to construct the tuple.\"), mdx(\"p\", null, \"Sometimes, when the success value of an effect is not useful (for example, if it is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Unit\"), \"), it can be more convenient to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#zipLeft\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#zipRight\"), \" functions, which first perform a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zip\"), \" and then map over the tuple to discard one side or the other:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val zipRight1: ZIO[Console, IOException, String] =\\n  printLine(\\\"What is your name?\\\").zipRight(readLine)\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zipRight\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zipLeft\"), \" functions have symbolic aliases, known as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<*\"), \", respectively. Some developers find these operators easier to read:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val zipRight2: ZIO[Console, IOException, String] =\\n  printLine(\\\"What is your name?\\\") *>\\n    readLine\\n\")), mdx(\"h2\", null, \"Next Step\"), mdx(\"p\", null, \"If you are comfortable with the basic operations on ZIO effects, the next step is to learn about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"handling_errors.md\"\n  }, \"error handling\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core-2/src/docs/overview/basic_operations.md"}},"staticQueryHashes":[]}