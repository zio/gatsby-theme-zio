{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/2-0-0/resources/ecosystem/community/tamer","result":{"data":{"mdx":{"id":"be4cd14e-80e7-53b3-b4e9-586fbd106ecc","slug":"resources/ecosystem/community/tamer","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Tamer\"), mdx(\"p\", null, \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/laserdisc-io/tamer\"\n  }, \"Tamer\"), \" is a multi-functional Kafka connector for producing data based on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/zio/zio-kafka\"\n  }, \"ZIO Kafka\"), \".\"), mdx(\"h3\", null, \"Introduction\"), mdx(\"p\", null, \" Tamer is a completely customizable source connector that produces to Kafka. It ships with preconfigured modules for SQL, cloud storage and REST API, but you can provide your own functions and Tamer will take care of the rest.\"), mdx(\"h3\", null, \"Installation\"), mdx(\"p\", null, \" Depending on the source you have at hand you can add the correct dependency in your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"build.sbt\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"libraryDependencies += \\\"io.laserdisc\\\" %% \\\"tamer-db\\\"                % \\\"0.16.1\\\"\\nlibraryDependencies += \\\"io.laserdisc\\\" %% \\\"tamer-oci-objectstorage\\\" % \\\"0.16.1\\\"\\nlibraryDependencies += \\\"io.laserdisc\\\" %% \\\"tamer-rest\\\"              % \\\"0.16.1\\\"\\nlibraryDependencies += \\\"io.laserdisc\\\" %% \\\"tamer-s3\\\"                % \\\"0.16.1\\\"\\n\")), mdx(\"h3\", null, \"Example\"), mdx(\"p\", null, \" Let's say you have a inventory DB that's compatible with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tpolecat/doobie\"\n  }, \"Doobie\"), \", you can get all of your items with just a few lines of code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import tamer._\\nimport tamer.db._\\n\\nimport doobie.implicits.legacy.instant._\\nimport doobie.syntax.string._\\nimport zio._\\nimport zio.duration._\\nimport zio.json._\\n\\nimport java.time.Instant\\n\\ncase class Row(id: String, name: String, description: Option[String], modifiedAt: Instant)\\n    extends tamer.db.Timestamped(modifiedAt)\\n\\nobject Row {\\n  implicit val rowJsonCodec = DeriveJsonCodec.gen[Row]\\n}\\n\\nobject DatabaseSimple extends zio.App {\\n  // Here we'll go with zio-json codec, you can use avro, circe and jsoniter\\n  // out-of-the box or plug yours!\\n  implicit val stateKeyJsonCodec = DeriveJsonCodec.gen[tamer.Tamer.StateKey]\\n  implicit val windowJsonCodec = DeriveJsonCodec.gen[tamer.db.Window]\\n\\n  val program: RIO[ZEnv, Unit] = tamer.db.DbSetup\\n    .tumbling(window =>\\n      sql\\\"\\\"\\\"SELECT id, name, description, modified_at \\n           |FROM users \\n           |WHERE modified_at > ${window.from} AND modified_at <= ${window.to}\\\"\\\"\\\".stripMargin\\n        .query[Row]\\n    )(\\n      recordKey = (_, v) => v.id,\\n      from = Instant.parse(\\\"2020-01-01T00:00:00.00Z\\\"),\\n      tumblingStep = 5.days\\n    )\\n    .runWith(dbLayerFromEnvironment ++ tamer.kafkaConfigFromEnvironment)\\n\\n  override final def run(args: List[String]): URIO[ZEnv, ExitCode] =\\n    program.exitCode\\n\\n  // If you have other codecs like circe in the classpath you have to disambiguate\\n  implicit lazy val stateKeyCodec: Codec[Tamer.StateKey] = Codec.optionalZioJsonCodec\\n  implicit lazy val windowCodec: Codec[tamer.db.Window] = Codec.optionalZioJsonCodec\\n  implicit lazy val stringCodec: Codec[String] = Codec.optionalZioJsonCodec\\n}\\n\")), mdx(\"p\", null, \" See full example \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/laserdisc-io/tamer/blob/4e1a7646fb44041648d9aa3ba089decb81ebe487/example/src/main/scala/tamer/db/DatabaseSimple.scala\"\n  }, \"on the GitHub repo\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core-2/src/docs/resources/ecosystem/community/tamer.md"}},"staticQueryHashes":[]}