{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/2-0-0/datatypes/sync/concurrentmap","result":{"data":{"mdx":{"id":"26ae34e1-dca3-5498-b416-3242bcdc5772","slug":"datatypes/sync/concurrentmap","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"concurrentmap\",\n  \"title\": \"ConcurrentMap\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap\"), \" is a wrapper over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"java.util.concurrent.ConcurrentHashMap\"), \".\"), mdx(\"h2\", null, \"Motivation\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HashMap\"), \" in the Scala standard library is not thread-safe. This means that if multiple fibers are accessing the same key, and trying to modify the value, this can lead to inconsistent results.\"), mdx(\"p\", null, \"For example, assume we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HashMap\"), \" with a key \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" and a value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \". Let's see what happens if we perform the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inc\"), \" workflow 100 times concurrently:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\n\\nimport scala.collection.mutable\\n\\nobject MainApp extends ZIOAppDefault {\\n\\n  def inc(ref: Ref[mutable.HashMap[String, Int]], key: String) =\\n    for {\\n      _ <- ref.get\\n      _ <- ref.update { map =>\\n        map.updateWith(key)(_.map(_ + 1))\\n        map\\n      }\\n    } yield ()\\n\\n  def run =\\n    for {\\n      ref <- Ref.make(mutable.HashMap((\\\"foo\\\", 0)))\\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ => inc(ref, \\\"foo\\\"))\\n      _ <- ref.get.map(_.get(\\\"foo\\\")).debug(\\\"The final value of foo is\\\")\\n    } yield ()\\n\\n}\\n\")), mdx(\"p\", null, \"Since the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HashMap\"), \" is not thread-safe, every time we run this program, we might get different results, which is not desirable.\"), mdx(\"p\", null, \"So we need a concurrent data structure that can be used safely in concurrent environments, which the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap\"), \" does for us:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.concurrent.ConcurrentMap\\n\\nobject MainApp extends ZIOAppDefault {\\n  def run =\\n    for {\\n      map <- ConcurrentMap.make((\\\"foo\\\", 0), (\\\"bar\\\", 1), (\\\"baz\\\", 2))\\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ =>\\n        map.computeIfPresent(\\\"foo\\\", (_, v) => v + 1)\\n      )\\n      _ <- map.get(\\\"foo\\\").debug(\\\"The final value of foo is\\\")\\n    } yield ()\\n}\\n\")), mdx(\"h2\", null, \"Creation\"), mdx(\"p\", null, \"To make an empty \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap\"), \" we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap.empty\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.concurrent.ConcurrentMap\\n\\nval empty = ConcurrentMap.empty[String, Int]\\n\")), mdx(\"p\", null, \"And to make a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap\"), \" with some initial values we use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap.make\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap.fromIterable\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.concurrent.ConcurrentMap\\n\\nval map1 = ConcurrentMap.make((\\\"foo\\\", 0), (\\\"bar\\\", 1), (\\\"baz\\\", 2))\\nval map2 = ConcurrentMap.fromIterable(List((\\\"foo\\\", 0), (\\\"bar\\\", 1), (\\\"baz\\\", 2)))\\n\")), mdx(\"h2\", null, \"Update Operations\"), mdx(\"p\", null, \"Basic operations are provided to manipulate the values in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConcurrentMap\"), \":\"), mdx(\"h3\", null, \"Putting values\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Method\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Definition\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"put(key: K, value: V): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Adds a new key-value pair and optionally returns previously bound value.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"putAll(keyValues: (K, V)*): UIO[Unit]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Adds all new key-value pairs.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"putIfAbsent(key: K, value: V): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Adds a new key-value pair, unless the key is already bound to some other value.\")))), mdx(\"h3\", null, \"Removing values\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Method\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Definition\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"remove(key: K): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Removes the entry for the given key, optionally returning value associated with it.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"remove(key: K, value: V): UIO[Boolean]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Removes the entry for the given key if it is mapped to a given value.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"removeIf(p: (K, V) => Boolean): UIO[Unit]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Removes all elements which do not satisfy the given predicate.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"retainIf(p: (K, V) => Boolean): UIO[Unit]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Removes all elements which do not satisfy the given predicate.\")))), mdx(\"h3\", null, \"Replacing values\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Method\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Definition\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"replace(key: K, value: V): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Replaces the entry for the given key only if it is mapped to some value.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"replace(key: K, oldValue: V, newValue: V): UIO[Boolean]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Replaces the entry for the given key only if it was previously mapped to a given value.\")))), mdx(\"h3\", null, \"Remapping Values\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Method\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Definition\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"compute(key: K, remap: (K, V) => V): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Attempts to compute a mapping for the given key and its current mapped value.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"def computeIfAbsent(key: K, map: K => V): UIO[V]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Computes a value of a non-existing key.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"computeIfPresent(key: K, remap: (K, V) => V): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Attempts to compute a new mapping of an existing key.\")))), mdx(\"h2\", null, \"Retrieval Operations\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Method\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Definition\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"get(key: K): UIO[Option[V]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Retrieves the value associated with the given key.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"exists(p: (K, V) => Boolean): UIO[Boolean]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Tests whether a given predicate holds true for at least one element in a map.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"collectFirst[B](pf: PartialFunction[(K, V), B]): UIO[Option[B]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Finds the first element of a map for which the partial function is defined and applies the function to it.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"fold[S](zero: S)(f: (S, (K, V)) => S): UIO[S]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Folds the elements of a map using the given binary operator.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"forall(p: (K, V) => Boolean): UIO[Boolean]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Tests whether a predicate is satisfied by all elements of a map.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"toChunk: UIO[Chunk[(K, V)]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Collects all entries into a chunk.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"toList: UIO[List[(K, V)]]\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Collects all entries into a list.\")))), mdx(\"h2\", null, \"Example Usage\"), mdx(\"p\", null, \"Given:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.concurrent.ConcurrentMap\\nimport zio.{Chunk, ZIO}\\n\\nfor {\\n  emptyMap <- ConcurrentMap.empty[Int, String]\\n  data     <- ZIO.succeed(Chunk(1 -> \\\"A\\\", 2 -> \\\"B\\\", 3 -> \\\"C\\\"))\\n  mapA     <- ConcurrentMap.fromIterable(data)\\n  map100   <- ConcurrentMap.make(1 -> 100)\\n  mapB     <- ConcurrentMap.make((\\\"A\\\", 1), (\\\"B\\\", 2), (\\\"C\\\", 3))\\n} yield ()\\n\")), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Operation\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Result\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.collectFirst { case (3, _) => \\\"Three\\\" }\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"Three\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.collectFirst { case (4, _) => \\\"Four\\\" }\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Empty\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"map100.compute(1, _+_).get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"101\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"emptyMap.computeIfAbsent(\\\"abc\\\", _.length).get(\\\"abc\\\")\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"map100.computeIfPresent(1, _+_).get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"101\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.exists((k, _) => k % 2 == 0)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"true\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.exists((k, _) => k == 4)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"false\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapB.fold(0) { case (acc, (_, value)) => acc + value }\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"6\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapB.forall((_, v) => v < 4)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"true\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"emptyMap.get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"None\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"emptyMap.put(1, \\\"b\\\").get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"b\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.putIfAbsent(2, \\\"b\\\").get(2)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"B\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"emptyMap.putAll((1, \\\"A\\\"), (2, \\\"B\\\"), (3, \\\"C\\\")).get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"A\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.remove(1).get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"None\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.remove(1,\\\"b\\\").get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"A\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.removeIf((k, _) => k != 1).get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"A\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.removeIf((k, _) => k != 1).get(2)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"None\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.retainIf((k, _) => k == 1).get(1)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\\"A\\\"\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"mapA.retainIf((k, _) => k == 1).get(2)\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"None\")))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core-2/src/docs/datatypes/sync/concurrentmap.md"}},"staticQueryHashes":[]}