{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/2-0-0/datatypes/test/gen","result":{"data":{"mdx":{"id":"4be9e6d7-3311-5c00-bc57-266ebda42b52","slug":"datatypes/test/gen","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"gen\",\n  \"title\": \"Gen\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen[R, A]\"), \" represents a generator of values of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \", which requires an environment \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"R\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen\"), \" data type is the base functionality for generating test data for property-based testing. We use them to produce deterministic and non-deterministic (PRNG) random values.\"), mdx(\"p\", null, \"It is encoded as a stream of optional samples:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"case class Gen[-R, +A](sample: ZStream[R, Nothing, Option[Sample[R, A]]])\\n\")), mdx(\"p\", null, \"Before deep into the generators, let's see what is property-based testing and what problem it solves in the testing world.\"), mdx(\"h2\", null, \"What is Property-Based Testing?\"), mdx(\"p\", null, \"In property-based testing, instead of testing individual values and making assertions on the results, we rely on testing the properties of the system which is under the test.\"), mdx(\"p\", null, \"To be more acquainted with property-based testing, let's look at how we can test a simple addition function. So assume we have a function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" that adds two numbers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def add(a: Int, b: Int): Int = ???\\n\")), mdx(\"p\", null, \"in a typical test we start with some well-known values as test inputs and check if the function returns the expected values for each of the pair inputs:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"input\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"expected output\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"(0, 0)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"0\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"(1, 0)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"(0, 1)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"(0, -1)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"-1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"(-1, 0)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"-1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"...\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"...\")))), mdx(\"p\", null, \"Now we can test all the inputs and make sure the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" function returns the expected values:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.test._\\n\\nobject AdditionSpec extends ZIOSpecDefault {\\n\\n  def add(a: Int, b: Int): Int = ???\\n\\n  val testData = Seq(\\n    ((0, 0), 0),\\n    ((1, 0), 1),\\n    ((0, 1), 1),\\n    ((0, -1), -1),\\n    ((-1, 0), -1),\\n    ((1, 1), 2),\\n    ((1, -1), 0),\\n    ((-1, 1), 0)\\n  )\\n\\n  def spec =\\n    test(\\\"test add function\\\") {\\n      assertTrue {\\n        testData.forall { case ((a, b), expected) =>\\n          add(a, b) == expected\\n        }\\n      }\\n    }\\n}\\n\")), mdx(\"p\", null, \"This is not a very good approach because it is very hard to find a set of inputs that will cover all possible behaviors of the addition function.\"), mdx(\"p\", null, \"Instead, in property-based testing, we extract the set of properties that our function must satisfy. So let's think about the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" function and find out what properties it must satisfy:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Commutative Property\"), \"\\u2014 It says that changing the order of addends does not change the result. So for all \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"b\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(a, b)\"), \" must be equal to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(a, b)\"), \":\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"assertTrue(add(a, b) == add(b, a))\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Associative Property\"), \"\\u2014 This says that changing the grouping of addends does not change the result. So for all \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"b\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"c\"), \", the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(add(a, b), c)\"), \" must be equal to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(a, add(b, c))\"), \":\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"assertTrue(add(add(a, b), c) == add(a, add(b, c)))\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Identity Property\"), \"\\u2014 For all \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(a, 0)\"), \" must be equal to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a\"), \":\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"assertTrue(add(a, 0) == a)\\n\")), mdx(\"p\", null, \"If we test all of these properties we can be sure that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" function works as expected, so let's see how we can do that using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen\"), \" data type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.test._\\nimport zio.test._\\n\\nobject AdditionSpec extends ZIOSpecDefault {\\n\\n  def add(a: Int, b: Int): Int = ???\\n\\n  def spec = suite(\\\"Add Spec\\\")(\\n    test(\\\"add is commutative\\\") {\\n      check(Gen.int, Gen.int) { (a, b) =>\\n        assertTrue(add(a, b) == add(b, a))\\n      }\\n    },\\n    test(\\\"add is associative\\\") {\\n      check(Gen.int, Gen.int, Gen.int) { (a, b, c) =>\\n        assertTrue(add(add(a, b), c) == add(a, add(b, c)))\\n      }\\n    },\\n    test(\\\"add is identitive\\\") {\\n      check(Gen.int) { a =>\\n        assertTrue(add(a, 0) == a)\\n      }\\n    }\\n  )\\n}\\n\")), mdx(\"h2\", null, \"Generators Are Deterministic by Default\"), mdx(\"p\", null, \"The important fact about generators is that they produce deterministic values. This means that if we run the same generator multiple times, it will always produce the same sequence of values. So the let us add some debugging print lines inside a test and see what values are produced:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.test._\\nimport zio.test.TestAspect._\\n\\nobject ExampleSpec extends ZIOSpecDefault {\\n  def spec =\\n    test(\\\"example test\\\") {\\n      check(Gen.int(0, 10)) { n =>\\n        println(n)\\n        assertTrue(n + n == 2 * n)\\n      }\\n    } @@ samples(5)\\n}\\n\")), mdx(\"p\", null, \"We can see, every time we run the test, the generator will produce the same sequence of values:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"runSpec\\n9\\n3\\n0\\n9\\n6\\n+ example test\\n\")), mdx(\"p\", null, \"This is due to the fact that the generator uses a pseudo-random number generator which uses a deterministic algorithm. The generator provides a fixed seed number to its underlying deterministic algorithm to generate random numbers. As the seed number is fixed, the generator will always produce the same sequence of values. For more information, there is a separate page about this on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../test/environment/random.md\"\n  }, \"TestRandom\"), \" which is the underlying service for generating test values.\"), mdx(\"p\", null, \"This behavior helps us to have reproducible tests. But, if we might need non-deterministic tests values, we can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TestAspect.nondeterministic\"), \" to change the default behavior:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"myspec @@ TestAspect.nondeterministic\\n\")), mdx(\"h2\", null, \"Creating a Generator\"), mdx(\"p\", null, \"In the companion object of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen\"), \" data type, there are tons of generators for various data types.\"), mdx(\"h3\", null, \"Primitive Types Generators\"), mdx(\"p\", null, \"ZIO Test provides generators for primitive types such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.int\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.string\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.boolean\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.float\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.double\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.bigInt\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.byte\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.bigdecimal\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.long\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.char\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.short\"), \".\"), mdx(\"p\", null, \"Let's create an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \" generator:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.test._\\n\\nval intGen: Gen[Any, Int] = Gen.int\\n\")), mdx(\"h3\", null, \"Character Generators\"), mdx(\"p\", null, \"In addition to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.char\"), \", ZIO Test offers a variety of specialized character generators:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.alphaChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Z, z, A, t, o, e, K, E, y, N\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.alphaNumericChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"b, O, X, B, 4, M, k, 9, a, p\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.asciiChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\x10, >, \\x04, \\x1E, \\x02, 2, k, \\x16, \\x0F, \\x03\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.unicodeChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\uF9BA, \\uE53F, \\uC637, \\uFA0D, \\uE8D4, \\uBBB2, \\uFE53, \\u766E, \\uF62C, \\u1723)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.numericChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1, 0, 1, 5, 6, 9, 4, 4, 5, 2\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.printableChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"H, J, (, Q, n, g, 4, G, 9, l\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.whitespaceChars\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\x1C, \\x1F, \\u2006, \\x0B, \\x1F, \\u2003, \\u2004,  , \\u1680, \")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.hexChar\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"3, F, b, 5, 9, e, 2, 8, b, e\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.hexCharLower\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"f, c, 4, 4, c, 2, 5, 4, f, 3\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.hexCharUpper\"), \" \\u2014 e.g. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"4, 8, 9, 8, C, 9, F, A, E, C\"))), mdx(\"h3\", null, \"String Generators\"), mdx(\"p\", null, \"Besides the primitive string generator, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.string\"), \", ZIO Test also provides the following specialized generators:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.stringBounded\"), \" \\u2014 A generator of strings whose size falls within the specified bounds:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.stringBounded(1, 5)(Gen.alphaChar)\\n  .runCollectN(10)\\n  .debug\\n// Sample Output: List(b, YJXzY, Aro, y, WMPbj, Abxt, kJep, LKN, kUtr, xJ)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.stringN\"), \" \\u2014 A generator of strings of fixed size:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.stringN(5)(Gen.alphaChar)\\n  .runCollectN(10)\\n  .debug\\n// Sample Output: List(BuywQ, tXCEy, twZli, ffLwI, BPEbz, OKYTi, xeDJW, iDUVn, cuMCr, keQAA)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.string1\"), \" \\u2014 A generator of strings of at least one character.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.alphaNumericString\"), \" \\u2014 A generator of alphanumeric characters.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.alphaNumericStringBounded\"), \" \\u2014 A generator of alphanumeric strings whose size falls within the specified bounds.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.iso_8859_1\"), \" \\u2014 A generator of strings that can be encoded in the ISO-8859-1 character set.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.asciiString\"), \" \\u2014 A generator of US-ASCII characters.\"))), mdx(\"h3\", null, \"Generating Fixed Values\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.const\"), \" \\u2014 A constant generator of the specified value.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.const(true).runCollectN(5)\\n// Output: List(true, true, true, true, true)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.constSample\"), \" \\u2014 A constant generator of the specified sample:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \" Gen.constSample(Sample.noShrink(false)).runCollectN(5)\\n// Output: List(true, true, true, true, true)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.unit\"), \" \\u2014 A constant generator of the unit value.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.throwable\"), \" \\u2014 A generator of throwables.\"))), mdx(\"p\", null, \"Note that there is an empty generator called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.empty\"), \", which generates no values and returns nothing. We can think of that as a generator of empty stream, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen(Stream.empty)\"), \".\"), mdx(\"h3\", null, \"Generating from Fixed Values\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.elements\"), \" \\u2014 Constructs a non-deterministic generator that only generates randomly from the fixed values:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import java.time._\\n\\nGen.elements(\\n  DayOfWeek.MONDAY,\\n  DayOfWeek.TUESDAY,\\n  DayOfWeek.WEDNESDAY,\\n  DayOfWeek.THURSDAY,\\n  DayOfWeek.FRIDAY,\\n  DayOfWeek.SATURDAY,\\n  DayOfWeek.SUNDAY\\n).runCollectN(3).debug\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.fromIterable\"), \" \\u2014 Constructs a deterministic generator that only generates the specified fixed values:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"Gen.fromIterable(List(\\\"red\\\", \\\"green\\\", \\\"blue\\\"))\\n  .runCollectN(10)\\n  .debug\\n\")), mdx(\"h3\", null, \"Collection Generators\"), mdx(\"p\", null, \"ZIO Test has generators for collection data types such as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sets\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lists\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"vectors\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"chunks\"), \", and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"maps\"), \". These data types share similar APIs. The following example illustrates how the generator of sets works:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"// A sized generator of sets\\nGen.setOf(Gen.alphaChar)\\n// Sample Output: Set(Y, M, c), Set(), Set(g, x, Q), Set(s), Set(f, J, b, R)\\n\\n// A sized generator of non-empty sets\\nGen.setOf1(Gen.alphaChar)    \\n// Sample Output: Set(Y), Set(L, S), Set(i), Set(H), Set(r, Z, z)\\n\\n// A generator of sets whose size falls within the specified bounds.\\nGen.setOfBounded(1, 3)(Gen.alphaChar)\\n// Sample Output: Set(Q), Set(q, J), Set(V, t, h), Set(c), Set(X, O)\\n\\n// A generator of sets of the specified size.\\nGen.setOfN(2)(Gen.alphaChar)\\n\")), mdx(\"h3\", null, \"Bounded Generator\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.bounded\"), \" constructor is a generator whose size falls within the specified bounds:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"Gen.bounded(2, 5)(Gen.stringN(_)(Gen.alphaChar))\\n  .runCollectN(5)\\n\")), mdx(\"h3\", null, \"Suspended Generator\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.suspend\"), \" constructs a generator lazily. This is useful to avoid infinite recursion when creating generators that refer to themselves.\"), mdx(\"h3\", null, \"Unfold Generator\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unfoldGen\"), \" takes the initial state and depending on the previous state, it determines what will be the next generated value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def unfoldGen[R <: Sized, S, A](s: S)(f: S => Gen[R, (S, A)]): Gen[R, List[A]]\\n\")), mdx(\"p\", null, \"Assume we want to test the built-in scala stack (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"scala.collection.mutable.Stack\"), \"). One way to do that is to create an acceptable series of push and pop commands, and then check that the stack doesn't throw any exception by executing these commands:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"sealed trait Command\\ncase object Pop                    extends Command\\nfinal case class Push(value: Char) extends Command\\n\\nval genPop:  Gen[Any, Command]    = Gen.const(Pop)\\ndef genPush: Gen[Any, Command] = Gen.alphaChar.map(Push)\\n\\nval genCommands: Gen[Sized, List[Command]] =\\n  Gen.unfoldGen(0) { n =>\\n    if (n <= 0)\\n      genPush.map(command => (n + 1, command))\\n    else\\n      Gen.oneOf(\\n        genPop.map(command => (n - 1, command)),\\n        genPush.map(command => (n + 1, command))\\n      )\\n  }\\n\")), mdx(\"p\", null, \"We are now ready to test the generated list of commands:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.test.{ test, _ }\\n\\ntest(\\\"unfoldGen\\\") {\\n  check(genCommands) { commands =>\\n    val stack = scala.collection.mutable.Stack.empty[Int]\\n    commands.foreach {\\n      case Pop => stack.pop()\\n      case Push(value) => stack.push(value)\\n    }\\n    assertCompletes\\n  }\\n}\\n\")), mdx(\"h3\", null, \"From a ZIO Effect\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.fromZIO\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Any, Int] = Gen.fromZIO(Random.nextInt) \\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.fromZIOSample\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Any, Int] =\\n  Gen.fromZIOSample(\\n    Random.nextInt.map(Sample.shrinkIntegral(0))\\n  )\\n\")))), mdx(\"h3\", null, \"From a Random Effect\"), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.fromRandom\"), \" \\u2014 Constructs a generator from a function that uses randomness:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Any, Int] = Gen.fromRandom(_.nextInt) \\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.fromRandomSample\"), \" \\u2014 Constructs a generator from a function that uses randomness to produce a sample:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Any, Int] =\\n  Gen.fromRandomSample(\\n    _.nextIntBounded(20).map(Sample.shrinkIntegral(0))\\n  )\\n\")))), mdx(\"h3\", null, \"Uniform and Non-uniform Generators\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.uniform\"), \" \\u2014 A generator of uniformly distributed doubles between \", \"[0, 1]\", \".\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.weighted\"), \" \\u2014 A generator which chooses one of the given generators according to their weights. For example, the following generator will generate 90% true and 10% false values:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val trueFalse = Gen.weighted((Gen.const(true), 9), (Gen.const(false), 1))\\ntrueFalse.runCollectN(10).debug\\n// Sample Output: List(false, false, false, false, false, false, false, false, true, false)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.exponential\"), \" \\u2014 A generator of exponentially distributed doubles with mean \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \":\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.exponential.map(x => math.round(x * 100) / 100.0)\\n  .runCollectN(10)\\n  .debug\\n// Sample Output: List(0.22, 3.02, 1.96, 1.13, 0.81, 0.92, 1.7, 1.47, 1.55, 0.46)\\n\")))), mdx(\"h3\", null, \"Generating Date/Time Types\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Date/Time Types\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Generators\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.DayOfWeek\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.dayOfWeek\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.Month\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.month\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.Year\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.year\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.Instant\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.instant\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.MonthDay\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.monthDay\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.YearMonth\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.yearMonth\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.ZoneId\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.zoneId\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.ZoneOffset\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.zoneOffset\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.ZonedDateTime\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.zonedDateTime\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.OffsetTime\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.offsetTime\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.OffsetDateTime\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.offsetDateTime\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.Period\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.period\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.LocalDate\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.localDate\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.LocalDateTime\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.localDateTime\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"java.time.LocalTime\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.localTime\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"zio.duration.Duration\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Gen.finiteDuration\"))))), mdx(\"h3\", null, \"Function Generators\"), mdx(\"p\", null, \"To test some properties, we need to generate functions. There are two types of function generators:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.function\"), \" \\u2014 It takes a generator of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" and produces a generator of functions from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \":\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def function[R, A, B](gen: Gen[R, B]): Gen[R, A => B]\\n\")))), mdx(\"p\", null, \"Two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" values will be considered to be equal, and thus will be guaranteed to generate the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" value, if they have the same\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashCode\"), \".\"), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.functionWith\"), \" \\u2014 It takes a generator of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" and also a hash function for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" values, and produces a generator of functions from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \":\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def functionWith[R, A, B](gen: Gen[R, B])(hash: A => Int): Gen[R, A => B]\\n\")))), mdx(\"p\", null, \"Two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" values will be considered to be equal, and thus will be guaranteed to generate the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" value, if they have the same hash. This is useful when \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" does not implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashCode\"), \" in a way that is consistent with equality.\"), mdx(\"p\", null, \"Accordingly, ZIO Test provides a variety of function generators for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Function2\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Function3\"), \", ..., and also the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PartialFunction\"), \": \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.function2\"), \" \\u2014  Gen\", \"[R, C]\", \" => Gen\", \"[R, (A, B) => C]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.functionWith2\"), \" \\u2014 Gen\", \"[R, B]\", \" => ((A, B) => Int) => Gen\", \"[R, (A, B) => C]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.partialFunction\"), \" \\u2014 Gen\", \"[R, B]\", \" => Gen[R, PartialFunction\", \"[A, B]\", \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Gen.partialFunctionWith\"), \" \\u2014 Gen\", \"[R, B]\", \" => (A => Int) => Gen[R, PartialFunction\", \"[A, B]\", \"]\")), mdx(\"p\", null, \"Let's write a test for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO.foldLeft\"), \" operator. This operator has the following signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def foldLeft[R, E, S, A](in: => Iterable[A])(zero: => S)(f: (S, A) => ZIO[R, E, S]): ZIO[R, E, S]\\n\")), mdx(\"p\", null, \"We want to test the following property:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"\\u2200 (in, zero, f) => ZIO.foldLeft(in)(zero)(f) == ZIO(List.foldLeft(in)(zero)(f))\\n\")), mdx(\"p\", null, \"To test this property, we have an input of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(Int, Int) => Int\"), \". So we need a Function2 generator of integers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val func2: Gen[Any, (Int, Int) => Int] = Gen.function2(Gen.int)\\n\")), mdx(\"p\", null, \"Now we can test this property:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.test.{test, _}\\n\\ntest(\\\"ZIO.foldLeft should have the same result with List.foldLeft\\\") {\\n  check(Gen.listOf(Gen.int), Gen.int, func2) { case (in, zero, f) =>\\n    assertZIO(\\n      ZIO.foldLeft(in)(zero)((s, a) => ZIO.attempt(f(s, a)))\\n    )(Assertion.equalTo(\\n      in.foldLeft(zero)((s, a) => f(s, a)))\\n    )\\n  }\\n}\\n\")), mdx(\"h3\", null, \"Generating ZIO Values\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Successful effects (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.successes\"), \"):\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Any, UIO[Int]] = Gen.successes(Gen.int(-10, 10))\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Failed effects (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.failures\"), \"):\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Sized, IO[String, Nothing]] = Gen.failures(Gen.string)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Died effects (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.died\"), \"):\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: Gen[Any, UIO[Nothing]] = Gen.died(Gen.throwable)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Cause values (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.causes\"), \"):\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val causes: Gen[Sized, Cause[String]] = \\n  Gen.causes(Gen.string, Gen.throwable)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Chained effects (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.chined\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.chainedN\"), \"): A generator of effects that are the result of chaining the specified effect with itself a random number of times.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Let's see some example of chained ZIO effects:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"import zio._\\nval effect1 = ZIO(2).flatMap(x => ZIO(x * 2))\\nval effect2 = ZIO(1) *> ZIO(2)\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"By using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.chaned\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.chanedN\"), \" generator, we can create generators of chained effects:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val chained : Gen[Sized, ZIO[Any, Nothing, Int]] = \\n  Gen.chained(Gen.successes(Gen.int))\\n  \\nval chainedN: Gen[Any, ZIO[Any, Nothing, Int]] = \\n  Gen.chainedN(5)(Gen.successes(Gen.int))\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Concurrent effects (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.concurrent\"), \"): A generator of effects that are the result of applying concurrency combinators to the specified effect that are guaranteed not to change its value.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val random  : Gen[Any, UIO[Int]] = Gen.successes(Gen.int).flatMap(Gen.concurrent)\\nval constant: Gen[Any, UIO[Int]]    = Gen.concurrent(ZIO(3))\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Parallel effects (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.parallel\"), \"): A generator of effects that are the result of applying parallelism combinators to the specified effect that are guaranteed not to change its value.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val random: Gen[Sized, UIO[String]] =\\n  Gen.successes(Gen.string).flatMap(Gen.parallel)\\n  \\nval constant: Gen[Any, UIO[String]] =\\n  Gen.parallel(ZIO(\\\"Hello\\\"))\\n\")))), mdx(\"h3\", null, \"Generating Compound Types\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"tuples \\u2014 We can combine generators using for-comprehension syntax and tuples:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val tuples: Gen[Any, (Int, Double)] =\\n  for {\\n    a <- Gen.int\\n    b <- Gen.double\\n  } yield (a, b)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.oneOf\"), \" \\u2014 It takes variable number of generators and select one of them:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"sealed trait Color\\ncase object Red extends Color\\ncase object Blue extends Color\\ncase object Green extends Color\\n\\nGen.oneOf(Gen.const(Red), Gen.const(Blue), Gen.const(Green))\\n// Sample Output: Green, Green, Red, Green, Red\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.option\"), \" \\u2014 A generator of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"optional\"), \" values:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val intOptions: Gen[Any, Option[Int]] = Gen.option(Gen.int)\\nval someInts:   Gen[Any, Option[Int]] = Gen.some(Gen.int)\\nval nons:       Gen[Any, Option[Nothing]]     = Gen.none\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.either\"), \" \\u2014 A generator of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"either\"), \" values:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val char: Gen[Any, Either[Char, Char]] =\\n  Gen.either(Gen.numericChar, Gen.alphaChar)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.collectAll\"), \" \\u2014 Composes the specified generators to create a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cartesian product of elements\"), \" with the specified function:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: ZIO[Any, Nothing, List[List[Int]]] =\\n  Gen.collectAll(\\n    List(\\n      Gen.fromIterable(List(1, 2)),\\n      Gen.fromIterable(List(3)),\\n      Gen.fromIterable(List(4, 5))\\n    )\\n  ).runCollect\\n// Output:\\n// List(\\n//  List(1, 3, 4),\\n//  List(1, 3, 5),\\n//  List(2, 3, 4),\\n//  List(2, 3, 5)\\n//)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.concatAll\"), \" \\u2014 Combines the specified deterministic generators to return a new deterministic generator that generates all the values generated by the specified generators:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"val gen: ZIO[Any, Nothing, List[Int]] =\\n  Gen.concatAll(\\n    List(\\n      Gen.fromIterable(List(1, 2)),\\n      Gen.fromIterable(List(3)),\\n      Gen.fromIterable(List(4, 5))\\n    )\\n  ).runCollect\\n// Output: List(1, 2, 3, 4, 5)\\n\")))), mdx(\"h3\", null, \"Sized Generators\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.sized\"), \" \\u2014 A sized generator takes a function from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen[R, A]\"), \" and creates a generator by applying a size to that function:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.sized(Gen.int(0, _))\\n  .runCollectN(10)\\n  .provideCustomLayer(Sized.live(5))\\n  .debug\\n// Sample Output: List(5, 4, 1, 2, 0, 4, 2, 0, 1, 2)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.size\"), \" \\u2014 A generator which accesses the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"size\"), \" from the environment and generates that:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.size\\n  .runCollectN(5)\\n  .provideCustomLayer(Sized.live(100))\\n  .debug\\n// Output: List(100, 100, 100, 100, 100)\\n\")))), mdx(\"p\", null, \"There are also three sized generators, named \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"small\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"medium\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"large\"), \", that use an exponential distribution of size values:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.small\"), \" \\u2014 The values generated will be strongly concentrated towards the lower end of the range but a few larger values will still be generated:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.small(Gen.const(_))\\n  .runCollectN(10)\\n  .provideCustomLayer(Sized.live(1000))\\n  .debug\\n// Output: List(6, 39, 73, 3, 57, 51, 40, 12, 110, 46)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.medium\"), \" \\u2014 The majority of sizes will be towards the lower end of the range but some larger sizes will be generated as well:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.medium(Gen.const(_))\\n  .runCollectN(10)\\n  .provideCustomLayer(Sized.live(1000))\\n  .debug\\n// Output: List(93, 42, 58, 228, 42, 5, 12, 214, 106, 79)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen.large\"), \" \\u2014 The values generated will be strongly concentrated towards the lower end of the range but a few larger values will still be generated:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.large(Gen.const(_))\\n  .runCollectN(10)\\n  .provideCustomLayer(Sized.live(1000))\\n  .debug\\n// Output: List(797, 218, 596, 278, 301, 779, 165, 486, 695, 788)\\n\")))), mdx(\"h2\", null, \"Running a Generator\"), mdx(\"p\", null, \"To run a generator, we can call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"runCollect\"), \" operation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val ints: ZIO[Any, Nothing, List[Int]] = intGen.runCollect.debug\\n// Output: List(-2090696713)\\n\")), mdx(\"p\", null, \"This will return a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO\"), \" effect containing all its values in a list, which in this example it contains only one element.\"), mdx(\"p\", null, \"To create more samples, we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen#runCollectN\"), \", which repeatedly runs the generator as much as we need. In this example, it will generate a list of containing 5 integer elements:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"intGen.runCollectN(5).debug\\n\")), mdx(\"p\", null, \"In addition, there is an operator called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen#runHead\"), \", which returns the first value generated by the generator.\"), mdx(\"h2\", null, \"Operators on Generators\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen#zipWith\"), \" \\u2014 Composes this generator with the specified generator to create a cartesian product of elements with the specified function:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.elements(\\\"a\\\", \\\"b\\\", \\\"c\\\").zipWith(Gen.elements(\\\"1\\\", \\\"2\\\", \\\"3\\\"))(_ + _)\\n  .runCollectN(5)\\n// Sample Output: List(b1, a2, c1, b1, b1)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen#zip\"), \" \\u2014 Composes this generator with the specified generator to create a cartesian product of elements.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.elements(\\\"a\\\", \\\"b\\\", \\\"c\\\").zip(Gen.elements(\\\"1\\\", \\\"2\\\", \\\"3\\\"))\\n  .runCollectN(5)\\n(Gen.elements(\\\"a\\\", \\\"b\\\", \\\"c\\\") <*> Gen.elements(\\\"1\\\", \\\"2\\\", \\\"3\\\"))\\n  .runCollectN(5)\\n  \\n// Sample Output: List((a,3), (a,3), (c,3), (b,3), (c,2))\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen#collect\"), \" \\u2014 Maps the values produced by this generator with the specified partial function, discarding any values the partial function is not defined at:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.int(-10, +10)\\n  .collect { case n if n % 2 == 0 => n }\\n  .runCollectN(5)\\n  .debug\\n// Smaple Output: List(-6, -8, -2, 4, -6)\\n\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gen#filter\"), \" \\u2014 Filters the values produced by this generator, discarding any values that do not meet the specified predicate:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.int(-10, +10).filter(_ % 2 == 0).runCollectN(5) \\n// Sample Output: List(-6, 10, 0, -8, 4)\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" can reduce test performance, especially if many values must be discarded. It is recommended to use combinators such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"flatMap\"), \" to create generators of the desired values instead:\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\",\n    \"metastring\": \"mdoc:compile-only\",\n    \"mdoc:compile-only\": true\n  }, \"Gen.int(-10, +10).map(_ * 2).runCollectN(5)\\n// Sample Output: List(2, 6, -6, 20, -14)\\n\")))), mdx(\"h2\", null, \"Shrinking\"), mdx(\"p\", null, \"In Property-Based Testing, we specify certain properties of a program, then we ask the testing framework to generate random test data to discover counterexamples. The existence of counterexamples shows that our function, which is under the test, is not correct. Unfortunately, in almost all cases, the first counterexample is not the minimal one, and they are fairly large or complex. So it is not a pretty good sample to describe why our test is failing.\"), mdx(\"p\", null, \"Shrinking is a mechanism that tries to find the smallest counterexample, which is the root cause of the test failure. So it helps a developer to find out why the test is failing.\"), mdx(\"p\", null, \"Finding the smallest failing case is somehow cumbersome and requires many attempts. As a developer, we do not need to do shrinking ourselves. All generators in ZIO Test have built-in shrinkers, so when we test properties, in case of test failures, the ZIO Test attempts to reduce the counterexamples forward their own zero points.\"), mdx(\"p\", null, \"Let's write a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" function with an incorrect implementation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def reverse[T](list: List[T]): List[T] =\\n  if (list.length > 6) list.reverse.dropRight(1) else list.reverse\\n\")), mdx(\"p\", null, \"We know that if we reverse a list twice, it should give us the original list, so let's check this property:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.test._\\n\\nsuite(\\\"ReverseSpec\\\"){\\n  // \\u2200 xs. reverse(reverse(xs)) == xs\\n  test(\\\"reversing a list twice must give the original list\\\")(\\n    check(Gen.listOf(Gen.int)) { list =>\\n      assertTrue(reverse(reverse(list)) == list)\\n    }\\n  )\\n}\\n\")), mdx(\"p\", null, \"The following messages, is a sample output of the test renderer, after running the test:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"- ReverseSpec\\n  - reversing a list twice must give the original list\\n    Test failed after 7 iterations with input: List(0, 0, 0, 0, 0, 0, 0)\\n    Original input before shrinking was: List(724856966, 1976458409, -940069360, -191508820, -291932258, 1296893186, 2010410723, 1134770522, 1260002835)\\n    \\u2717 List(0, 0, 0, 0, 0, 0) was not equal to List(0, 0, 0, 0, 0, 0, 0)\\n    reverse(reverse(list)) == list\\n    reverse(reverse(list)) = List(0, 0, 0, 0, 0, 0)\\n\")), mdx(\"p\", null, \"The initial failing input discovered by ZIO Test is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List(724856966, 1976458409, -940069360, -191508820, -291932258, 1296893186, 2010410723, 1134770522, 1260002835)\"), \". The ZIO Test then tries to find the simplest counterexample which is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List(0, 0, 0, 0, 0, 0, 0)\"), \". So the property still fails with the final shrunk value. The original input is a list of 9 somewhat useless numbers, while after shrinking, we have a list of 7 zero numbers, so we can find the bug faster.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core-2/src/docs/datatypes/test/gen.md"}},"staticQueryHashes":[]}