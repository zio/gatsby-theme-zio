{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/2-0-0/datatypes/stm/tmap","result":{"data":{"mdx":{"id":"0928b9b5-9733-59c2-bc54-a067ab14fe4a","slug":"datatypes/stm/tmap","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"tmap\",\n  \"title\": \"TMap\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap[A]\"), \" is a mutable map that can participate in transactions in STM.\"), mdx(\"h2\", null, \"Create a TMap\"), mdx(\"p\", null, \"Creating an empty \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval emptyTMap: STM[Nothing, TMap[String, Int]] = TMap.empty[String, Int]\\n\")), mdx(\"p\", null, \"Or creating a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \" with specified values:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval specifiedValuesTMap: STM[Nothing, TMap[String, Int]] = TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n\")), mdx(\"p\", null, \"Alternatively, you can create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \" by providing a collection of tuple values:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval iterableTMap: STM[Nothing, TMap[String, Int]] = TMap.fromIterable(List((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3)))\\n\")), mdx(\"h2\", null, \"Put a key-value pair to a TMap\"), mdx(\"p\", null, \"New key-value pair can be added to the map in the following way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval putElem: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2))\\n  _    <- tMap.put(\\\"c\\\", 3)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"Another way of adding an entry in the map is by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"merge\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval mergeElem: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.merge(\\\"c\\\", 4)((x, y) => x * y)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"If the key is not present in the map it behaves as a simple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"put\"), \" method. It merges the existing value with the new one using the provided function otherwise.\"), mdx(\"h2\", null, \"Remove an element from a TMap\"), mdx(\"p\", null, \"The simplest way to remove a key-value pair from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \" is using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"delete\"), \" method that takes key:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval deleteElem: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.delete(\\\"b\\\")\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"Also, it is possible to remove every key-value pairs that satisfy provided predicate:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval removedEvenValues: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3), (\\\"d\\\", 4))\\n  _    <- tMap.removeIf((_, v) => v % 2 == 0)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"Or you can keep all key-value pairs that match predicate function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval retainedEvenValues: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3), (\\\"d\\\", 4))\\n  _    <- tMap.retainIf((_, v) => v % 2 == 0)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"retainIf\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"removeIf\"), \" serve the same purpose as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filter\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"filterNot\"), \". The reason for naming them differently was to emphasize a distinction in their nature. Namely, both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"retainIf\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"removeIf\"), \" are destructive - calling them can modify the collection.\"), mdx(\"h2\", null, \"Retrieve the value from a TMap\"), mdx(\"p\", null, \"Value associated with the key can be obtained as follows: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval elemGet: UIO[Option[Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  elem <- tMap.get(\\\"c\\\")\\n} yield elem).commit\\n\")), mdx(\"p\", null, \"Alternatively, you can provide a default value if entry by key is not present in the map:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval elemGetOrElse: UIO[Int] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  elem <- tMap.getOrElse(\\\"d\\\", 4)\\n} yield elem).commit\\n\")), mdx(\"h2\", null, \"Transform entries of a TMap\"), mdx(\"p\", null, \"The transform function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(K, V) => (K, V)\"), \" allows computing a new value for every entry in the map: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval transformTMap: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.transform((k, v) => k -> v * v)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"Note that it is possible to shrink a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval shrinkTMap: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.transform((_, v) => \\\"d\\\" -> v)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"The entries can be mapped effectfully via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformSTM\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval transformSTMTMap: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.transformSTM((k, v) => STM.succeed(k -> v * v))\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformValues\"), \" function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"V => V\"), \" allows computing a new value for every value in the map: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval transformValuesTMap: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.transformValues(v => v * v)\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"The values can be mapped effectfully via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformValuesSTM\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval transformValuesMTMap: UIO[TMap[String, Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.transformValuesSTM(v => STM.succeed(v * v))\\n} yield tMap).commit\\n\")), mdx(\"p\", null, \"Note that both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transform\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformValues\"), \" serve the same purpose as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"map\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mapValues\"), \". The reason for naming them differently was to emphasize a distinction in their nature. Namely, both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transform\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transformValues\"), \" are destructive - calling them can modify the collection.\"), mdx(\"p\", null, \"Folds the elements of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \" using the specified associative binary operator:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval foldTMap: UIO[Int] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  sum  <- tMap.fold(0) { case (acc, (_, v)) => acc + v }\\n} yield sum).commit\\n\")), mdx(\"p\", null, \"The elements can be folded effectfully via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foldSTM\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval foldSTMTMap: UIO[Int] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  sum  <- tMap.foldSTM(0) { case (acc, (_, v)) => STM.succeed(acc + v) }\\n} yield sum).commit\\n\")), mdx(\"h2\", null, \"Perform side-effect for TMap key-value pairs\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foreach\"), \" is used for performing side-effect for each key-value pair in the map:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval foreachTMap = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  _    <- tMap.foreach((k, v) => STM.succeed(println(s\\\"$k -> $v\\\")))\\n} yield tMap).commit\\n\")), mdx(\"h2\", null, \"Check TMap membership\"), mdx(\"p\", null, \"Checking whether key-value pair is present in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TMap\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tMapContainsValue: UIO[Boolean] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  res  <- tMap.contains(\\\"a\\\")\\n} yield res).commit\\n\")), mdx(\"h2\", null, \"Convert TMap to a List\"), mdx(\"p\", null, \"List of tuples can be obtained as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tMapTuplesList: UIO[List[(String, Int)]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  list <- tMap.toList\\n} yield list).commit\\n\")), mdx(\"p\", null, \"List of keys can be obtained as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tMapKeysList: UIO[List[String]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  list <- tMap.keys\\n} yield list).commit\\n\")), mdx(\"p\", null, \"List of values can be obtained as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tMapValuesList: UIO[List[Int]] = (for {\\n  tMap <- TMap.make((\\\"a\\\", 1), (\\\"b\\\", 2), (\\\"c\\\", 3))\\n  list <- tMap.values\\n} yield list).commit\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core-2/src/docs/datatypes/stm/tmap.md"}},"staticQueryHashes":[]}