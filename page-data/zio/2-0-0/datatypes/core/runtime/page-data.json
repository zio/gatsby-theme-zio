{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/2-0-0/datatypes/core/runtime","result":{"data":{"mdx":{"id":"b68a82de-4771-5c45-88fe-2e1fecff8760","slug":"datatypes/core/runtime","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"runtime\",\n  \"title\": \"Runtime\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime[R]\"), \" is capable of executing tasks within an environment \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"R\"), \".\"), mdx(\"p\", null, \"To run an effect, we need a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime\"), \", which is capable of executing effects. Runtimes bundle a thread pool together with the environment that effects need.\"), mdx(\"h2\", null, \"What is a Runtime System?\"), mdx(\"p\", null, \"Whenever we write a ZIO program, we create a ZIO effect from ZIO constructors plus using its combinators. We are building a blueprint. ZIO effect is just a data structure that describes the execution of a concurrent program. So we end up with a tree data structure that contains lots of different data structures combined together to describe what the ZIO effect should do. This data structure doesn't do anything, it is just a description of a concurrent program.\"), mdx(\"p\", null, \"So the most important thing we should keep in mind when we are working with a functional effect system like ZIO is that when we are writing code, printing a string onto the console, reading a file, querying a database, and so forth; We are just writing a workflow or blueprint of an application. We are just building a data structure.\"), mdx(\"p\", null, \"So how can ZIO run these workflows? This is where ZIO Runtime System comes into play. Whenever we run an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unsaferun\"), \" function, the Runtime System is responsible to step through all the instructions described by the ZIO effect and execute them.\"), mdx(\"p\", null, \"To simplify everything, we can think of a Runtime System like a black box that takes both the ZIO effect (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO[R, E, A]\"), \") and its environment (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"R\"), \"), it will run this effect and then will return its result as an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either[E, A]\"), \" value.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/img/zio-runtime-system.svg\",\n    \"alt\": \"ZIO Runtime System\"\n  })), mdx(\"h2\", null, \"Responsibilities of the Runtime System\"), mdx(\"p\", null, \"Runtime Systems have a lot of responsibilities:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Execute every step of the blueprint\"), \" \\u2014 They have to execute every step of the blueprint in a while loop until it's done.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Handle unexpected errors\"), \" \\u2014 They have to handle unexpected errors, not just the expected ones but also the unexpected ones. \")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Spawn concurrent fiber\"), \" \\u2014 They are actually responsible for the concurrency that effect systems have. They have to spawn a fiber every time we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fork\"), \" on an effect to spawn off a new fiber.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Cooperatively yield to other fibers\"), \" \\u2014 They have to cooperatively yield to other fibers so that fibers that are sort of hogging the spotlight, don't get to monopolize all the CPU resources. They have to make sure that the fibers split the CPU cores among all the fibers that are working.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Capture execution and stack traces\"), \" \\u2014 They have to keep track of where we are in the progress of our own user-land code so the nice detailed execution traces can be captured. \")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ensure finalizers are run appropriately\"), \" \\u2014 They have to ensure finalizers are run appropriately at the right point in all circumstances to make sure that resources are closed that clean-up logic is executed. This is the feature that powers Scope and all the other resource-safe constructs in ZIO.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Handle asynchronous callback\"), \" \\u2014 They have to handle this messy job of dealing with asynchronous callbacks. So we don't have to deal with async code. When we are doing ZIO, everything is just async out of the box. \"))), mdx(\"h2\", null, \"Running a ZIO Effect\"), mdx(\"p\", null, \"There are two common ways to run a ZIO effect. Most of the time, we use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"zioapp.md\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"ZIOAppDefault\")), \" trait. There are, however, some advanced use cases for which we need to directly feed a ZIO effect into the runtime system's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unsafeRun\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\n\\nobject RunZIOEffectUsingUnsafeRun extends scala.App {\\n  val myAppLogic = for {\\n    _ <- Console.printLine(\\\"Hello! What is your name?\\\")\\n    n <- Console.readLine\\n    _ <- Console.printLine(\\\"Hello, \\\" + n + \\\", good to meet you!\\\")\\n  } yield ()\\n\\n  zio.Runtime.default.unsafeRun(\\n    myAppLogic\\n  )\\n}\\n\")), mdx(\"p\", null, \"We don't usually use this method to run our effects. One of the use cases of this method is when we are integrating the legacy (non-effectful code) with the ZIO effect. It also helps us to refactor a large legacy code base into a ZIO effect gradually; Assume we have decided to refactor a component in the middle of a legacy code and rewrite that with ZIO. We can start rewriting that component with the ZIO effect and then integrate that component with the existing code base, using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unsafeRun\"), \" function.\"), mdx(\"h2\", null, \"Default Runtime\"), mdx(\"p\", null, \"ZIO contains a default runtime called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime.default\"), \" designed to work well for mainstream usage. It is already implemented as below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"object Runtime {\\n  lazy val default: Runtime[Any] = Runtime(ZEnvironment.empty)\\n}\\n\")), mdx(\"p\", null, \"The default runtime contains minimum capabilities to bootstrap execution of ZIO tasks.\"), mdx(\"p\", null, \"We can easily access the default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime\"), \" to run an effect:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"object MainApp extends scala.App {\\n  val myAppLogic = ZIO.succeed(???)\\n  val runtime = Runtime.default\\n  runtime.unsafeRun(myAppLogic)\\n}\\n\")), mdx(\"h2\", null, \"Custom Runtime\"), mdx(\"p\", null, \"Sometimes we need to create a custom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime\"), \" with a user-defined environment.\"), mdx(\"p\", null, \"Some use-cases of custom Runtimes:\"), mdx(\"h3\", null, \"Providing Environment to Runtime System\"), mdx(\"p\", null, \"The custom runtime can be used to run many different effects that all require the same environment, so we don't have to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#provide\"), \" on all of them before we run them.\"), mdx(\"p\", null, \"For example, assume we want to create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime\"), \" for services that are for testing purposes, and they don't interact with real external APIs. So we can create a runtime, especially for testing.\"), mdx(\"p\", null, \"Let's say we have defined two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Logging\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Email\"), \" services:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"trait Logging {\\n  def log(line: String): UIO[Unit]\\n}\\n\\nobject Logging {\\n  def log(line: String): URIO[Logging, Unit] =\\n    ZIO.serviceWith[Logging](_.log(line))\\n}\\n\\ntrait Email {\\n  def send(user: String, content: String): Task[Unit]\\n}\\n\\nobject Email {\\n  def send(user: String, content: String): ZIO[Email, Throwable, Unit] =\\n    ZIO.serviceWith[Email](_.send(user, content))\\n}\\n\")), mdx(\"p\", null, \"We are going to implement a live version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Logging\"), \" service and also a mock version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Email\"), \" service for testing:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"case class LoggingLive() extends Logging {\\n  override def log(line: String): UIO[Unit] =\\n    ZIO.succeed(print(line))\\n}\\n\\ncase class EmailMock() extends Email {\\n  override def send(user: String, content: String): Task[Unit] =\\n    ZIO.attempt(println(s\\\"sending email to $user\\\"))\\n}\\n\")), mdx(\"p\", null, \"Let's create a custom runtime that contains these two service implementations in its environment:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val testableRuntime = Runtime(\\n  ZEnvironment[Logging, Email](LoggingLive(), EmailMock()),\\n  FiberRefs.empty\\n)\\n\")), mdx(\"p\", null, \"Also, we can map the default runtime to the new runtime, so we can append new services to the ZIO environment:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val testableRuntime: Runtime[Logging with Email] =\\n  Runtime.default.map { _ =>\\n    ZEnvironment[Logging, Email](LoggingLive(), EmailMock())\\n  }\\n\")), mdx(\"p\", null, \"Now we can run our effects using this custom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Runtime\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"testableRuntime.unsafeRun(\\n  for {\\n    _ <- Logging.log(\\\"sending newsletter\\\")\\n    _ <- Email.send(\\\"David\\\", \\\"Hi! Here is today's newsletter.\\\")\\n  } yield ()\\n)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core-2/src/docs/datatypes/core/runtime.md"}},"staticQueryHashes":[]}