{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/1-0-0/datatypes/stm/tqueue","result":{"data":{"mdx":{"id":"a4ce369b-8fc9-574c-9c06-6f024a4e922b","slug":"datatypes/stm/tqueue","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"tqueue\",\n  \"title\": \"TQueue\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TQueue[A]\"), \" is a mutable queue that can participate in transactions in STM.\"), mdx(\"h2\", null, \"Create a TQueue\"), mdx(\"p\", null, \"Creating an empty bounded \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TQueue\"), \" with specified capacity:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueBounded: STM[Nothing, TQueue[Int]] = TQueue.bounded[Int](5)\\n\")), mdx(\"p\", null, \"Creating an empty unbounded \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TQueue\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueUnbounded: STM[Nothing, TQueue[Int]] = TQueue.unbounded[Int]\\n\")), mdx(\"h2\", null, \"Put element(s) in a TQueue\"), mdx(\"p\", null, \"In order to put an element to a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TQueue\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueOffer: UIO[TQueue[Int]] = (for {\\n  tQueue <- TQueue.bounded[Int](3)\\n  _      <- tQueue.offer(1)\\n} yield tQueue).commit\\n\")), mdx(\"p\", null, \"The specified element will be successfully added to a queue if the queue is not full.\\nIt will wait for an empty slot in the queue otherwise.\"), mdx(\"p\", null, \"Alternatively, you can provide a list of elements:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueOfferAll: UIO[TQueue[Int]] = (for {\\n  tQueue <- TQueue.bounded[Int](3)\\n  _      <- tQueue.offerAll(List(1, 2))\\n} yield tQueue).commit\\n\")), mdx(\"h2\", null, \"Retrieve element(s) from a TQueue\"), mdx(\"p\", null, \"The first element of the queue can be obtained as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueTake: UIO[Int] = (for {\\n  tQueue <- TQueue.bounded[Int](3)\\n  _      <- tQueue.offerAll(List(1, 2))\\n  res    <- tQueue.take\\n} yield res).commit\\n\")), mdx(\"p\", null, \"In case the queue is empty it will block execution waiting for the element you're asking for.\"), mdx(\"p\", null, \"This behavior can be avoided by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"poll\"), \" method that will return an element if exists or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \" otherwise:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueuePoll: UIO[Option[Int]] = (for {\\n  tQueue <- TQueue.bounded[Int](3)\\n  res    <- tQueue.poll\\n} yield res).commit\\n\")), mdx(\"p\", null, \"Retrieving first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" elements of the queue:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueTakeUpTo: UIO[List[Int]] = (for {\\n  tQueue <- TQueue.bounded[Int](4)\\n  _      <- tQueue.offerAll(List(1, 2))\\n  res    <- tQueue.takeUpTo(3)\\n} yield res).commit\\n\")), mdx(\"p\", null, \"All elements of the queue can be obtained as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueTakeAll: UIO[List[Int]] = (for {\\n  tQueue <- TQueue.bounded[Int](4)\\n  _      <- tQueue.offerAll(List(1, 2))\\n  res    <- tQueue.takeAll\\n} yield res).commit\\n\")), mdx(\"h2\", null, \"Size of a TQueue\"), mdx(\"p\", null, \"The number of elements in the queue can be obtained as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\nimport zio.stm._\\n\\nval tQueueSize: UIO[Int] = (for {\\n  tQueue <- TQueue.bounded[Int](3)\\n  _      <- tQueue.offerAll(List(1, 2))\\n  size   <- tQueue.size\\n} yield size).commit\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core/src/docs/datatypes/stm/tqueue.md"}},"staticQueryHashes":[]}