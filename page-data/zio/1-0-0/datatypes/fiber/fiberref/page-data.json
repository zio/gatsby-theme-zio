{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/1-0-0/datatypes/fiber/fiberref","result":{"data":{"mdx":{"id":"8c9917a3-9587-5b4e-9ae3-b2684786cc96","slug":"datatypes/fiber/fiberref","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"fiberref\",\n  \"title\": \"FiberRef\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef[A]\"), \" models a mutable reference to a value of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \". The two basic operations are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set\"), \", which sets the reference to a new value, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get\"), \", which retrieves the current value of the reference.\"), mdx(\"p\", null, \"We can think of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" as Java's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" on steroids. So, just like we have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" in Java we have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" in ZIO. So as different threads have different \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \"s, we can say different fibers have different \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \"s. They don't intersect or overlap in any way. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" is the fiber version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" with significant improvements in its semantics. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" only has a mutable state in which each thread accesses its own copy, but threads don't propagate their state to their children's.\"), mdx(\"p\", null, \"As opposed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ref[A]\"), \", the value of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef[A]\"), \" is bound to an executing fiber. Different fibers who hold the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef[A]\"), \" can independently set and retrieve values of the reference, without collisions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio._\\n\\nfor {\\n  fiberRef <- FiberRef.make[Int](0)\\n  _        <- fiberRef.set(10)\\n  v        <- fiberRef.get\\n} yield v == 10\\n\")), mdx(\"h2\", null, \"Operations\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef[A]\"), \" has an API almost identical to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ref[A]\"), \". It includes well-known methods such as:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FiberRef#get\"), \". Returns the current value of the reference.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FiberRef#set\"), \". Sets the current value of the reference.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FiberRef#update\"), \" / \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FiberRef#updateSome\"), \" updates the value with the specified function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FiberRef#modify\"), \"/ \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FiberRef#modifySome\"), \" modifies the value with the specified function, computing a return value for the operation.\")), mdx(\"p\", null, \"You can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"locally\"), \" to scope \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" value only for a given effect:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  correlationId <- FiberRef.make[String](\\\"\\\")\\n  v1            <- correlationId.locally(\\\"my-correlation-id\\\")(correlationId.get)\\n  v2            <- correlationId.get\\n} yield v1 == \\\"my-correlation-id\\\" && v2 == \\\"\\\"\\n\")), mdx(\"h2\", null, \"Propagation\"), mdx(\"p\", null, \"Let's go back to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \"s analog called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" and see how it works. If we have thread \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" with its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" and thread \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" creates a new thread, let's call it thread \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \". When thread \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \" sends thread \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" then what value does thread \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" see inside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \"? Well, it sees the default value of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \". It does not see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \"s value of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \". So in other words, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \"s do not propagate their values across the sort of graph of threads so when one thread creates another, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ThreadLocal\"), \" value is not propagated from parent to child.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRefs\"), \" improve on that model quite dramatically. Basically, whenever a child's fiber is created from its parent, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" value of parent fiber propagated to its child fiber.\"), mdx(\"h3\", null, \"Copy-on-Fork\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef[A]\"), \" has \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"copy-on-fork\"), \" semantics for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#fork\"), \". This essentially means that a child \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber\"), \" starts with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" values of its parent. When the child set a new value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \", the change is visible only to the child itself. The parent fiber still has its own value.\"), mdx(\"p\", null, \"So if we create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" and, we set its value to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \", and we pass this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" to a child fiber, it sees the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \". If the child fiber modifies the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"5\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \", the parent fiber can't see that change. So the child fiber gets its own copy of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \", and it can modify it locally. Those changes will not affect the parent fiber:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  fiberRef <- FiberRef.make(5)\\n  promise <- Promise.make[Nothing, Int]\\n  _ <- fiberRef\\n    .updateAndGet(_ => 6)\\n    .flatMap(promise.succeed).fork\\n  childValue <- promise.await\\n  parentValue <- fiberRef.get\\n} yield assert(parentValue == 5 && childValue == 6)\\n\")), mdx(\"h3\", null, \"join Semantic\"), mdx(\"p\", null, \"If we \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"join\"), \" a fiber then its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" is merged back into the parent fiber:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  fiberRef <- FiberRef.make(5)\\n  child <- fiberRef.set(6).fork\\n  _ <- child.join\\n  parentValue <- fiberRef.get\\n} yield assert(parentValue == 6)\\n\")), mdx(\"p\", null, \"So if we \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fork\"), \" a fiber and that child fiber modifies a bunch of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \"s and then later we join it, we get those modifications merged back into the parent fiber. So that's the semantic model of ZIO on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"join\"), \". \"), mdx(\"p\", null, \"Each fiber has its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" and modifying it locally. So when they do their job and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"join\"), \" their parent, how do they get merged?  By default, the last child fiber will win, the last fiber which is going to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"join\"), \" will override the parent's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" value.\"), mdx(\"p\", null, \"As we can see, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"child1\"), \" is the last fiber, so its value which is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \", gets merged back into its parent:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  fiberRef <- FiberRef.make(5)\\n  child1 <- fiberRef.set(6).fork\\n  child2 <- fiberRef.set(7).fork\\n  _ <- child2.join\\n  _ <- child1.join\\n  parentValue <- fiberRef.get\\n} yield assert(parentValue == 6)\\n\")), mdx(\"h3\", null, \"Custom Merge\"), mdx(\"p\", null, \"Furthermore we can customize how, if at all, the value will be update when a fiber is forked and how values will be combined when a fiber is merged. To do this you specify the desired behavior during \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef#make\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  fiberRef <- FiberRef.make(initial = 0, join = math.max)\\n  child    <- fiberRef.update(_ + 1).fork\\n  _        <- fiberRef.update(_ + 2)\\n  _        <- child.join\\n  value    <- fiberRef.get\\n} yield assert(value == 2)\\n\")), mdx(\"h3\", null, \"await semantic\"), mdx(\"p\", null, \"Important to note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \", has no such properties, so \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" waits for the child fiber to finish and gives us its value as an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Exit\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  fiberRef <- FiberRef.make(5)\\n  child <- fiberRef.set(6).fork\\n  _ <- child.await\\n  parentValue <- fiberRef.get\\n} yield assert(parentValue == 5)\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Join\"), \" has higher-level semantics that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" because it will fail if the child fiber failed, and it will also merge back its value to its parent.\"), mdx(\"h3\", null, \"inheritRefs\"), mdx(\"p\", null, \"We can inherit the values from all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \"s from an existing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber\"), \" using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber#inheritRefs\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"for {\\n  fiberRef <- FiberRef.make[Int](0)\\n  latch    <- Promise.make[Nothing, Unit]\\n  fiber    <- (fiberRef.set(10) *> latch.succeed(())).fork\\n  _        <- latch.await\\n  _        <- fiber.inheritRefs\\n  v        <- fiberRef.get\\n} yield v == 10\\n\")), mdx(\"p\", null, \"Note that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inheritRefs\"), \" is automatically called on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"join\"), \". This effectively means that both of the following effects behave identically:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val withJoin =\\n  for {\\n    fiberRef <- FiberRef.make[Int](0)\\n    fiber    <- fiberRef.set(10).fork\\n    _        <- fiber.join\\n    v        <- fiberRef.get\\n  } yield assert(v == 10)\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val withoutJoin =\\n  for {\\n    fiberRef <- FiberRef.make[Int](0)\\n    fiber    <- fiberRef.set(10).fork\\n    _        <- fiber.inheritRefs\\n    v        <- fiberRef.get\\n  } yield assert(v == 10)\\n\")), mdx(\"h2\", null, \"Memory Safety\"), mdx(\"p\", null, \"The value of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" is automatically garbage collected once the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber\"), \" owning it is finished. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FiberRef\"), \" that is no longer reachable (has no reference to it in user-code) will cause all fiber-specific values of the reference to be garbage collected, even if they were once used in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber\"), \" that is currently executing.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core/src/docs/datatypes/fiber/fiberref.md"}},"staticQueryHashes":[]}