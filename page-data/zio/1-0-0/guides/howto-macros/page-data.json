{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/1-0-0/guides/howto-macros","result":{"data":{"mdx":{"id":"9d111549-f4b6-53f2-807a-38e677fd2b08","slug":"guides/howto-macros","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"use-zio-macros\",\n  \"title\": \"How to use ZIO Macros?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Scrapping the boilerplate with macros\"), mdx(\"p\", null, \"Many libraries come together with usage best practices and repeatable code, ZIO is no different. Fortunately ZIO provides macros\\nto perform these repetitive tasks for you. At the moment these are only available for Scala versions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2.x\"), \", however their equivalents\\nfor Dotty are on our roadmap.\"), mdx(\"h3\", null, \"Prerequisites\"), mdx(\"p\", null, \"To enable macro expansion you need to setup your project:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for Scala \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \">= 2.13\"), \" add compiler option\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"scalacOptions += \\\"-Ymacro-annotations\\\"\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for Scala \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"< 2.13\"), \" add macro paradise compiler plugin\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"compilerPlugin((\\\"org.scalamacros\\\" % \\\"paradise\\\"  % \\\"2.1.1\\\") cross CrossVersion.full)\\n\")), mdx(\"h2\", null, \"Capability accessors\"), mdx(\"h3\", null, \"Installation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"libraryDependencies += \\\"dev.zio\\\" %% \\\"zio-macros\\\" % \\\"<zio-version>\\\"\\n\")), mdx(\"h3\", null, \"Description\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@accessible\"), \" macro generates \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"capability accessors\"), \" into annotated module object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.{ Has, ZIO }\\nimport zio.macros.accessible\\n\\n@accessible\\nobject AccountObserver {\\n  trait Service {\\n    def processEvent(event: AccountEvent): UIO[Unit]\\n  }\\n\\n  // below will be autogenerated\\n  def processEvent(event: AccountEvent) =\\n    ZIO.accessM[Has[AccountObserver.Service]](_.get[Service].processEvent(event))\\n}\\n\")), mdx(\"p\", null, \"For normal values, a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Nothing\"), \" on error channel is generated.\\nIf the code is throwing exceptions see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@throwing\"), \" below.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.{ Has, ZIO }\\nimport zio.macros.accessible\\n\\n@accessible\\nobject Module {\\n  trait Service {\\n    def pureMethod(v: Something): SomethingElse\\n  }\\n\\n  // below will be autogenerated\\n  def pureMethod(v: Something): ZIO[Service, Nothing, SomethingElse] =\\n    ZIO.access[Has[Module.Service]](_.get[Service].pureMethod(v))\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@throwing\"), \" annotation will mark impure methods.\\nUsing this annotation will request ZIO to push the error on the error channel.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.{ Has, ZIO }\\nimport zio.macros.accessible\\n\\n@accessible\\nobject Module {\\n  trait Service {\\n    @throwing\\n    def impureMethod(v: Something): SomethingElse\\n  }\\n\\n  // below will be autogenerated\\n  def impureMethod(v: Something): ZIO[Service, Throwable, SomethingElse] =\\n    ZIO.accessM[Has[Module.Service]](s => ZIO(s.get[Service].impureMethod(v)))\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" the macro can only be applied to objects which contain a trait called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Service\"), \".\")), mdx(\"h2\", null, \"Capability tags\"), mdx(\"h3\", null, \"Installation\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"libraryDependencies += \\\"dev.zio\\\" %% \\\"zio-test\\\" % \\\"<zio-version>\\\"\\n\")), mdx(\"h3\", null, \"Description\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@mockable[A]\"), \" generates \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"capability tags\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"mock layer\"), \" into annotated object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.test.mock.mockable\\n\\n@mockable[AccountObserver.Service]\\nobject AccountObserverMock\\n\")), mdx(\"p\", null, \"Will result in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.{ Has, UIO, URLayer, ZLayer }\\nimport zio.test.mock.{ Mock, Proxy }\\n\\nobject AccountObserverMock extends Mock[Has[AccountObserver.Service]] {\\n\\n  object ProcessEvent extends Effect[AccountEvent, Nothing, Unit]\\n  object RunCommand   extends Effect[Unit, Nothing, Unit]\\n\\n  val compose: URLayer[Has[Proxy], AccountObserver] =\\n    ZLayer.fromServiceM { proxy =>\\n      withRuntime.map { rts =>\\n        new AccountObserver.Service {\\n          def processEvent(event: AccountEvent) = proxy(ProcessEvent, event)\\n          def runCommand: UIO[Unit]           = proxy(RunCommand)\\n        }\\n      }\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core/src/docs/guides/howto-macros.md"}},"staticQueryHashes":[]}