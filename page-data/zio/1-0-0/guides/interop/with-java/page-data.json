{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/1-0-0/guides/interop/with-java","result":{"data":{"mdx":{"id":"307eec85-ea30-55ca-96d7-8fc7935c0eb1","slug":"guides/interop/with-java","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"with-java\",\n  \"title\": \"How to Interop with Java?\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"ZIO has full interoperability with foreign Java code. Let me show you how it works and then \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"BOOM\"), \", tomorrow you can show off your purely functional Java at work.\"), mdx(\"p\", null, \"ZIO has built-in conversion between ZIO data types (like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber\"), \") and Java concurrent data types like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"CompletionStage\")), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Future\")), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.oracle.com/javase/8/docs/api/java/nio/channels/CompletionHandler.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"CompletionHandler\")), \".\"), mdx(\"h2\", null, \"From Java CompletionStage and back\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CompletionStage\"), \" is the interface that comes closest to emulate a functional asynchronous effects API like ZIO's, so we start with it. It's a breeze:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def loggedStage[A](stage: => CompletionStage[A]): Task[A] =\\n    ZIO.fromCompletionStage(UIO {\\n        stage.thenApplyAsync { a =>\\n            println(\\\"Stage completed with \\\" + a)\\n            a\\n        }\\n    })\\n\")), mdx(\"p\", null, \"By Jove, you can even turn it into fiber!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def stageToFiber[A](stage: => CompletionStage[A]): Fiber[Throwable, A] = \\n  Fiber.fromCompletionStage(future)\\n\")), mdx(\"p\", null, \"This API creates a synthetic fiber which doesn't have any notion of identity.\"), mdx(\"p\", null, \"Additionally, you may want to go the other way and convert a ZIO value into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CompletionStage\"), \". Easy as pie:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def taskToStage[A](task: Task[A]): UIO[CompletableFuture[A]] =\\n    task.toCompletableFuture\\n\")), mdx(\"p\", null, \"As you can see, it commits to a concrete class implementing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CompletionStage\"), \" interface, i.e. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CompletableFuture\"), \". It is worth to point out that any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IO[E, A]\"), \" can be turned into a completable future provided you can turn a value of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"E\"), \" into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Throwable\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def ioToStage[E, A](io: IO[E, A])(toThrowable: E => Throwable): UIO[CompletableFuture[A]] =\\n    io.toCompletableFutureWith(toThrowable)\\n\")), mdx(\"h2\", null, \"Java Future\"), mdx(\"p\", null, \"You can embed any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"java.util.concurrent.Future\"), \" in a ZIO computation via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO.fromFutureJava\"), \". A toy wrapper around Apache Async HTTP client could look like:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def execute(client: HttpAsyncClient, request: HttpUriRequest): RIO[Blocking, HttpResponse] =\\n    ZIO.fromFutureJava(UIO {\\n        client.execute(request, null)\\n    })\\n\")), mdx(\"p\", null, \"That's it. Just a bit of a warning here, mate. As you can see from the requirement on the produced value, ZIO uses the blocking \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Future#get\"), \" call internally. It is running on the blocking thread pool, of course, but I thought you should know. If possible, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO.fromCompletionStage\"), \" instead, as detailed above.\"), mdx(\"p\", null, \"Should you need it, it is also possible to convert a future into a fiber using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fiber.fromFutureJava\"), \". Same same, but different:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def execute(client: HttpAsyncClient, request: HttpUriRequest): Fiber[Throwable, HttpResponse] =\\n    Fiber.fromFutureJava {\\n        client.execute(request, null)\\n    }\\n\")), mdx(\"h2\", null, \"NIO Completion handler\"), mdx(\"p\", null, \"Java libraries using channels from the NIO API for asynchronous, interruptible I/O can be hooked into by providing completion handlers. As in, reading the contents of a file:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def readFile(file: AsynchronousFileChannel): Task[Chunk[Byte]] = for {\\n    pos <- Ref.make(0)\\n    buf <- ZIO.effectTotal(ByteBuffer.allocate(1024))\\n    contents <- Ref.make[Chunk[Byte]](Chunk.empty)\\n    def go = pos.get.flatMap { p =>\\n        ZIO.effectAsyncWithCompletionHandler[Chunk[Byte]] { handler =>\\n            file.read(buf, p, buf, handler)\\n        }.flatMap {\\n            case -1 => contents.get\\n            case n  =>\\n                ZIO.effectTotal {\\n                    val arr = Array.ofDim[Byte](n)\\n                    buf.get(arr, 0, n)\\n                    buf.clear()\\n                    Chunk.fromArray(arr)\\n                }.flatMap { slice =>\\n                    contents.update(_ ++ slice)\\n                } *> pos.update(_ + n) *> go\\n        }\\n    }\\n    dump <- go\\n} yield dump\\n\")), mdx(\"p\", null, \"As you can see, ZIO provides a CPS-style API here which is a bit different from the two sections above, but hey still super elegant.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core/src/docs/guides/interop/with-java.md"}},"staticQueryHashes":[]}