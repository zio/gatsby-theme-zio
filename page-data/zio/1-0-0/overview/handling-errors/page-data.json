{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio/1-0-0/overview/handling-errors","result":{"data":{"mdx":{"id":"52688bfc-49b3-520f-aaa5-2f8a8b634085","slug":"overview/handling_errors","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"overview_handling_errors\",\n  \"title\": \"Handling Errors\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This section looks at some of the common ways to detect and respond to failure.\"), mdx(\"h2\", null, \"Either\"), mdx(\"p\", null, \"You can surface failures with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#either\"), \", which takes an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO[R, E, A]\"), \" and produces an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO[R, Nothing, Either[E, A]]\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val zeither: UIO[Either[String, Int]] = \\n  IO.fail(\\\"Uh oh!\\\").either\\n\")), mdx(\"p\", null, \"You can submerge failures with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO.absolve\"), \", which is the opposite of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"either\"), \" and turns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO[R, Nothing, Either[E, A]]\"), \" into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO[R, E, A]\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"def sqrt(io: UIO[Double]): IO[String, Double] =\\n  ZIO.absolve(\\n    io.map(value =>\\n      if (value < 0.0) Left(\\\"Value must be >= 0.0\\\")\\n      else Right(Math.sqrt(value))\\n    )\\n  )\\n\")), mdx(\"h2\", null, \"Catching All Errors\"), mdx(\"p\", null, \"If you want to catch and recover from all types of errors and effectfully attempt recovery, you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catchAll\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val z: IO[IOException, Array[Byte]] = \\n  openFile(\\\"primary.json\\\").catchAll(_ => \\n    openFile(\\\"backup.json\\\"))\\n\")), mdx(\"p\", null, \"In the callback passed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catchAll\"), \", you may return an effect with a different error type (or perhaps \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Nothing\"), \"), which will be reflected in the type of effect returned by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catchAll\"), \".\"), mdx(\"h2\", null, \"Catching Some Errors\"), mdx(\"p\", null, \"If you want to catch and recover from only some types of exceptions and effectfully attempt recovery, you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catchSome\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val data: IO[IOException, Array[Byte]] = \\n  openFile(\\\"primary.data\\\").catchSome {\\n    case _ : FileNotFoundException => \\n      openFile(\\\"backup.data\\\")\\n  }\\n\")), mdx(\"p\", null, \"Unlike \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catchAll\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"catchSome\"), \" cannot reduce or eliminate the error type, although it can widen the error type to a broader class of errors.\"), mdx(\"h2\", null, \"Fallback\"), mdx(\"p\", null, \"You can try one effect, or, if it fails, try another effect, with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"orElse\"), \" combinator:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val primaryOrBackupData: IO[IOException, Array[Byte]] = \\n  openFile(\\\"primary.data\\\").orElse(openFile(\\\"backup.data\\\"))\\n\")), mdx(\"h2\", null, \"Folding\"), mdx(\"p\", null, \"Scala's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Option\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Either\"), \" data types have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fold\"), \", which let you handle both failure and success at the same time. In a similar fashion, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO\"), \" effects also have several methods that allow you to handle both failure and success.\"), mdx(\"p\", null, \"The first fold method, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fold\"), \", lets you non-effectfully handle both failure and success, by supplying a non-effectful handler for each case:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"lazy val DefaultData: Array[Byte] = Array(0, 0)\\n\\nval primaryOrDefaultData: UIO[Array[Byte]] = \\n  openFile(\\\"primary.data\\\").fold(\\n    _    => DefaultData,\\n    data => data)\\n\")), mdx(\"p\", null, \"The second fold method, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foldM\"), \", lets you effectfully handle both failure and success, by supplying an effectful (but still pure) handler for each case:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val primaryOrSecondaryData: IO[IOException, Array[Byte]] = \\n  openFile(\\\"primary.data\\\").foldM(\\n    _    => openFile(\\\"secondary.data\\\"),\\n    data => ZIO.succeed(data))\\n\")), mdx(\"p\", null, \"Nearly all error handling methods are defined in terms of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foldM\"), \", because it is both powerful and fast.\"), mdx(\"p\", null, \"In the following example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foldM\"), \" is used to handle both failure and success of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"readUrls\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"val urls: UIO[Content] =\\n  readUrls(\\\"urls.json\\\").foldM(\\n    error   => IO.succeed(NoContent(error)), \\n    success => fetchContent(success)\\n  )\\n\")), mdx(\"h2\", null, \"Retrying\"), mdx(\"p\", null, \"There are a number of useful methods on the ZIO data type for retrying failed effects. \"), mdx(\"p\", null, \"The most basic of these is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#retry\"), \", which takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Schedule\"), \" and returns a new effect that will retry the first effect if it fails, according to the specified policy:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"import zio.clock._\\n\\nval retriedOpenFile: ZIO[Clock, IOException, Array[Byte]] = \\n  openFile(\\\"primary.data\\\").retry(Schedule.recurs(5))\\n\")), mdx(\"p\", null, \"The next most powerful function is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#retryOrElse\"), \", which allows specification of a fallback to use, if the effect does not succeed with the specified policy:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"  openFile(\\\"primary.data\\\").retryOrElse(\\n    Schedule.recurs(5), \\n    (_, _) => ZIO.succeed(DefaultData))\\n\")), mdx(\"p\", null, \"The final method, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ZIO#retryOrElseEither\"), \", allows returning a different type for the fallback.\"), mdx(\"p\", null, \"For more information on how to build schedules, see the documentation on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../datatypes/misc/schedule.md\"\n  }, \"Schedule\"), \".\"), mdx(\"h2\", null, \"Next Steps\"), mdx(\"p\", null, \"If you are comfortable with basic error handling, then the next step is to learn about safe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"handling_resources.md\"\n  }, \"resource handling\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-core/src/docs/overview/handling_errors.md"}},"staticQueryHashes":[]}