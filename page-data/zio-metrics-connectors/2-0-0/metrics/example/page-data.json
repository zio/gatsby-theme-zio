{"componentChunkName":"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js","path":"/zio-metrics-connectors/2-0-0/metrics/example","result":{"data":{"mdx":{"id":"e91f42da-11fc-5e9f-bd90-9cb981509946","slug":"metrics/example","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"metrics_example\",\n  \"title\": \"Instrumentation Examples\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The trait below is used in the ZMX sample application just to show how the individual aspects\\ncan be configured and used. \"), mdx(\"p\", null, \"Please refer to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"statsd.md\"\n  }, \"StatsD\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"prometheus.md\"\n  }, \"Prometheus\"), \" to see how the captured\\nmetrics can be visualized in the supported back ends. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-scala\"\n  }, \"trait InstrumentedSample {\\n\\n  // Create a gauge, it can be applied to effects yielding a Double\\n  val aspGauge1 = Metric.gauge(\\\"gauge1\\\")\\n\\n  val aspGauge2 = Metric.gauge(\\\"gauge2\\\")\\n\\n  // Create a histogram with 12 buckets: 0..100 in steps of 10, Infinite\\n  // It also can be applied to effects yielding a Double\\n  val aspHistogram =\\n    Metric.histogram(\\\"zmxHistogram\\\", MetricKeyType.Histogram.Boundaries.linear(0.0d, 10.0d, 11))\\n\\n  // Create a summary that can hold 100 samples, the max age of the samples is 1 day.\\n  // The summary should report th 10%, 50% and 90% Quantile\\n  // It can be applied to effects yielding an Int\\n  val aspSummary =\\n    Metric.summary(\\\"mySummary\\\", 1.day, 100, 0.03d, Chunk(0.1, 0.5, 0.9)).contramap[Int](_.toDouble)\\n\\n  // Create a Set to observe the occurrences of unique Strings\\n  // It can be applied to effects yielding a String\\n  val aspSet = Metric.frequency(\\\"mySet\\\")\\n\\n  // Create a counter applicable to any effect\\n  val aspCountAll = Metric.counter(\\\"countAll\\\").contramap[Any](_ => 1L)\\n\\n  private lazy val gaugeSomething = for {\\n    _ <- Random.nextDoubleBetween(0.0d, 100.0d) @@ aspGauge1 @@ aspCountAll\\n    _ <- Random.nextDoubleBetween(-50d, 50d) @@ aspGauge2 @@ aspCountAll\\n  } yield ()\\n\\n  // Just record something into a histogram\\n  private lazy val observeNumbers = for {\\n    _ <- Random.nextDoubleBetween(0.0d, 120.0d) @@ aspHistogram @@ aspCountAll\\n    _ <- Random.nextIntBetween(100, 500) @@ aspSummary @@ aspCountAll\\n  } yield ()\\n\\n  // Observe Strings in order to capture unique values\\n  private lazy val observeKey = for {\\n    _ <- Random.nextIntBetween(10, 20).map(v => s\\\"myKey-$v\\\") @@ aspSet @@ aspCountAll\\n  } yield ()\\n\\n  def program: ZIO[Any, Nothing, Unit] = for {\\n    _ <- gaugeSomething.schedule(Schedule.spaced(200.millis)).forkDaemon\\n    _ <- observeNumbers.schedule(Schedule.spaced(150.millis)).forkDaemon\\n    _ <- observeKey.schedule(Schedule.spaced(300.millis)).forkDaemon\\n  } yield ()\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"filePath":"/home/runner/work/gatsby-theme-zio/gatsby-theme-zio/example/node_modules/@atooni/zio-metrics-connectors/src/docs/metrics/example.md"}},"staticQueryHashes":[]}