<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/styles.0d77a1f9790ad3befaea.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><p><code>Ref[A]</code> models a <strong>mutable reference</strong> to a value of type <code>A</code> in which we can store <strong>immutable</strong> data. The two basic operations are <code>set</code>, which fills the <code>Ref</code> with a new value, and <code>get</code>, which retrieves its current content.</p><p><code>Ref</code> provides us a way to functionally manage in-memory state. All operations on <code>Ref</code> are atomic and thread-safe, giving us a reliable foundation for synchronizing concurrent programs.</p><p><code>Ref</code>:</p><ul><li>is purely functional and referentially transparent</li><li>is concurrent-safe and lock-free</li><li>updates and modifies atomically</li></ul><h2>Concurrent Stateful Application</h2><p><strong><code>Ref</code> is the foundation for writing concurrent stateful applications</strong>. Anytime we need to share information between multiple fibers, and those fibers have to update the same information, they need to communicate through something that provides the guarantee of atomicity. Because <code>Ref</code> is <strong>concurrent-safe</strong>, we can share the same <code>Ref</code> among many fibers. All of which can update <code>Ref</code> concurrently, removing the worry of race conditions. Even if we had ten thousand fibers all updating the same <code>Ref</code>, as long as they are using atomic update and modify functions, we will have zero race conditions.</p><h2>Operations</h2><p>Though <code>Ref</code> has many operations, here we will introduce the most common and important ones.</p><h3>make</h3><p><code>Ref</code> is never empty, it always contains something. We can create a <code>Ref</code> by providing the initial value to its <code>make</code> method, a constructor of the <code>Ref</code> data type. We should pass an <strong>immutable value</strong> of type <code>A</code> to the constructor, and it returns an <code>UIO[Ref[A]]</code> value:</p><pre><code class="language-scala">def make[A](a: A): UIO[Ref[A]]
</code></pre><p>As we can see, the output is wrapped in<code>UIO</code>, which means creating a <code>Ref</code> is effectful. Whenever we <code>make</code>, <code>update</code>, or <code>modify</code> the <code>Ref</code>, we are performing an effectful operation.</p><p>Let&#x27;s create some <code>Ref</code>s from immutable values:</p><pre><code class="language-scala">val counterRef = Ref.make(0)
// counterRef: UIO[Ref[Int]] = zio.ZIO$Succeed@205decaf
val stringRef = Ref.make(&quot;initial&quot;) 
// stringRef: UIO[Ref[String]] = zio.ZIO$Succeed@97fb6d 

sealed trait State
case object Active  extends State
case object Changed extends State
case object Closed  extends State

val stateRef = Ref.make(Active) 
// stateRef: UIO[Ref[Active.type]] = zio.ZIO$Succeed@3074a840
</code></pre><blockquote><p><em><strong>Warning</strong></em>:  </p><p>A big mistake when creating a <code>Ref</code> is trying to store mutable data inside it. A<code>Ref</code> must be used with <strong>immutable data</strong>. Otherwise, we lose our atomic guarantees, which can lead to collisions and race conditions. </p></blockquote><p>The following snippet compiles, but it leads to race conditions due to a mutable variable being provided to <code>make</code>:</p><pre><code class="language-scala">// Compiles but don&#x27;t work properly
var init = 0
// init: Int = 0
val counterRef = Ref.make(init)
// counterRef: UIO[Ref[Int]] = zio.ZIO$Succeed@745c1565
</code></pre><p>To correct this, we should change the <code>init</code> to be immutable:</p><pre><code class="language-scala">val init = 0
// init: Int = 0
val counterRef = Ref.make(init)
// counterRef: UIO[Ref[Int]] = zio.ZIO$Succeed@37bec74b
</code></pre><h3>get</h3><p>The <code>get</code> method returns the current value of the reference. Its return type is <code>IO[EB, B]</code> in which <code>B</code> is the value type of the effect and in the failure case, <code>EB</code> is the error type of that effect.</p><pre><code class="language-scala">def get: IO[EB, B]
</code></pre><p>As the <code>make</code> and <code>get</code> methods of <code>Ref</code> are effectful, we can chain them together with <code>flatMap</code>. In the following example, we create a <code>Ref</code> with <code>initial</code> value, and then we acquire the current state with the <code>get</code> method:</p><pre><code class="language-scala">Ref.make(&quot;initial&quot;)
   .flatMap(_.get)
   .flatMap(current =&gt; Console.printLine(s&quot;current value of ref: $current&quot;))
</code></pre><p>We can refactor this to use a for-comprehension rather than a series of <code>flatMap</code>s to increase readability:</p><pre><code class="language-scala">for {
  ref   &lt;- Ref.make(&quot;initial&quot;)
  value &lt;- ref.get
} yield assert(value == &quot;initial&quot;)
</code></pre><p>Note that, there is no way to access the shared state outside the monadic operations.</p><h3>set</h3><p>The <code>set</code> method atomically writes a new value to the <code>Ref</code>.</p><pre><code class="language-scala">for {
  ref   &lt;- Ref.make(&quot;initial&quot;)
  _     &lt;- ref.set(&quot;update&quot;)
  value &lt;- ref.get
} yield assert(value == &quot;update&quot;)
</code></pre><h3>update</h3><p>With <code>update</code>, we can atomically update the state of <code>Ref</code> with a given <strong>pure</strong> function, that is, it needs to be deterministic and free of side effects.</p><pre><code class="language-scala">def update(f: A =&gt; A): IO[E, Unit]
</code></pre><p>Assume we have a counter, we can increase its value with the <code>update</code> method:</p><pre><code class="language-scala">val counterInitial = 0
for {
  counterRef &lt;- Ref.make(counterInitial)
  _          &lt;- counterRef.update(_ + 1)
  value &lt;- counterRef.get
} yield assert(value == 1)
</code></pre><blockquote><p><strong>Note</strong>:  </p><p><code>update</code> is not the composition of <code>get</code> and <code>set</code>. This composition is not concurrent-safe. Whenever we need to update our state, we should use the <code>update</code> operation which modifies its <code>Ref</code> atomically. </p></blockquote><p>For example, the following snippet is not concurrent-safe:</p><pre><code class="language-scala">// Unsafe State Management
object UnsafeCountRequests extends ZIOAppDefault {

  def request(counter: Ref[Int]) = for {
    current &lt;- counter.get
    _ &lt;- counter.set(current + 1)
  } yield ()

  private val initial = 0
  private val myApp =
    for {
      ref &lt;- Ref.make(initial)
      _ &lt;- request(ref) zipPar request(ref)
      rn &lt;- ref.get
      _ &lt;- Console.printLine(s&quot;total requests performed: $rn&quot;)
    } yield ()

  def run = myApp
}
</code></pre><p>The above snippet doesn&#x27;t behave deterministically. This program sometimes prints <code>2</code> and sometimes prints <code>1</code>. We can fix it by using <code>update</code>:</p><pre><code class="language-scala">// Safe State Management
object CountRequests extends ZIOAppDefault {

  def request(counter: Ref[Int]): ZIO[Any, Nothing, Unit] = {
    for {
      _ &lt;- counter.update(_ + 1)
      reqNumber &lt;- counter.get
      _ &lt;- Console.printLine(s&quot;request number: $reqNumber&quot;).orDie
    } yield ()
  }

  private val initial = 0
  private val myApp =
    for {
      ref &lt;- Ref.make(initial)
      _ &lt;- request(ref) zipPar request(ref)
      rn &lt;- ref.get
      _ &lt;- Console.printLine(s&quot;total requests performed: $rn&quot;).orDie
    } yield ()

  def run = myApp
}
</code></pre><p>Here is another use case of <code>update</code> to write a <code>repeat</code> combinator:</p><pre><code class="language-scala">def repeat[E, A](n: Int)(io: IO[E, A]): IO[E, Unit] =
  Ref.make(0).flatMap { iRef =&gt;
    def loop: IO[E, Unit] = iRef.get.flatMap { i =&gt;
      if (i &lt; n)
        io *&gt; iRef.update(_ + 1) *&gt; loop
      else
        ZIO.unit
    }
    loop
  }
</code></pre><h3>modify</h3><p><code>modify</code> is a more powerful version of <code>update</code>. It atomically modifies <code>Ref</code> by the given function, and also computes a return value. The function that we pass to <code>modify</code> needs to be a pure function; it needs to be deterministic and free of side effects.</p><pre><code class="language-scala">def modify[B](f: A =&gt; (B, A)): IO[E, B]
</code></pre><p>Remember the <code>CountRequest</code> example. What if we want to log the number of each request inside the <code>request</code> function? Let&#x27;s see what happens if we write that function with the composition of <code>update</code> and <code>get</code> methods:</p><pre><code class="language-scala">// Unsafe in Concurrent Environment
def request(counter: Ref[Int]) = {
  for {
    _  &lt;- counter.update(_ + 1)
    rn &lt;- counter.get
    _  &lt;- Console.printLine(s&quot;request number received: $rn&quot;)
  } yield ()
}
</code></pre><p>What happens if, between running <code>update</code> and <code>get</code>, a second <code>update</code> occurs on another fiber? This would not behave deterministically in concurrent environments. So we need a way to perform a combination of <strong>get, set, get</strong> atomically. This is where <code>modify</code> comes in. Here we will edit <code>request</code> to use <code>modify</code>:</p><pre><code class="language-scala">// Safe in Concurrent Environment
def request(counter: Ref[Int]) = {
  for {
    rn &lt;- counter.modify(c =&gt; (c + 1, c + 1))
    _  &lt;- Console.printLine(s&quot;request number received: $rn&quot;)
  } yield ()
}
</code></pre><h2>AtomicReference in Java</h2><p>For Java programmers, we can think of <code>Ref</code> as an <code>AtomicReference</code>. Java has a <code>java.util.concurrent.atomic</code> package which contains <code>AtomicReference</code>, <code>AtomicLong</code>, <code>AtomicBoolean</code> and so forth. <code>Ref</code> has roughly the same power, guarantees, and limitations as <code>AtomicReference</code>, but is higher-level and ZIO-friendly. </p><h2>Ref vs. State Monad</h2><p>Basically <code>Ref</code> allows us to have all the power of State Monad inside ZIO. State Monad lacks two important features that we use in real-life application development:</p><ol><li>Concurrency Support</li><li>Error Handling</li></ol><h3>Concurrency</h3><p>State Monad is an effect system that only includes state. It allows us to do pure stateful computations. We can only get, set, and update (and related computations) state. State Monad updates its state with series of stateful computations sequentially, but <strong>it can&#x27;t be used to do async or concurrent computations</strong>. <code>Ref</code>, in contrast, has great support for concurrent and async programming.</p><h3>Error Handling</h3><p>In most real-life,stateful applications, we will involve some database IO and API calls and/or some concurrent and sync operations which can fail in different ways along the path of execution. So besides state management, we need a way to handle errors. The State Monad doesn&#x27;t have the ability to model error management. We can combine State Monad and Either Monad with StateT monad transformer, but it imposes massive performance overhead. It doesn&#x27;t buy us anything that we can&#x27;t do with <code>Ref</code>. So it is an anti-pattern. In the ZIO model, errors are encoded in effects and <code>Ref</code> utilizes that. So, in addition to state management, we have the ability to handle errors without additional work.</p><h2>State Transformers</h2><p>Those who live on the dark side of mutation sometimes have it easy; they can add state everywhere like it&#x27;s Christmas. Behold:</p><pre><code class="language-scala">var idCounter = 0
def freshVar: String = {
  idCounter += 1
  s&quot;var${idCounter}&quot;
}
val v1 = freshVar
val v2 = freshVar
val v3 = freshVar
</code></pre><p>As functional programmers, we know better and have captured state mutation in the form of functions of type <code>S =&gt; (A, S)</code>. <code>Ref</code> provides such an encoding, with <code>S</code> being the type of the value, and <code>modify</code> embodying the state mutation function.</p><pre><code class="language-scala">Ref.make(0).flatMap { idCounter =&gt;
  def freshVar: UIO[String] =
    idCounter.modify(cpt =&gt; (s&quot;var${cpt + 1}&quot;, cpt + 1))

  for {
    v1 &lt;- freshVar
    v2 &lt;- freshVar
    v3 &lt;- freshVar
  } yield ()
}
</code></pre><h2>Building more sophisticated concurrency primitives</h2><p><code>Ref</code> is low-level enough that it can serve as the foundation for other concurrency data types.</p><p>For example, semaphores are a classic abstract data type for controlling access to shared resources. They are defined as a triplet <code>S = (v, P, V)</code> where <code>v</code> is the number of units of the resource that are currently available, and <code>P</code> and <code>V</code> are operations that decrement and increment <code>v</code>, respectively. <code>P</code> will only complete when <code>v</code> is non-negative and must wait if it isn&#x27;t.</p><p>With <code>Ref</code>, it&#x27;s easy to implement such a semaphore! The only difficulty is in <code>P</code>, where we must fail and retry when either <code>v</code> is negative, or its value has changed between the moment we read it and the moment we try to update it. A naive implementation could look like:</p><pre><code class="language-scala">sealed trait S {
  def P: UIO[Unit]
  def V: UIO[Unit]
}

object S {
  def apply(v: Long): UIO[S] =
    Ref.make(v).map { vref =&gt;
      new S {
        def V = vref.update(_ + 1).unit

        def P = (vref.get.flatMap { v =&gt;
          if (v &lt; 0)
            ZIO.fail(())
          else
            vref.modify(v0 =&gt; if (v0 == v) (true, v - 1) else (false, v)).flatMap {
              case false =&gt; ZIO.fail(())
              case true  =&gt; ZIO.unit
            }
        } &lt;&gt; P).unit
      }
    }
}
</code></pre><p>Let&#x27;s rock these crocodile boots we found the other day at the market and test our semaphore at the night club, yee-haw:</p><pre><code class="language-scala">import zio.Console._

val party = for {
  dancefloor &lt;- S(10)
  dancers &lt;- ZIO.foreachPar(1 to 100) { i =&gt;
    dancefloor.P *&gt; Random.nextDouble.map(d =&gt; Duration.fromNanos((d * 1000000).round)).flatMap { d =&gt;
      printLine(s&quot;${i} checking my boots&quot;) *&gt; ZIO.sleep(d) *&gt; printLine(s&quot;${i} dancing like it&#x27;s 99&quot;)
    } *&gt; dancefloor.V
  }
} yield ()
</code></pre><p>It goes without saying you should take a look at ZIO&#x27;s own <code>Semaphore</code>, it does all this and more without wasting all those CPU cycles while waiting.</p></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/2-0-0/datatypes/concurrency/ref";window.___webpackCompilationHash="cdece7bd87ec0e38633f";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0704c8948e63b1196955.js"],"app":["/app-8399cd578ff86df79336.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-f82da7fc8f1ed5d041f7.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/polyfill-0704c8948e63b1196955.js" nomodule=""></script><script src="/app-8399cd578ff86df79336.js" async=""></script><script src="/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/webpack-runtime-90acb813f0122dad9372.js" async=""></script></body></html>