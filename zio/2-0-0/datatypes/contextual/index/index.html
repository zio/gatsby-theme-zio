<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/styles.0d77a1f9790ad3befaea.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><p>ZIO provides a contextual abstraction that encodes the environment of the running effect. This means, every effect can work within a specific context, called an environment.</p><p>So when we have a <code>ZIO[R, E, A]</code> effect, we can say &quot;given <code>R</code> as the environment of the effect, the effect may fail with an error type of <code>E</code>, or may succeed with a value of type <code>A</code>&quot;.</p><p>For example, when we have an effect of type <code>ZIO[DatabaseConnection, IOException, String]</code>, we can say that our effect works within the context of <code>DatabaseConnection</code>. In other words, we can say that our effect requires the <code>DatabaseConnection</code> service as a context to run.</p><p>We will see how layers can be used to eliminate the environment of an effect:</p><pre><code class="language-scala">import zio._

import java.io.IOException

trait DatabaseConnection

// An effect which requires DatabaseConnection to run
val effect: ZIO[DatabaseConnection, IOException, String] = ???

// A layer that produces DatabaseConnection service
val dbConnection: ZLayer[Any, IOException, DatabaseConnection] = ???

// After applying dbConnection to our environmental effect the reurned
// effect has no dependency on the DatabaseConnection
val eliminated: ZIO[Any, IOException, String] = 
  dbConnection { // Provides DatabaseConnection context
    effect       // An effect running within `DatabaseConnection` context
  }
</code></pre><p>ZIO provides this facility through the following concepts and data types:</p><ol><li><a href="#1-zio-environment">ZIO Environment</a> — The <code>R</code> type parameter of <code>ZIO[R, E, A]</code> data type.</li><li><a href="zenvironment.md">ZEnvironment</a> — Built-in type-level map for maintaining the environment of a <code>ZIO</code> data type. </li><li><a href="zlayer.md">ZLayer</a> — Describes how to build one or more services in our application.</li></ol><p>Next, we will discuss <em>ZIO Environment</em> and <em>ZLayer</em> and finally how to write ZIO services using the <em>Service Pattern</em>.</p><h2>1. ZIO Environment</h2><p>The <code>ZIO[-R, +E, +A]</code> data type describes an effect that requires an input of type <code>R</code>, as an environment, may fail with an error of type <code>E</code>, or succeed with a value of type <code>A</code>.</p><p>The input type is also known as <em>environment type</em>. This type-parameter indicates that to run an effect we need one or some services as an environment of that effect. In other word, <code>R</code> represents the <em>requirement</em> for the effect to run, meaning we need to fulfill the requirement in order to make the effect <em>runnable</em>.</p><p>So we can think of <code>ZIO[R, E, A]</code> as a mental model of a function from a value of type <code>R</code> to the <code>Either[E, A]</code>:</p><pre><code class="language-scala">type ZIO[R, E, A] = R =&gt; Either[E, A]
</code></pre><p><code>R</code> represents dependencies; whatever services, config, or wiring a part of a ZIO program depends upon to work. We will explore what we can do with <code>R</code>, as it plays a crucial role in <code>ZIO</code>.</p><p>We don&#x27;t need to provide live layers for built-in services (Layers will be discussed later on this page). ZIO has a <code>ZEnv</code> type alias for the composition of all ZIO built-in services (<code>Clock</code>, <code>Console</code>, <code>System</code>, <code>Random</code>, and <code>Blocking</code>). So we can run the above <code>effect</code> as follows:</p><pre><code class="language-scala">import zio._

object MainApp extends ZIOAppDefault {
  def run = effect
  
  val effect: ZIO[Any, Nothing, Unit] = for {
    r &lt;- Random.nextInt
    _ &lt;- Console.printLine(s&quot;random number: $r&quot;).orDie
  } yield ()
}
</code></pre><h3>Motivation</h3><p>One might ask &quot;What is the motivation behind encoding the dependency in the type parameter of <code>ZIO</code> data type&quot;? What is the benefit of doing so?</p><p>Let&#x27;s see how writing an application which requires reading from or writing to the console. As part of making the application <em>modular</em> and <em>testable</em> we define a separate service called <code>Console</code> which is responsible for reading from and writing to the console. We do that simply by writing an interface:</p><pre><code class="language-scala">import zio._

trait Console {
  def print(line: Any): Task[Unit]

  def printLine(line: Any): Task[Unit]

  def readLine: Task[String]
}
</code></pre><p>Now we can write our application that accepts the <code>Console</code> interface as a parameter:</p><pre><code class="language-scala">import zio._

def myApp(c: Console): Task[Unit] =
  for {
    _    &lt;- c.print(&quot;Please enter your name: &quot;)
    name &lt;- c.readLine
    _    &lt;- c.printLine(s&quot;Hello, $name!&quot;)
  } yield ()
</code></pre><p>Similar to the object-oriented paradigm we code to interface not implementation. In order to run the application, we need to implement a production version of the <code>Console</code>:</p><pre><code class="language-scala">import zio._

object ConsoleLive extends Console {
  override def print(line: Any): Task[Unit] =
    ZIO.attemptBlocking(scala.Predef.print(line))

  override def printLine(line: Any): Task[Unit] =
    ZIO.attemptBlocking(scala.Predef.println(line))

  override def readLine: Task[String] =
    ZIO.attemptBlocking(scala.io.StdIn.readLine())
}
</code></pre><p>Finally, we can provide the <code>ConsoleLive</code> to our application and run the whole:</p><pre><code class="language-scala">import zio._

object MainApp extends ZIOAppDefault {
  def myApp(c: Console): Task[Unit] =
    for {
      _    &lt;- c.print(&quot;Please enter your name: &quot;)
      name &lt;- c.readLine
      _    &lt;- c.printLine(s&quot;Hello, $name!&quot;)
    } yield ()

  def run = myApp(ConsoleLive)
}
</code></pre><p>In the above example, we discard the fact that we could use the ZIO environment and utilize the <code>R</code> parameter of the <code>ZIO</code> data type. So instead we tried to write the application with the <code>Task</code> data type, which ignores the ZIO environment. To create our application testable, we gathered all console functionalities into the same interface called <code>Console</code>, and implemented that in another object called <code>ConsoleLive</code>. Finally, at the end of the day, we provide the implementation of the <code>Console</code> service, i.e. <code>ConsoleLive</code>, to our application.</p><p><strong>While this technique works for small programs, it doesn&#x27;t scale.</strong> Assume we have multiple services, and we use them in our application logic like below:</p><pre><code class="language-scala">def foo(
   s1: Service1,
   s2: Service2,
   s3: Service3
)(arg1: String, arg2: String, arg3: Int): Task[Int] = ???

def bar(
  s1: Service1,
  s12: Service12,
  s18: Service18, 
  sn: ServiceN
)(arg1: Int, arg2: String, arg3: Double, arg4: Int): Task[Unit]

def myApp(s1: Service1, s2: Service2, ..., sn: ServiceN): Task[Unit] = 
  for {
    a &lt;- foo(s1, s2, s3)(&quot;arg1&quot;, &quot;arg2&quot;, 4) 
    _ &lt;- bar(s1, s12, s18, sn)(7, &quot;arg2&quot;, 1.2, a)
      ...
  } yield ()
</code></pre><p>Writing real applications using this technique is tedious and cumbersome because all dependencies have to be passed across all methods. We can simplify the process of writing our application by using the ZIO environment and <a href="#service-pattern">Service Pattern</a>:</p><pre><code class="language-scala">def foo(arg1: String, arg2: String, arg3: Int): ZIO[Service1 &amp; Service2 &amp; Service3, Throwable, Int] = 
  for {
    s1 &lt;- ZIO.service[Service1]
    s2 &lt;- ZIO.service[Service2] 
      ...
  } yield ()

def bar(arg1: Int, arg2: String, arg3: Double, arg4: Int): ZIO[Service1 &amp; Service12 &amp; Service18 &amp; ServiceN, Throwable, Unit] =
  for {
    s1  &lt;- ZIO.service[Service1] 
    s12 &lt;- ZIO.service[Service12]
      ...
  } yield ()
</code></pre><h3>Advantage of Using ZIO Environment</h3><p>ZIO environment facility enables us to:</p><ol><li><p><strong>Code to Interface</strong> — Like object-oriented paradigm, in ZIO we are encouraged to code to interface and defer the implementation. It is the best practice, but ZIO does not enforce us to do that.</p></li><li><p><strong>Write a Testable Code</strong> — By coding to an interface, whenever we want to test our effects, we can easily mock any external services, by providing a <em>test</em> version of those instead of the <em>live</em> version.</p></li><li><p><strong>Compose Services with Strong Type Inference Facility</strong> — We can compose multiple effects that require various services, so the final effect requires the intersection of all those services:</p></li></ol><pre><code class="language-scala">import zio._

trait ServiceA
trait ServiceB
trait ServiceC

// Requires ServiceA and produces a value of type Int
def foo: ZIO[ServiceA, Nothing, Int] = ???

// Requires ServiceB and ServiceC and produces a value of type String
def bar: ZIO[ServiceB &amp; ServiceC, Throwable, String] = ???

// Requires ServicB and produces a value of type Double
def baz(a: Int, b: String): ZIO[ServiceB, Nothing, Double] = ???

// Requires ServiceB and ServiceB and ServiceC and produces a value of type Double
val myApp: ZIO[ServiceA &amp; ServiceB &amp; ServiceC, Throwable, Double] =
  for {
    a &lt;- foo
    b &lt;- bar
    c &lt;- baz(a, b)
  } yield c
</code></pre><p>Another important note about the ZIO environment is that the type inference works well on effect composition. After we composed all the application logic together, the compiler and also IDE can infer the proper type for the environment of the final effect.</p><p>In the example above, the compiler can infer the environment type of the <code>myApp</code> effect which is <code>ServiceA &amp; ServiceB &amp; ServiceC</code>.</p><h3>Accessing ZIO Environment</h3><p>We have two types of accessors for the ZIO environment:</p><ol><li><strong>Service Accessor (<code>ZIO.service</code>)</strong> is used to access a specific service from the environment.</li><li><strong>Service Member Accessors (<code>ZIO.serviceWith</code> and <code>ZIO.serviceWithZIO</code>)</strong> are used to access capabilities of a specific service from the environment.</li></ol><blockquote><p><strong>Note</strong>:</p><p>To access the entire ZIO environment we can use <code>ZIO.environment*</code>, but we do not use these methods regularly to access ZIO services. Instead, we use service accessors and service member accessors.</p></blockquote><h4>Service Accessor</h4><p>To access a service from the ZIO environment, we can use the <code>ZIO.service</code> constructor. For example, in the following program we are going to access the <code>AppConfig</code> from the environment:</p><pre><code class="language-scala">import zio._

case class AppConfig(host: String, port: Int)

val myApp: ZIO[AppConfig, Nothing, Unit] =
  for {
    config &lt;- ZIO.service[AppConfig]
    _      &lt;- ZIO.logInfo(s&quot;Application started with config: $config&quot;)
  } yield ()
</code></pre><p>To run the <code>myApp</code> effect, we should provide the <code>AppConfig</code> layer (we will talk about <code>ZLayer</code> on the next section):</p><pre><code class="language-scala">object MainApp extends ZIOAppDefault {
  def run = myApp.provide(ZLayer.succeed(AppConfig(&quot;localhost&quot;, 8080)))
}
</code></pre><p>To access multiple services from the ZIO environment, we can do the same:</p><pre><code class="language-scala">import zio._

trait Foo
trait Bar
trait Baz

for {
  foo &lt;- ZIO.service[Foo]  
  bar &lt;- ZIO.service[Bar]
  bax &lt;- ZIO.service[Baz]
} yield ()
</code></pre><p>When creating ZIO layers that have multiple dependencies, this can be helpful. We will discuss this pattern in the <a href="#service-pattern">Service Pattern</a> section.</p><h4>Service Member Accessors</h4><p>Sometimes instead of accessing a service, we need to access the capabilities (members) of a service. Based on the return type of each capability, we can use one of these accessors:</p><ul><li><strong>ZIO.serviceWith</strong></li><li><strong>ZIO.serviceWithZIO</strong></li></ul><p>In <a href="#service-pattern">Service Pattern</a>, we use these accessors to write &quot;accessor methods&quot; for ZIO services.</p><p>Let&#x27;s look at each one in more detail:</p><ol><li><strong>ZIO.serviceWith</strong> — When we are accessing service members whose return type is an ordinary value, we should use the <code>ZIO.serviceWith</code>.</li></ol><p>In the following example, we need to use the <code>ZIO.serviceWith</code> to write accessor methods for all of the <code>AppConfig</code> members:</p><pre><code class="language-scala">import zio._

case class AppConfig(host: String, port: Int, poolSize: Int)

object AppConfig {
  // Accessor Methods
  def host: ZIO[AppConfig, Nothing, String]  = ZIO.serviceWith(_.host) 
  def port: ZIO[AppConfig, Nothing, Int]     = ZIO.serviceWith(_.port)
  def poolSize: ZIO[AppConfig, Nothing, Int] = ZIO.serviceWith(_.poolSize)
}

val myApp: ZIO[AppConfig, Nothing, Unit] =
  for {
    host     &lt;- AppConfig.host
    port     &lt;- AppConfig.port
    _        &lt;- ZIO.logInfo(s&quot;The service will be service at $host:$port&quot;)
    poolSize &lt;- AppConfig.poolSize
    _        &lt;- ZIO.logInfo(s&quot;Application started with $poolSize pool size&quot;)
  } yield ()
</code></pre><ol start="2"><li><strong>ZIO.serviceWithZIO</strong> — When we are accessing service members whose return type is a ZIO effect, we should use the <code>ZIO.serviceWithZIO</code>.</li></ol><p>For example, in order to write the accessor method for the <code>log</code> member of the <code>Logging</code> service, we need to use the <code>ZIO.serviceWithZIO</code> function:</p><pre><code class="language-scala">import zio._

trait Logging {
  def log(line: String): Task[Unit]
}

object Logging {
  // Accessor Methods:
  def log(line: String): ZIO[Logging, Throwable, Unit] =
    ZIO.serviceWithZIO(_.log(line))
}

val myApp: ZIO[Logging &amp; Console, Throwable, Unit] =
  for {
    _    &lt;- Logging.log(&quot;Application Started!&quot;)
    _    &lt;- Console.print(&quot;Please enter your name: &quot;)
    name &lt;- Console.readLine
    _    &lt;- Console.printLine(s&quot;Hello, $name!&quot;)
    _    &lt;- Logging.log(&quot;Application exited!&quot;)
  } yield ()
</code></pre><h2>2. ZEnvironment</h2><p><code>ZEnvironment</code> is a built-in type-level map for maintaining the environment of a <code>ZIO</code> data type. We don&#x27;t typically use this data type directly. It&#x27;s okay to skip learning it at the moment. We have a <a href="zenvironment.md">separate article</a> about this data type.</p><h2>3. ZLayer</h2><p><code>ZLayer[-RIn, +E, +ROut]</code> is a recipe to build an environment of type <code>ROut</code>, starting from a value <code>RIn</code>, and possibly producing an error <code>E</code> during creation.</p><p><code>ZLayer</code> combined with the <em>ZIO Environment</em>, allow us to use ZIO for <em>dependency injection</em>. There are two parts of dependency injection:</p><ol><li><strong>Building Dependency Graph</strong></li><li><strong>Dependency Propagation</strong></li></ol><p>ZIO has a full solution to the dependency injection problem. It solves the first problem by using <a href="zlayer.md#manual-layer-construction">compositional properties</a> of <code>ZLayer</code>. Assume we have several services with their dependencies, and we need a way to compose and wire up these dependencies to create the dependency graph of the application. <code>ZLayer</code> is a ZIO solution for this problem. It allows us to build up the whole application dependency graph by composing layers horizontally and vertically. </p><p>ZIO also solves the second problem by using <a href="zlayer.md#dependency-propagation">ZIO Environment facilities like <code>ZIO#provide</code></a>.</p><blockquote><p><strong>Note:</strong></p><p>By using ZLayer and ZIO Environment we can solve the propagation and wire-up problems in dependency injection. Note that we are not enforced to use this approach, as we can still use things like <a href="https://github.com/google/guice">Guice</a> with ZIO, or we might like to use <a href="https://izumi.7mind.io/distage/index.html">izumi distage</a> solution for dependency injection.</p></blockquote><h2>Defining ZIO Services</h2><p>Defining services in ZIO is not very different from object-oriented style, it has the same principle: coding to an interface, not an implementation. Therefore, ZIO encourages us to implement this principle by using <em>Service Pattern</em>, which is quite similar to the object-oriented style.</p><p>Before diving into writing services in ZIO style, let&#x27;s review how we define them in an object-oriented fashion in the next section.</p><h3>Defining Services in OOP</h3><p>Here are the steps we take to implement a service in object-oriented programming:</p><ol><li><strong>Service Definition</strong> — In object-oriented programming, we define services with traits. A service is a bundle of related functionality that is defined in a trait:</li></ol><pre><code class="language-scala">trait FooService {

}
</code></pre><ol start="2"><li><strong>Service Implementation</strong> — We implement these services by using classes:</li></ol><pre><code class="language-scala">class FooServiceImpl extends FooService {
    
}
</code></pre><ol start="3"><li><strong>Defining Dependencies</strong> — If the creation of a service depends on other services, we can define these dependencies by using constructors:</li></ol><pre><code class="language-scala">trait ServiceA {

}

trait ServiceB {

}

class FooServiceImpl(a: ServiceA, b: ServiceB) {

}
</code></pre><p>In object-oriented programming, the best practice is to <em>program to an interface, not an implementation</em>. So in the previous example, <code>ServiceA</code> and <code>ServiceB</code> are interfaces, not concrete classes.</p><ol start="4"><li><strong>Injecting Dependencies</strong> — Now, the client of <code>FooServiceImpl</code> service can provide its own implementation of <code>ServiceA</code> and <code>ServiceB</code>, and inject them to the <code>FooServiceImpl</code> constructor:</li></ol><pre><code class="language-scala">class ServiceAImpl extends ServiceA
class ServiceBImpl extends ServiceB
val fooService = new FooServiceImpl(new ServiceAImpl, new ServiceBImpl)
</code></pre><p>Sometimes, as the number of dependent services grows and the dependency graph of our application becomes complicated, we need an automatic way of wiring and providing dependencies into the services of our application. In these situations, we might use a dependency injection framework to do all its magic machinery for us.</p><h3>Defining Services in ZIO</h3><p>A service is a group of functions that deals with only one concern. Keeping the scope of each service limited to a single responsibility improves our ability to understand code, in that we need to focus only on one topic at a time without juggling too many concepts together in our head.</p><p><code>ZIO</code> itself provides the basic capabilities through modules, e.g. see how <code>ZEnv</code> is defined.</p><p>In functional Scala as well as in object-oriented programming the best practice is to <em>Program to an Interface, Not an Implementation</em>. This is the most important design principle in software development and helps us to write maintainable code by:</p><ul><li><p>Allowing the client to hold an interface as a contract and don&#x27;t worry about the implementation. The interface signature determines all operations that should be done.</p></li><li><p>Enabling a developer to write more testable programs. When we write a test for our business logic we don&#x27;t have to run and interact with real services like databases which makes our test run very slow. If our code is correct our test code should always pass, there should be no hidden variables or depend on outside sources. We can&#x27;t know that the database is always running correctly. We don&#x27;t want to fail our tests because of the failure of external service.</p></li><li><p>Providing the ability to write more modular applications. So we can plug in different implementations for different purposes without a major modification.</p></li></ul><p>It is not mandatory, but ZIO encourages us to follow this principle by bundling related functionality as an interface by using the <em>Service Pattern</em>.</p><p>The core idea is that a layer depends upon the interfaces exposed by the layers immediately below itself, but is completely unaware of its dependencies&#x27; internal implementations.</p><p>In object-oriented programming:</p><ul><li><strong>Service Definition</strong> is done by using <em>interfaces</em> (Scala trait or Java Interface).</li><li><strong>Service Implementation</strong> is done by implementing interfaces using <em>classes</em> or creating <em>new object</em> of the interface.</li><li><strong>Defining Dependencies</strong> is done by using <em>constructors</em>. They allow us to build classes, given their dependencies. This is called constructor-based dependency injection.</li></ul><p>We have a similar analogy in the Service Pattern, except instead of using <em>constructors</em> we use <strong><code>ZLayer</code></strong> to define dependencies. So in ZIO fashion, we can think of <code>ZLayer</code> as a service constructor.</p><h3>Service Pattern</h3><p>Writing services in ZIO using the <em>Service Pattern</em> is very similar to the object-oriented way of defining services. We use scala traits to define services, classes to implement services, and constructors to define service dependencies. Finally, we lift the class constructor into the <code>ZLayer</code>.</p><p>Let&#x27;s start learning this service pattern by writing a <code>Logging</code> service:</p><ol><li><strong>Service Definition</strong> — Traits are how we define services. A service could be all the stuff that is related to one concept with singular responsibility. We define the service definition with a trait named <code>Logging</code>:</li></ol><pre><code class="language-scala">trait Logging {
  def log(line: String): UIO[Unit]
}
</code></pre><ol start="2"><li><strong>Service Implementation</strong> — It is the same as what we did in an object-oriented fashion. We implement the service with the Scala class. By convention, we name the live version of its implementation as <code>LoggingLive</code>:</li></ol><pre><code class="language-scala">case class LoggingLive() extends Logging {
  override def log(line: String): UIO[Unit] = 
    ZIO.succeed(print(line))
}
</code></pre><ol start="3"><li><strong>Define Service Dependencies</strong> — We might need <code>Console</code> and <code>Clock</code> services to implement the <code>Logging</code> service. Here, we put its dependencies into its constructor. All the dependencies are just interfaces, not implementation. Just like what we did in object-oriented style:</li></ol><pre><code class="language-scala">case class LoggingLive(console: Console, clock: Clock) extends Logging {
  override def log(line: String): UIO[Unit] = 
    for {
      current &lt;- clock.currentDateTime
      _       &lt;- console.printLine(s&quot;$current--$line&quot;).orDie
    } yield ()
}
</code></pre><ol start="4"><li><strong>Defining ZLayer</strong> — Now, we create a companion object for <code>LoggingLive</code> data type and lift the service implementation into the <code>ZLayer</code>:</li></ol><pre><code class="language-scala">object LoggingLive {
  val layer: URLayer[Any, Logging] =
    ZLayer {
      for {
        console &lt;- ZIO.console
        clock   &lt;- ZIO.clock
      } yield LoggingLive(console, clock)
    }
}
</code></pre><p>Note that the previous step is syntactic sugar of writing the layer directly in combination with for-comprehension style of accessing the ZIO environment:</p><pre><code class="language-scala">object LoggingLive {
  val layer: ZLayer[Any, Nothing, Logging] =
    ZLayer {
      for {
        console &lt;- ZIO.service[Console]
        clock   &lt;- ZIO.service[Clock]
      } yield LoggingLive(console, clock)
    }
}
</code></pre><ol start="5"><li><strong>Accessor Methods</strong> — Finally, to create the API more ergonomic, it&#x27;s better to write accessor methods for all of our service methods using <code>ZIO.serviceWithZIO</code> constructor inside the companion object:</li></ol><pre><code class="language-scala">object Logging {
  def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO[Logging](_.log(line))
}
</code></pre><p>Accessor methods allow us to utilize all the features inside the service through the ZIO Environment. That means, if we call <code>Logging.log</code>, we don&#x27;t need to pull out the <code>log</code> function from the ZIO Environment. The <code>ZIO.serviceWithZIO</code> constructor helps us to access the environment and reduce the redundant operations, every time.</p><p>This is how ZIO services are created. Let&#x27;s use the <code>Logging</code> service in our application. We should provide the live layer of the <code>Logging</code> service to be able to run the application:</p><pre><code class="language-scala">import zio._
import java.io.IOException

object MainApp extends ZIOAppDefault {
  val app: ZIO[Logging, IOException, Unit] =
    for {
      _    &lt;- Logging.log(&quot;Application Started!&quot;)
      _    &lt;- Console.print(&quot;Enter your name:&quot;)
      name &lt;- Console.readLine
      _    &lt;- Console.printLine(s&quot;Hello, $name!&quot;)
      _    &lt;- Logging.log(&quot;Application Exited!&quot;)
    } yield ()

  def run = app.provide(LoggingLive.layer)
}
</code></pre><p>During writing the application, we don&#x27;t care which implementation version of the <code>Logging</code> service will be injected into our <code>app</code>, later at the end of the day, it will be provided by one of <code>ZIO#provide*</code> methods.</p><p>That&#x27;s it! Very simple! ZIO encourages us to follow some of the best practices in object-oriented programming. So it doesn&#x27;t require us to throw away all our object-oriented knowledge.</p><h3>Defining Polymorphic Services in ZIO</h3><p>As we discussed <a href="zenvironment.md">here</a>, the <code>ZEnvironment</code>, which is the underlying data type used by <code>ZLayer</code>, is backed by a type-level mapping from types of services to implementations of those services. This functionality is backed by <code>izumi.reflect.Tag</code>, which captures a type as a value. </p><p>We just need to know what is the type of service when we put it in the <code>ZEnvironment</code> because <code>ZEnvironment</code> is essentially a map from <em>service types (interfaces)</em> to <em>implementation of those interfaces</em>. To implement the map, the <code>ZEnvironment</code> needs a type tag for the new service, and also needs a way to remove the old service from the type level map. So we should have service type information at the runtime. </p><p>We can think of <code>Tag[A]</code> as like a <code>TypeTag[A]</code> or <code>ClassTag[A]</code> from the Scala standard library but available on a cross-version and cross-platform basis. Basically, it carries information about a certain type into runtime that was available at compile time. Methods that construct <code>ZEnvironment</code> values generally require a tag for the value being included in the “bundle of services”. </p><p>As a user, we should not normally interact with <code>Tag</code> except where we define polymorphic services. In general, a <code>Tag</code> should always be available whenever we have a concrete type. The only time we should have to use it is when we have a <em>polymorphic service</em>. If we are using polymorphic code, we need to provide implicit evidence that a tag exists for that type (<code>implicit tag: Tag[A]</code>) or as a context-bound for that type parameter: (<code>A: Tag</code>).</p><p>Let&#x27;s try to write a polymorphic service. Assume we have the following service interface:</p><pre><code class="language-scala">trait KeyValueStore[K, V, E, F[_, _]] {
  def get(key: K): F[E, V]

  def set(key: K, value: V): F[E, V]

  def remove(key: K): F[E, Unit]
}
</code></pre><p>In the next step, we are going to write its accessors. We might end up with the following snippet code:</p><pre><code class="language-scala">import zio._

object KeyValueStore {
  def get[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =
    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))

  def set[K, V, E](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =
    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))

  def remove[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =
    ZIO.serviceWithZIO(_.remove(key))
}

// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...
// 
// 
// &lt;trace&gt;: 
//   deriving Tag for K, dealiased: K:
//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!
//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))
//                                                   ^
// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...
// 
// 
// &lt;trace&gt;: 
//   deriving Tag for K, dealiased: K:
//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!
//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))
//                                                   ^
// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...
// 
// 
// &lt;trace&gt;: 
//   deriving Tag for K, dealiased: K:
//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!
//     ZIO.serviceWithZIO(_.remove(key))
//                       ^
</code></pre><p>The compiler generates the following errors:</p><pre><code>could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...


&lt;trace&gt;: 
  deriving Tag for K, dealiased: K:
  could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!
    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))
</code></pre><p>As the compiler says, we should put <code>Tag</code> as a context-bound for <code>K</code>, <code>V</code>, and <code>E</code> type parameters:</p><pre><code class="language-scala">import zio._

object KeyValueStore {
  def get[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =
    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))

  def set[K: Tag, V: Tag, E: Tag](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =
    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))

  def remove[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =
    ZIO.serviceWithZIO(_.remove(key))
}
</code></pre><p>Now, we can continue and implement the in-memory version of this key-value store:</p><pre><code class="language-scala">case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])
  extends KeyValueStore[String, Int, String, IO] {

  override def get(key: String): IO[String, Int] =
    map.get.map(_.get(key)).someOrFail(s&quot;$key not found&quot;)

  override def set(key: String, value: Int): IO[String, Int] =
    map.update(_.updated(key, value)).map(_ =&gt; value)

  override def remove(key: String): IO[String, Unit] =
    map.update(_.removed(key))
}

object InmemoryKeyValueStore {
  def layer: ULayer[KeyValueStore[String, Int, String, IO]] =
    ZLayer {
      Ref.make(Map[String, Int]()).map(InmemoryKeyValueStore.apply)
    }
}
</code></pre><p>The last step is to use the service in a ZIO application:</p><pre><code class="language-scala">import zio._

object MainApp extends ZIOAppDefault {

  val myApp: ZIO[KeyValueStore[String, Int, String, IO], String, Unit] =
    for {
      _ &lt;- KeyValueStore.set[String, Int, String](&quot;key1&quot;, 3).debug
      _ &lt;- KeyValueStore.get[String, Int, String](&quot;key1&quot;).debug
      _ &lt;- KeyValueStore.remove[String, Int, String](&quot;key1&quot;)
      _ &lt;- KeyValueStore.get[String, Int, String](&quot;key1&quot;).either.debug
    } yield ()

  def run = myApp.provide(InmemoryKeyValueStore.layer)
  
}
</code></pre><p>Note that in the above example, one might want to write accessors more polymorphic. So in this case we should add <code>TagKK</code> as a context-bound of the <code>F</code> type parameter:</p><pre><code class="language-scala">object KeyValueStore {
  def get[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =
    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.get(key))

  def set[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K, value: V): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =
    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.set(key, value))

  def remove[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], E, Unit] =
    ZIO.serviceWith(_.remove(key))
}
</code></pre><h3>Generating Accessor Methods Using Macros</h3><p>Writing accessor methods is a repetitive task and would be cumbersome in services with many methods. We can automate the generation of accessor methods using <code>zio-macro</code> module. </p><p>To install the <code>zio-macro</code> we should add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;dev.zio&quot; %% &quot;zio-macros&quot; % &quot;&lt;zio-version&gt;&quot;
</code></pre><p>Also, to enable macro expansion we need to setup our project:</p><ul><li><p>for Scala <code>&gt;= 2.13</code> add compiler option:</p><pre><code class="language-scala">scalacOptions += &quot;-Ymacro-annotations&quot;
</code></pre></li><li><p>for Scala <code>&lt; 2.13</code> add macro paradise compiler plugin:</p><pre><code class="language-scala">compilerPlugin((&quot;org.scalamacros&quot; % &quot;paradise&quot;  % &quot;2.1.1&quot;) cross CrossVersion.full)
</code></pre></li></ul><blockquote><p><strong>Note:</strong></p><p>At the moment these are only available for Scala versions <code>2.x</code>, however their equivalents for Scala 3 are on our roadmap.</p></blockquote><h4>Monomorphic Services</h4><p>We can use the <code>@accessible</code> macro to generate <em>service member accessors</em>:</p><pre><code class="language-scala">import zio._
import zio.macros.accessible

@accessible
trait ServiceA {
  def method(input: Something): UIO[Unit]
}

// below will be autogenerated
object ServiceA {
  def method(input: Something) =
    ZIO.serviceWithZIO[ServiceA](_.method(event))
}
</code></pre><p>For normal values, a <code>ZIO</code> with <code>Nothing</code> on error channel is generated:</p><pre><code class="language-scala">import zio._
import zio.macros.accessible

@accessible
trait ServiceB {
  def pureMethod(input: Something): SomethingElse
}

// below will be autogenerated
object ServiceB {
  def pureMethod(input: Something): ZIO[ServiceB, Nothing, SomethingElse] =
    ZIO.serviceWith[ServiceB](_.pureMethod(input))
}
</code></pre><p>The <code>@throwing</code> annotation will mark impure methods. Using this annotation will request ZIO to push the error on the error channel:</p><pre><code class="language-scala">import zio._
import zio.macros.accessible
import zio.macros.throwing

@accessible
trait ServiceC {
  @throwing
  def impureMethod(input: Something): SomethingElse
}

// below will be autogenerated
object ServiceC {
  def impureMethod(input: Something): ZIO[ServiceC, Throwable, SomethingElse] =
    ZIO.serviceWithZIO[ServiceC](s =&gt; ZIO(s.impureMethod(input)))
}
</code></pre><p>Below is a fully working example:</p><pre><code class="language-scala">import zio._
import zio.macros.accessible

@accessible
trait KeyValueStore {
  def set(key: String, value: Int): Task[Int]

  def get(key: String): Task[Int]
}


case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])
  extends KeyValueStore {
  override def set(key: String, value: Int): Task[Int] =
    map.update(_.updated(key, value)).map(_ =&gt; value)

  override def get(key: String): Task[Int] =
    map.get.map(_.get(key)).someOrFailException
}

object InmemoryKeyValueStore {
  val layer: ULayer[KeyValueStore] =
    ZLayer {
      for {
        map &lt;- Ref.make(Map[String, Int]())
      } yield InmemoryKeyValueStore(map)
    }
}

object MainApp extends ZIOAppDefault {
  val myApp =
    for {
      _   &lt;- KeyValueStore.set(&quot;key&quot;, 5)
      key &lt;- KeyValueStore.get(&quot;key&quot;)
    } yield key
    
  def run = myApp.provide(InmemoryKeyValueStore.layer).debug
}
</code></pre><h4>Writing Polymorphic Services</h4><h5>With Proper Type Parameters</h5><p>If the service is polymorphic for some proper types, we can use the <code>@accessible</code> macro like previous examples.</p><p>Assume we have a <code>KeyValueStore</code> like below, as we will see using <code>@accessible</code> will generate us the accessor methods:</p><pre><code class="language-scala">import zio._
import zio.macros.accessible


@accessible
trait KeyValueStore[K, V] {
  def set(key: K, value: V): Task[V]

  def get(key: K): Task[V]
}


case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])
  extends KeyValueStore[String, Int] {
  override def set(key: String, value: Int): Task[Int] =
    map.update(_.updated(key, value)).map(_ =&gt; value)

  override def get(key: String): Task[Int] =
    map.get.map(_.get(key)).someOrFailException
}

object InmemoryKeyValueStore {
  val layer: ULayer[KeyValueStore[String, Int]] =
    ZLayer {
      for {
        map &lt;- Ref.make(Map[String, Int]())
      } yield InmemoryKeyValueStore(map)
    }
}

object MainApp extends ZIOAppDefault {
  val myApp =
    for {
      _ &lt;- KeyValueStore.set(&quot;key&quot;, 5)
      key &lt;- KeyValueStore.get[String, Int](&quot;key&quot;)
    } yield key

  def run = myApp.provide(InmemoryKeyValueStore.layer).debug
}
</code></pre><h5>With Higher-Kinded Type Parameters (<code>F[_]</code>)</h5><p>If a service has a higher-kinded type parameter like <code>F[_]</code> we should use the <code>accessibleM</code> macro. Here is an example of such a service:</p><pre><code class="language-scala">import zio._
import zio.macros.accessibleM

@accessibleM[Task]
trait KeyValueStore[K, V, F[_]] {
  def set(key: K, value: V): F[V]

  def get(key: K): F[V]
}

case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])
  extends KeyValueStore[String, Int, Task] {
  override def set(key: String, value: Int): Task[Int] =
    map.update(_.updated(key, value)).map(_ =&gt; value)

  override def get(key: String): Task[Int] =
    map.get.map(_.get(key)).someOrFailException

}

object InmemoryKeyValueStore {
  val layer: ULayer[KeyValueStore[String, Int, Task]] =
    ZLayer {
      for {
        map &lt;- Ref.make(Map[String, Int]())
      } yield InmemoryKeyValueStore(map)
    }
}


object MainApp extends ZIOAppDefault {
  val myApp =
    for {
      key &lt;- KeyValueStore.set[String, Int](&quot;key&quot;, 5)
      _   &lt;- KeyValueStore.get[String, Int](&quot;key&quot;)
    } yield key

  def run = myApp.provide(InmemoryKeyValueStore.layer).debug
}

</code></pre><h5>With Higher-Kinded Type Parameters (<code>F[_, _]</code>)</h5><p>If the service has a higher-kinded type parameter like <code>F[_, _]</code> we should use the <code>accessibleMM</code> macro. Let&#x27;s see an example:</p><pre><code class="language-scala">import zio._
import zio.macros.accessibleMM

@accessibleMM[IO]
trait KeyValueStore[K, V, E, F[_, _]] {
  def set(key: K, value: V): F[E, V]

  def get(key: K): F[E, V]
}

case class InmemoryKeyValueStore(map: Ref[Map[String, Int]])
  extends KeyValueStore[String, Int, String, IO] {
  override def set(key: String, value: Int): IO[String, Int] =
    map.update(_.updated(key, value)).map(_ =&gt; value)

  override def get(key: String): IO[String, Int] =
    map.get.map(_.get(key)).someOrFail(s&quot;key not found: $key&quot;)
}

object InmemoryKeyValueStore {
  val layer: ULayer[KeyValueStore[String, Int, String, IO]] =
    ZLayer {
      for {
        map &lt;- Ref.make(Map[String, Int]())
      } yield InmemoryKeyValueStore(map)
    }
}

object MainApp extends ZIOAppDefault {
  val myApp =
    for {
      _   &lt;- KeyValueStore.set[String, Int, String](&quot;key&quot;, 5)
      key &lt;- KeyValueStore.get[String, Int, String](&quot;key&quot;)
    } yield key

  def run = myApp.provide(InmemoryKeyValueStore.layer).debug

}
</code></pre><h3>The Three Laws of ZIO Environment</h3><p>When we are working with the ZIO environment, one question might arise: &quot;When should we use environment and when do we need to use constructors?&quot;.</p><p>Using ZIO environment follows three laws:</p><ol><li><strong>Service Interface (Trait)</strong> — When we are defining service interfaces we should <em>never</em> use the environment for dependencies of the service itself.</li></ol><p>For example, if the implementation of service <code>X</code> depends on service <code>Y</code> and <code>Z</code> then these should never be reflected in the trait that defines service <code>X</code>. It&#x27;s leaking implementation details.</p><p>So the following service definition is wrong because the <code>Console</code> and <code>Clock</code> service are dependencies of the  <code>Logging</code> service&#x27;s implementation, not the <code>Logging</code> interface itself:</p><pre><code class="language-scala">import zio._
trait Logging {
  def log(line: String): ZIO[Any, Nothing, Unit]
}
</code></pre><ol start="2"><li><strong>Service Implementation (Class)</strong> — When implementing service interfaces, we should accept all dependencies in the class constructor.</li></ol><p>Again, let&#x27;s see how <code>LoggingLive</code> accepts <code>Console</code> and <code>Clock</code> dependencies from the class constructor:</p><pre><code class="language-scala">case class LoggingLive(console: Console, clock: Clock) extends Logging {
  override def log(line: String): UIO[Unit] =
    for {
      current &lt;- clock.currentDateTime
      _       &lt;- console.printLine(s&quot;$current--$line&quot;).orDie
    } yield ()
}
</code></pre><p>So keep in mind, we can&#x27;t do something like this:</p><pre><code class="language-scala">case class LoggingLive() extends Logging {
  override def log(line: String) =
    for {
      clock   &lt;- ZIO.service[Clock]
      console &lt;- ZIO.service[Console]
      current &lt;- clock.currentDateTime
      _       &lt;- console.printLine(s&quot;$current--$line&quot;).orDie
    } yield ()
}

// error: type mismatch;
//  found   : zio.ZIO[zio.Console &amp; zio.Clock,Nothing,Unit]
//     (which expands to)  zio.ZIO[zio.Console with zio.Clock,Nothing,Unit]
//  required: zio.ZIO[Logging,Nothing,Unit]
//   def log(line: String): URIO[Logging, Unit] = ZIO.serviceWithZIO[Logging](_.log(line))
//                                                                            ^^^^^^^^^^^
</code></pre><ol start="3"><li><strong>Business Logic</strong> — Finally, in the business logic we should use the ZIO environment to consume services.</li></ol><p>Therefore, in the last example, if we inline all accessor methods whenever we are using services, we are using the ZIO environment:</p><pre><code class="language-scala">import zio._
import java.io.IOException

object MainApp extends ZIOAppDefault {
  val app: ZIO[Logging, IOException, Unit] =
    for {
      _    &lt;- ZIO.serviceWithZIO[Logging](_.log(&quot;Application Started!&quot;))
      _    &lt;- Console.print(&quot;Enter your name: &quot;)
      name &lt;- Console.readLine
      _    &lt;- Console.printLine(s&quot;Hello, $name!&quot;)
      _    &lt;- ZIO.serviceWithZIO[Logging](_.log(&quot;Application Exited!&quot;))
    } yield ()

  def run = app.provide(LoggingLive.layer)
}
</code></pre><p>That&#x27;s it! These are the most important rules we need to know about the ZIO environment.</p><blockquote><p><strong>Note</strong>:</p><p>The remaining part of this section can be skipped if you are not an advanced ZIO user.</p></blockquote><p>Now let&#x27;s elaborate more on the first rule. On rare occasions, all of which involve local context that is independent of implementation, it&#x27;s <em>acceptable</em> to use the environment in the definition of a service.</p><p>Here are two examples:</p><ol><li>In a web application, a service may be defined only to operate in the context of an HTTP request. In such a case, the request itself could be stored in the environment: <code>ZIO[HttpRequest, ...]</code>. This is acceptable because this use of the environment is part of the semantics of the trait itself, rather than leaking an implementation detail of some particular class that implements the service trait:</li></ol><pre><code class="language-scala">import zio._
import zio.stream._
import java.net.URI
import java.nio.charset.StandardCharsets

type HttpApp = ZIO[HttpRequest, Throwable, HttpResponse]
type HttpRoute = Map[String, HttpApp]

case class HttpRequest(method: Int,
                       uri: URI,
                       headers: Map[String, String],
                       body: UStream[Byte])

case class HttpResponse(status: Int,
                        headers: Map[String, String],
                        body: UStream[Byte])

object HttpResponse {
  def apply(status: Int, message: String): HttpResponse =
    HttpResponse(
      status = status,
      headers = Map.empty,
      body = ZStream.fromChunk(
        Chunk.fromArray(message.getBytes(StandardCharsets.UTF_8))
      )
    )

  def ok(msg: String): HttpResponse = HttpResponse(200, msg)

  def error(msg: String): HttpResponse = HttpResponse(800, msg)
}

trait HttpServer {
  def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit]
}

object HttpServer {
  def serve(map: HttpRoute, host: String, port: Int): ZIO[HttpServer, Throwable, Unit] =
    ZIO.serviceWithZIO(_.serve(map, host, port))
}

case class HttpServerLive() extends HttpServer {
  override def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit] = ???
}

object HttpServerLive {
  val layer: URLayer[Any, HttpServer] = ZLayer.succeed(HttpServerLive())
}

object MainWebApp extends ZIOAppDefault {

  val myApp: ZIO[HttpServer, Throwable, Unit] = for {
    _ &lt;- ZIO.unit
    healthcheck: HttpApp = ZIO.service[HttpRequest].map { _ =&gt;
      HttpResponse.ok(&quot;up&quot;)
    }

    pingpong = ZIO.service[HttpRequest].flatMap { req =&gt;
      ZIO.ifZIO(
        req.body.via(ZPipeline.utf8Decode).runHead.map(_.contains(&quot;ping&quot;))
      )(
        onTrue = ZIO.attempt(HttpResponse.ok(&quot;pong&quot;)),
        onFalse = ZIO.attempt(HttpResponse.error(&quot;bad request&quot;))
      )
    }

    map = Map(
      &quot;/healthcheck&quot; -&gt; healthcheck,
      &quot;/pingpong&quot; -&gt; pingpong
    )
    _ &lt;- HttpServer.serve(map, &quot;localhost&quot;, 8080)
  } yield ()

  def run = myApp.provideLayer(HttpServerLive.layer)

}
</code></pre><ol start="2"><li>In a database application, a service may be defined only to operate in the context of a larger database transaction. In such a case, the transaction could be stored in the environment: <code>ZIO[DatabaseTransaction, ...]</code>. As in the previous example, because this is part of the semantics of the trait itself (whose functionality all operates within a transaction), this is not leaking implementation details, and therefore it is valid:</li></ol><pre><code class="language-scala">trait DatabaseTransaction {
  def get(key: String): Task[Int]
  def put(key: String, value: Int): Task[Unit]
}

object DatabaseTransaction {
  def get(key: String): ZIO[DatabaseTransaction, Throwable, Int] =
    ZIO.serviceWithZIO(_.get(key))

  def put(key: String, value: Int): ZIO[DatabaseTransaction, Throwable, Unit] =
    ZIO.serviceWithZIO(_.put(key, value))
}

trait Database {
  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A]
}

object Database {
  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Database, E, A] =
    ZIO.serviceWithZIO(_.atomically(zio))
}

case class DatabaseLive() extends Database {
  override def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A] = ???
}

object DatabaseLive {
  val layer = ZLayer.succeed(DatabaseLive())
}

object MainDatabaseApp extends ZIOAppDefault {
  val myApp: ZIO[Database, Throwable, Unit] =
    for {
      _ &lt;- Database.atomically(DatabaseTransaction.put(&quot;counter&quot;, 0))
      _ &lt;- ZIO.foreachPar(List(1 to 10)) { _ =&gt;
        Database.atomically(
          for {
            value &lt;- DatabaseTransaction.get(&quot;counter&quot;)
            _ &lt;- DatabaseTransaction.put(&quot;counter&quot;, value + 1)
          } yield ()
        )
      }
    } yield ()

  def run = myApp.provideLayer(DatabaseLive.layer)

}
</code></pre><p>So while it&#x27;s better to err on the side of &quot;don&#x27;t put things into the environment of service interface&quot;, there are cases where it&#x27;s acceptable.</p></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/2-0-0/datatypes/contextual/index";window.___webpackCompilationHash="cdece7bd87ec0e38633f";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0704c8948e63b1196955.js"],"app":["/app-8399cd578ff86df79336.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-f82da7fc8f1ed5d041f7.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/polyfill-0704c8948e63b1196955.js" nomodule=""></script><script src="/app-8399cd578ff86df79336.js" async=""></script><script src="/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/webpack-runtime-90acb813f0122dad9372.js" async=""></script></body></html>