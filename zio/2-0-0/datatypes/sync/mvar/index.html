<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/styles.0d77a1f9790ad3befaea.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><p>An <code>MVar[A]</code> is a mutable location that is either empty or contains a value of type <code>A</code>. So the <code>MVar</code> acts like a <em>single-element buffer</em>.</p><p><code>MVar</code> can be used in multiple different ways:</p><ul><li>As a simple on/off latch</li><li>As a binary semaphore <code>MVar[Unit]</code>, with <code>take</code> and <code>put</code> as <code>acquire</code> and <code>release</code></li><li>As a synchronized mutable variable</li><li>As a channel, with <code>take</code> and <code>put</code> as <code>receive</code> and <code>send</code></li></ul><p>They were introduced in the paper <a href="#http://research.microsoft.com/~simonpj/papers/concurrent-haskell.ps.gz">Concurrent Haskell</a> by Simon Peyton Jones, Andrew Gordon and, Sigbjorn Finne.</p><h2>Creation</h2><p>There are two ways to create an <code>MVar</code>:</p><ol><li><strong><code>MVar.empty[A]</code></strong>— To create an <code>MVar</code> of type <code>A</code> that is <em>initially empty</em>, for example:</li></ol><pre><code class="language-scala">import zio.concurrent.MVar

val empty = MVar.empty[Int]
</code></pre><ol start="2"><li><strong><code>MVar.make[A]</code></strong>— To create an <code>MVar</code> of type <code>A</code> that is <em>initially full</em>, for example:</li></ol><pre><code class="language-scala">import zio.concurrent.MVar

val full = MVar.make(42)
</code></pre><h2>Operations</h2><h3>Blocking <code>put</code> and <code>take</code></h3><p><code>MVar</code> has two fundamental operations:</p><ul><li><code>MVar#put</code> which fills an <code>MVar</code> if it is empty and blocks otherwise.</li><li><code>MVar#take</code> which empties an <code>MVar</code> if it is full and blocks otherwise.</li></ul><pre><code class="language-scala">class MVar[A] {
  def put(a: A): UIO[Unit] = ???
  def take: UIO[A] = ???
}
</code></pre><p>So we can put something into it, making it full, or take something out, making it empty, and in two cases, it will block the calling fiber:</p><ul><li>If it is full and the calling fiber tries to put something in it.</li><li>If it is empty and the calling fiber tries to take something out of it.</li></ul><p>These two features of <code>MVar</code> make it possible to synchronize multiple fibers.</p><h3>Nonblocking <code>tryPut</code> and <code>tryTake</code></h3><p>While <code>put</code> and <code>take</code> are blocking operations, there are also non-blocking versions of these operations:</p><ul><li><code>MVar#tryPut</code> which tries to fill an <code>MVar</code> and returns <code>true</code> if successful or <code>false</code> if it is full.</li><li><code>MVar#tryTake</code> which tries to empty an <code>MVar</code> and returns <code>Some(x)</code> if it is full of <code>x</code> or <code>None</code> if it is empty.</li></ul><pre><code class="language-scala">class MVar[A] {
  def tryPut(x: A): UIO[Boolean] = ???
  def tryTake: UIO[Option[A]] = ???
}
</code></pre><h3>Blocking <code>update</code>, and <code>modify</code></h3><p>Using <code>update</code> and <code>modify</code> we can update the value of an <code>MVar</code>. The <code>update</code> doesn&#x27;t return the updated value, but the <code>modify</code> does:</p><pre><code class="language-scala">class MVar[A] {
  def update(f: A =&gt; A): UIO[Unit] = ???
  def modify[B](f: A =&gt; (B, A)): UIO[B] = ???
}
</code></pre><p>Like the <code>put</code> and <code>take</code> operations, the <code>update</code> and <code>modify</code> operations are blocking, this means if the <code>MVar</code> is empty, they will block the calling fiber until the <code>MVar</code> becomes full.</p><h2>Use Cases</h2><h3>Simple On/Off Latch</h3><p>We can use an <code>MVar</code> to implement a simple on/off latch:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {

  def job1(latch: MVar[Unit]) =
    for {
      _ &lt;- ZIO.debug(&quot;Job 1: I started my work&quot;)
      _ &lt;- ZIO.sleep(5.second)
      _ &lt;- ZIO.debug(&quot;Job 1: I finished my work&quot;)
      _ &lt;- latch.put(())
    } yield ()

  def job2(latch: MVar[Unit]) = for {
    _ &lt;- ZIO.debug(&quot;Job 2: I&#x27;m waiting for job 1 to finish its work&quot;)
    _ &lt;- latch.take
    _ &lt;- ZIO.debug(&quot;Job 2: I&#x27;m starting my work&quot;)
    _ &lt;- ZIO.sleep(4.second)
    _ &lt;- ZIO.debug(&quot;Job 2: I finished my work&quot;)
  } yield ()

  def run =
    MVar.empty[Unit].flatMap { latch =&gt;
      job1(latch) &lt;&amp;&gt; job2(latch)
    }
}
</code></pre><p>In the above example, we created an empty <code>MVar</code>, and then we created two <code>ZIO</code> workflows that will be executed concurrently. The first one will wait for the second one to finish its work. But the second one at some point in its execution will need to synchronize with the first one. It needs to make sure that the first one has finished its work before it continues its own work.</p><h3>Binary Semaphore</h3><p>Assume we have a function <code>inc</code> that takes a <code>Ref[Int]</code> and increments its value by one as below:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {

  def inc(ref: Ref[Int]) =
    for {
      v &lt;- ref.get
      result = v + 1
      _ &lt;- ref.set(result)
    } yield ()
    
  def run =
    for {
      ref &lt;- Ref.make(0)
      _ &lt;- ZIO.foreachParDiscard(1 to 100)(_ =&gt; inc(ref))
      _ &lt;- ref.get.debug(&quot;result&quot;)
    } yield ()

}
</code></pre><p>When we perform the <code>inc</code> function, 100 times, we expect the final value of the <code>ref</code> to be 100. But if we run the program multiple times, we will get different results. This is because the <code>inc</code> function is not atomic, and the <code>ref</code> may be updated by another thread between the time we read it and the time we write it.</p><p>So we need a way to ensure that between the time we read the ref and the time we write to it, no other threads will be able to make changes to it.</p><p>We know that <code>Ref</code> has the <code>update</code> operation that is atomic. So if we rewrite the <code>inc</code> as below, our program will work as expected:</p><pre><code class="language-scala">def inc(ref: Ref[Int]) =
  ref.update(_ + 1)
</code></pre><p>Although the solution to this problem is <code>Ref#update</code>, we want to use <code>MVar</code> to implement the same functionality for pedagogical purposes. So let&#x27;s see how we can do that using <code>MVar</code>:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {

  def inc(ref: Ref[Int]) =
    for {
      v &lt;- ref.get
      result = v + 1
      _ &lt;- ref.set(result)
    } yield ()
    
  def run =
    for {
      semaphore &lt;- MVar.make[Unit](())
      ref &lt;- Ref.make(0)
      _ &lt;- ZIO.foreachParDiscard(1 to 100) { _ =&gt;
          for {
            _ &lt;- semaphore.take     // acquire
            _ &lt;- inc(ref)
            _ &lt;- semaphore.put(())  // release
          } yield ()
      }
      _ &lt;- ref.get.debug(&quot;result&quot;)
    } yield ()

}
</code></pre><p>So we used the <code>take</code> as <code>acquire</code> and the <code>put</code> as the <code>release</code> operation of the binary semaphore.</p><p>Note that, in the above solution, if any interruption occurs while we have acquired the semaphore (between <code>acquire</code> and <code>release</code> operations), the semaphore will not be released. So to prevent such a situation, we need to make sure that we always release the semaphore whether the critical section runs successfully or not. Let&#x27;s model the whole solution in a new data type called <code>BinarySemaphore</code>:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

class BinarySemaphore private (mvar: MVar[Unit]) {
  def acquire: ZIO[Any, Nothing, Unit] = mvar.take

  def release: ZIO[Any, Nothing, Unit] = mvar.put(())

  def guard[R, E, A](
      region: ZIO[R, E, A]
  ): ZIO[R, E, A] =
    ZIO.acquireReleaseWith(acquire)(_ =&gt; release)(_ =&gt; region)
}

object BinarySemaphore {
  def make(): ZIO[Any, Nothing, BinarySemaphore] =
    MVar.make(()).map(new BinarySemaphore(_))
}
</code></pre><p>Now we can apply the <code>guard</code> function to the <code>inc</code> function of the previous example:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {

  def inc(ref: Ref[Int]) =
    for {
      v &lt;- ref.get
      result = v + 1
      _ &lt;- ref.set(result)
    } yield ()

  def run =
    for {
      semaphore &lt;- BinarySemaphore.make()
      ref &lt;- Ref.make(0)
      _ &lt;- ZIO.foreachParDiscard(1 to 100) { _ =&gt;
        semaphore.guard(inc(ref))
      }
      _ &lt;- ref.get.debug(&quot;result&quot;)
    } yield ()

}
</code></pre><h3>Synchronized Mutable Variable</h3><p>We can have synchronized mutable variables using the <code>MVar</code> data type:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {
  def inc(state: MVar[Int]) =
    state.update(_ + 1)

  def run =
    MVar
      .make(0)
      .flatMap(s =&gt; ZIO.foreachParDiscard(1 to 100)(_ =&gt; inc(s)) *&gt; s.take)
      .debug(&quot;result&quot;)
}
</code></pre><p>In this case, we executed the same <code>inc</code> workflow 100 times concurrently. All the concurrent fibers access the same shared mutable variable called <code>state</code> in a synchronized way. In this case, we used the <code>update</code>, a safe operation that will atomically update the value of <code>MVar</code>.</p><p>A question that may be raised is that can we compose <code>take</code> and <code>update</code> to implement the same functionality for the <code>inc</code> workflow as below?</p><pre><code class="language-scala">def inc(state: MVar[Int]) =
  state.take.flatMap(s =&gt; state.put(s + 1))
</code></pre><p>Can we say this is the same as the previous <code>inc</code> function? No, because although the <code>take</code> and <code>put</code> are atomic by themselves, their composition is not. So in a real-world scenario, in a concurrent environment it is possible that in between the <code>take</code> and <code>put</code> operations, the <code>state</code> is modified by another fiber. So this is why we used the <code>update</code> operation instead, which is an atomic operation.</p><h3>Producer/Consumer Channel</h3><p>We can use an <code>MVar</code> to implement a producer/consumer channel:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {
  def producer(state: MVar[Int]) =
    Random.nextIntBounded(100)
      .flatMap(state.put)
      .forever
 
  def consumer(state: MVar[Int]) =
    state.take
      .flatMap(i =&gt; ZIO.debug(s&quot;$i consumed!&quot;))
      .delay(1.second)
      .forever

  def run =
    MVar.empty[Int].flatMap { s =&gt;
      producer(s) &lt;&amp;&gt; consumer(s)
    }
}
</code></pre><p>In such a case we want to model a producer/consumer channel to make sure the producer doesn&#x27;t produce any value unless the consumer is ready to consume it. So in this example, <code>MVar</code> acts as one element size channel that handles backpressure. </p><p>If we add more consumers, the speed of consuming elements will be increased. Note that, by having multiple consumers, the data will not be duplicated through the consumers. If we have three consumers, each piece of data will be consumed only by one of the consumers:</p><pre><code class="language-scala">import zio._
import zio.concurrent.MVar

object MainApp extends ZIOAppDefault {
  def producer(state: MVar[Int]) =
    ZIO.foreachDiscard(1 to Int.MaxValue)(state.put)

  def consumer(state: MVar[Int])(name: String) =
    state.take
      .flatMap(i =&gt; ZIO.debug(s&quot;Consumer $name: $i consumed!&quot;))
      .delay(1.second)
      .forever

  def run =
    MVar.empty[Int].flatMap { s =&gt;
      producer(s) &lt;&amp;&gt;
        consumer(s)(&quot;A&quot;) &lt;&amp;&gt; consumer(s)(&quot;B&quot;) &lt;&amp;&gt; consumer(s)(&quot;C&quot;)
    }
}
</code></pre></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/2-0-0/datatypes/sync/mvar";window.___webpackCompilationHash="53b7c704da15532d0ff8";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0704c8948e63b1196955.js"],"app":["/app-339ef8175e8f2f05ba0d.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-d0913b8933fa48a45475.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/polyfill-0704c8948e63b1196955.js" nomodule=""></script><script src="/app-339ef8175e8f2f05ba0d.js" async=""></script><script src="/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/webpack-runtime-cb792496eecc1c611f4e.js" async=""></script></body></html>