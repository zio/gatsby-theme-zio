<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/gatsby-theme-zio/styles.c7a353d8d87792ddfeb7.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><p>A <code>Schedule[Env, In, Out]</code> is an <strong>immutable value</strong> that <strong>describes</strong> a recurring effectful schedule, which runs in some environment <code>Env</code>, after consuming values of type <code>In</code> (errors in the case of <code>retry</code>, or values in the case of <code>repeat</code>) produces values of type <code>Out</code>, and in every step based on input values and the internal state decides to halt or continue after some delay <strong>d</strong>.</p><p>Schedules are defined as a possibly infinite set of intervals spread out over time. Each interval defines a window in which recurrence is possible.</p><p>When schedules are used to repeat or retry effects, the starting boundary of each interval produced by a schedule is used as the moment when the effect will be executed again.</p><p>A variety of other operators exist for transforming and combining schedules, and the companion object for <code>Schedule</code> contains all common types of schedules, both for performing retrying, as well as performing repetition.</p><h2>Repeat and Retry</h2><p>Schedules allow us to define and compose flexible recurrence schedules, which can be used to <strong>repeat</strong> actions, or <strong>retry</strong> actions in the event of errors.</p><p>Repetition and retrying are two similar concepts in the domain of scheduling. It is the same concept and idea, only one of them looks for successes and the other one looks for failures. </p><h3>Repeat</h3><p>In the case of repetition, ZIO has a <code>ZIO#repeat</code> function, which takes a schedule as a repetition policy and returns another effect that describes an effect with repetition strategy according to that policy.</p><p>Repeat policies are used in the following functions:</p><ul><li><code>ZIO#repeat</code> — Repeats an effect until the schedule is done.</li><li><code>ZIO#repeatOrElse</code> — Repeats an effect until the schedule is done, with a fallback for errors.</li></ul><blockquote><p><em><strong>Note:</strong></em></p><p>Scheduled recurrences are in addition to the first execution, so that <code>io.repeat(Schedule.once)</code> yields an effect that executes <code>io</code>, and then if that succeeds, executes <code>io</code> an additional time.</p></blockquote><p>Let&#x27;s see how we can create a repeated effect by using <code>ZIO#repeat</code> function:</p><pre><code class="language-scala">val action:      ZIO[R, E, A] = ???
val policy: Schedule[R1, A, B] = ???

val repeated = action repeat policy
</code></pre><p>There is another version of <code>repeat</code> that helps us to have a fallback strategy in case of erros, if something goes wrong we can handle that by using the <code>ZIO#repeatOrElse</code> function, which helps up to add an <code>orElse</code> callback that will run in case of repetition failure:</p><pre><code class="language-scala">val action:       ZIO[R, E, A] = ???
val policy: Schedule[R1, A, B] = ???

val orElse: (E, Option[B]) =&gt; ZIO[R1, E2, B] = ???

val repeated = action repeatOrElse (policy, orElse)
</code></pre><h3>Retry</h3><p>In the case of retrying, ZIO has a <code>ZIO#retry</code> function, which takes a schedule as a repetition policy and returns another effect that describes an effect with repetition strategy which will retry following the failure of the original effect.</p><p>Repeat policies are used in the following functions:</p><ul><li><code>ZIO#retry</code> – Retries an effect until it succeeds.</li><li><code>ZIO#retryOrElse</code> — Retries an effect until it succeeds, with a fallback for errors.</li></ul><p>Let&#x27;s see how we can create a repeated effect by using <code>ZIO#retry</code> function:</p><pre><code class="language-scala">val action:       ZIO[R, E, A] = ???
val policy: Schedule[R1, E, S] = ???

val repeated = action retry policy

</code></pre><p>There is another version of <code>retry</code> that helps us to have a fallback strategy in case of erros, if something goes wrong we can handle that by using the <code>ZIO#retryOrElse</code> function, which helps up to add an <code>orElse</code> callback that will run in case of failure of repetition failure:</p><pre><code class="language-scala">val action:       ZIO[R, E, A] = ???
val policy: Schedule[R1, A, B] = ???

val orElse: (E, S) =&gt; ZIO[R1, E1, A1] = ???

val repeated = action retryOrElse (policy, orElse)
</code></pre><h2>Base Schedules</h2><h3>stop</h3><p>A schedule that does not recur, just stops and returns one <code>Unit</code> element:</p><pre><code class="language-scala">val stop = Schedule.stop
</code></pre><h3>once</h3><p>A schedule that recurs one time an returns one <code>Unit</code> element:</p><pre><code class="language-scala">val once = Schedule.once
</code></pre><h3>forever</h3><p>A schedule that always recurs and produces number of recurrence at each run:</p><pre><code class="language-scala">val forever = Schedule.forever
</code></pre><h3>recurs</h3><p>A schedule that only recurs the specified number of times:</p><pre><code class="language-scala">val recurs = Schedule.recurs(5)
</code></pre><h3>spaced</h3><p>A schedule that recurs continuously, each repetition spaced the specified duration from the last run:</p><pre><code class="language-scala">val spaced = Schedule.spaced(10.milliseconds)
</code></pre><h3>fixed</h3><p>A schedule that recurs on a fixed interval. Returns the number of repetitions of the schedule so far:</p><pre><code class="language-scala">val fixed = Schedule.fixed(10.seconds)
</code></pre><h3>exponential</h3><p>A schedule that recurs using exponential backoff:</p><pre><code class="language-scala">val exponential = Schedule.exponential(10.milliseconds)
</code></pre><h3>fibonacci</h3><p>A schedule that always recurs, increasing delays by summing the preceding two delays (similar to the fibonacci sequence). Returns the current duration between recurrences:</p><pre><code class="language-scala">val fibonacci = Schedule.fibonacci(10.milliseconds)
</code></pre><h3>identity</h3><p>A schedule that always decides to continue. It recurs forever, without any delay. <code>identity</code> schedule consumes input, and emit the same as output (<code>Schedule[Any, A, A]</code>):</p><pre><code class="language-scala">val identity = Schedule.identity[Int]
</code></pre><h3>unfold</h3><p>A schedule that repeats one time from the specified state and iterator:</p><pre><code class="language-scala">val unfold = Schedule.unfold(0)(_ + 1)
</code></pre><h3>succeed</h3><p>Returns a schedule that repeats one time, producing the specified constant value:</p><pre><code class="language-scala">val constant = Schedule.succeed(5)
</code></pre><h3>fromFunction</h3><p>A schedule that always recurs, mapping input values through the specified function:</p><pre><code class="language-scala">val inc = Schedule.fromFunction[Int, Int](_ + 1)
</code></pre><h2>Schedule Combinators</h2><p>Schedules define stateful, possibly effectful, recurring schedules of events, and compose in a variety of ways. Combinators allow us to take schedules and combine them together to get other schedules and if we have combinators with just the right properties. Then in theory we should be able to solve an infinite number of problems, with only a few combinators and few base schedules.</p><h3>Composition</h3><p>Schedules compose in the following primary ways:</p><ul><li><strong>Union</strong>. This performs the union of the intervals of two schedules.</li><li><strong>Intersection</strong>. This performs the intersection of the intervals of two schedules.</li><li><strong>Sequence</strong>. This concatenates the intervals of one schedule onto another.</li></ul><h4>Union</h4><p>Combines two schedules through union, by recurring if either schedule wants to
recur, using the minimum of the two delays between recurrences.</p><table><thead><tr><th></th><th><code>s1</code></th><th><code>s2</code></th><th><code>s1</code> <!-- -->|<!-- --> <!-- -->|<!-- --> <code>s2</code></th></tr></thead><tbody><tr><td>Type</td><td><code>Schedule[R, A, B]</code></td><td><code>Schedule[R, A, C]</code></td><td><code>Schedule[R, A, (B, C)]</code></td></tr><tr><td>Continute: <code>Boolean</code></td><td><code>b1</code></td><td><code>b2</code></td><td><code>b1</code> <!-- -->|<!-- --> <!-- -->|<!-- --> <code>b2</code></td></tr><tr><td>Delay: <code>Duration</code></td><td><code>d1</code></td><td><code>d2</code></td><td><code>d1.min(d2)</code></td></tr><tr><td>Emit: <code>(A, B)</code></td><td><code>a</code></td><td><code>b</code></td><td><code>(a, b)</code></td></tr></tbody></table><p>We can combine two schedule through union with <code>||</code> operator:</p><pre><code class="language-scala">val expCapped = Schedule.exponential(100.milliseconds) || Schedule.spaced(1.second)
</code></pre><h4>Intersection</h4><p>Combines two schedules through the intersection, by recurring only if both schedules want to recur, using the maximum of the two delays between recurrences.</p><table><thead><tr><th></th><th><code>s1</code></th><th><code>s2</code></th><th><code>s1 &amp;&amp; s2</code></th></tr></thead><tbody><tr><td>Type</td><td><code>Schedule[R, A, B]</code></td><td><code>Schedule[R, A, C]</code></td><td><code>Schedule[R, A, (B, C)]</code></td></tr><tr><td>Continute: <code>Boolean</code></td><td><code>b1</code></td><td><code>b2</code></td><td><code>b1 &amp;&amp; b2</code></td></tr><tr><td>Delay: <code>Duration</code></td><td><code>d1</code></td><td><code>d2</code></td><td><code>d1.max(d2)</code></td></tr><tr><td>Emit: <code>(A, B)</code></td><td><code>a</code></td><td><code>b</code></td><td><code>(a, b)</code></td></tr></tbody></table><p>We can intersect two schedule with <code>&amp;&amp;</code> operator:</p><pre><code class="language-scala">val expUpTo10 = Schedule.exponential(1.second) &amp;&amp; Schedule.recurs(10)
</code></pre><h4>Sequence</h4><p>Combines two schedules sequentially, by following the first policy until it ends, and then following the second policy.</p><table><thead><tr><th></th><th><code>s1</code></th><th><code>s2</code></th><th><code>s1 andThen s2</code></th></tr></thead><tbody><tr><td>Type</td><td><code>Schedule[R, A, B]</code></td><td><code>Schedule[R, A, C]</code></td><td><code>Schedule[R, A, C]</code></td></tr><tr><td>Delay: <code>Duration</code></td><td><code>d1</code></td><td><code>d2</code></td><td><code>d1 + d2</code></td></tr><tr><td>Emit: <code>B</code></td><td><code>a</code></td><td><code>b</code></td><td><code>b</code></td></tr></tbody></table><p>We can sequence two schedule by using <code>andThen</code>:</p><pre><code class="language-scala">val sequential = Schedule.recurs(10) andThen Schedule.spaced(1.second)
</code></pre><h3>Piping</h3><p>Combine two schedules by piping the output of the first schedule to the input of the other. Effects described by the first schedule will always be executed before the effects described by the second schedule.</p><table><thead><tr><th></th><th><code>s1</code></th><th><code>s2</code></th><th><code>s1 &gt;&gt;&gt; s2</code></th></tr></thead><tbody><tr><td>Type</td><td><code>Schedule[R, A, B]</code></td><td><code>Schedule[R, B, C]</code></td><td><code>Schedule[R, A, C]</code></td></tr><tr><td>Delay: <code>Duration</code></td><td><code>d1</code></td><td><code>d2</code></td><td><code>d1 + d2</code></td></tr><tr><td>Emit: <code>B</code></td><td><code>a</code></td><td><code>b</code></td><td><code>b</code></td></tr></tbody></table><p>We can pipe two schedule by using <code>&gt;&gt;&gt;</code> operator:</p><pre><code class="language-scala">val totalElapsed = Schedule.spaced(1.second) &lt;* Schedule.recurs(5) &gt;&gt;&gt; Schedule.elapsed
</code></pre><h3>Jittering</h3><p>A <code>jittered</code> is a combinator that takes one schedule and returns another schedule of the same type except for the delay which is applied randomly:</p><table><thead><tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr></thead><tbody><tr><td><code>jittered</code></td><td></td><td><code>Schedule[Env with Random, In, Out]</code></td></tr><tr><td><code>jittered</code></td><td><code>min: Double, max: Double</code></td><td><code>Schedule[Env with Random, In, Out]</code></td></tr></tbody></table><p>We can jitter any schedule by calling <code>jittered</code> on it:</p><pre><code class="language-scala">val jitteredExp = Schedule.exponential(10.milliseconds).jittered
</code></pre><p>When a resource is out of service due to overload or contention, retrying and backing off doesn&#x27;t help us. If all failed API calls are backed off to the same point of time, they cause another overload or contention. Jitter adds some amount of randomness to the delay of the schedule. This helps us to avoid ending up accidentally synchronizing and taking the service down by accident.</p><p>The form with parameters <code>min</code> and <code>max</code> creates a new schedule where the new interval size is randomly distributed between <code>min * old interval</code> and <code>max * old interval</code>.</p><h3>Collecting</h3><p>A <code>collectAll</code> is a combinator that when we call it on a schedule, produces a new schedule that collects the outputs of the first schedule into a chunk.</p><table><thead><tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr></thead><tbody><tr><td><code>collectAll</code></td><td><code>Schedule[Env, In, Out]</code></td><td><code>Schedule[Env, In, Chunk[Out]]</code></td></tr></tbody></table><p>In the following example, we are catching all recurrence of schedule into <code>Chunk</code>, so at the end, it would contain <code>Chunk(0, 1, 2, 3, 4)</code>:</p><pre><code class="language-scala">val collect = Schedule.recurs(5).collectAll
</code></pre><h3>Filtering</h3><p>We can filter inputs or outputs of a schedule with <code>whileInput</code> and <code>whileOutput</code>. Alse ZIO schedule has an effectful version of these two functions, <code>whileInputZIO</code> and <code>whileOutputZIO</code>.</p><table><thead><tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr></thead><tbody><tr><td><code>whileInput</code></td><td><code>In1 =&gt; Boolean</code></td><td><code>Schedule[Env, In1, Out]</code></td></tr><tr><td><code>whileOutput</code></td><td><code>Out =&gt; Boolean</code></td><td><code>Schedule[Env, In, Out]</code></td></tr><tr><td><code>whileInputZIO</code></td><td><code>In1 =&gt; URIO[Env1, Boolean]</code></td><td><code>Schedule[Env1, In1, Out]</code></td></tr><tr><td><code>whileOutputZIO</code></td><td><code>Out =&gt; URIO[Env1, Boolean]</code></td><td><code>Schedule[Env1, In, Out]</code></td></tr></tbody></table><p>In following example we collect all emiting outputs before reaching the 5 output, so it would return <code>Chunk(0, 1, 2, 3, 4)</code>:</p><pre><code class="language-scala">val res = Schedule.unfold(0)(_ + 1).whileOutput(_ &lt; 5).collectAll
</code></pre><h3>Mapping</h3><p>There are two versions for mapping schedules, <code>map</code> and its effectful version <code>mapZIO</code>.</p><table><thead><tr><th>Function</th><th>Input Type</th><th>Output Type</th></tr></thead><tbody><tr><td><code>map</code></td><td><code>f: Out =&gt; Out2</code></td><td><code>Schedule[Env, In, Out2]</code></td></tr><tr><td><code>mapZIO</code></td><td><code>f: Out =&gt; URIO[Env1, Out2]</code></td><td><code>Schedule[Env1, In, Out2]</code></td></tr></tbody></table><h3>Left/Right Ap</h3><p>Sometimes when we intersect two schedules with the <code>&amp;&amp;</code> operator, we just need to ignore the left or the right output. </p><ul><li><ul><li><code>*&gt;</code> ignore the left output </li></ul></li><li><ul><li><code>&lt;*</code> ignore the right output</li></ul></li></ul><h3>Modifying</h3><p>Modifies the delay of a schedule:</p><pre><code class="language-scala">val boosted = Schedule.spaced(1.second).delayed(_ =&gt; 100.milliseconds)
</code></pre><h3>Tapping</h3><p>Whenever we need to effectfully process each schedule input/output, we can use <code>tapInput</code> and <code>tapOutput</code>.</p><p>We can use these two functions for logging purposes:</p><pre><code class="language-scala">val tappedSchedule = Schedule.count.whileOutput(_ &lt; 5).tapOutput(o =&gt; Console.printLine(s&quot;retrying $o&quot;).orDie)
</code></pre><h2>Examples</h2><p>Stops retrying after a specified amount of time has elapsed:</p><pre><code class="language-scala">val expMaxElapsed = (Schedule.exponential(10.milliseconds) &gt;&gt;&gt; Schedule.elapsed).whileOutput(_ &lt; 30.seconds)
</code></pre><p>Retry only when a specific exception occurs:</p><pre><code class="language-scala">import scala.concurrent.TimeoutException

val whileTimeout = Schedule.exponential(10.milliseconds) &amp;&amp; Schedule.recurWhile[Throwable] {
  case _: TimeoutException =&gt; true
  case _ =&gt; false
}
</code></pre></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/2-0-0/datatypes/misc/schedule";window.___webpackCompilationHash="c9a81335e251e70eaae1";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0e4cbbcc00d4e08af0a8.js"],"app":["/app-b67510c2f2944fbdda0c.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-d7ac5bbd88d2967e36ed.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/gatsby-theme-zio/polyfill-0e4cbbcc00d4e08af0a8.js" nomodule=""></script><script src="/gatsby-theme-zio/app-b67510c2f2944fbdda0c.js" async=""></script><script src="/gatsby-theme-zio/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/gatsby-theme-zio/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/gatsby-theme-zio/webpack-runtime-e8cb2cd16229bfcc03b8.js" async=""></script></body></html>