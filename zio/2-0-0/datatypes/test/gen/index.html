<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/gatsby-theme-zio/styles.c7a353d8d87792ddfeb7.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><p>A <code>Gen[R, A]</code> represents a generator of values of type <code>A</code>, which requires an environment <code>R</code>. The <code>Gen</code> data type is the base functionality for generating test data for property-based testing. We use them to produce deterministic and non-deterministic (PRNG) random values.</p><p>It is encoded as a stream of optional samples:</p><pre><code class="language-scala">case class Gen[-R, +A](sample: ZStream[R, Nothing, Option[Sample[R, A]]])
</code></pre><p>Before deep into the generators, let&#x27;s see what is property-based testing and what problem it solves in the testing world.</p><h2>What is Property-Based Testing?</h2><p>In property-based testing, instead of testing individual values and making assertions on the results, we rely on testing the properties of the system which is under the test.</p><p>To be more acquainted with property-based testing, let&#x27;s look at how we can test a simple addition function. So assume we have a function <code>add</code> that adds two numbers:</p><pre><code class="language-scala">def add(a: Int, b: Int): Int = ???
</code></pre><p>in a typical test we start with some well-known values as test inputs and check if the function returns the expected values for each of the pair inputs:</p><table><thead><tr><th>input</th><th>expected output</th></tr></thead><tbody><tr><td>(0, 0)</td><td>0</td></tr><tr><td>(1, 0)</td><td>1</td></tr><tr><td>(0, 1)</td><td>1</td></tr><tr><td>(0, -1)</td><td>-1</td></tr><tr><td>(-1, 0)</td><td>-1</td></tr><tr><td>...</td><td>...</td></tr></tbody></table><p>Now we can test all the inputs and make sure the <code>add</code> function returns the expected values:</p><pre><code class="language-scala">import zio.test._

object AdditionSpec extends ZIOSpecDefault {

  def add(a: Int, b: Int): Int = ???

  val testData = Seq(
    ((0, 0), 0),
    ((1, 0), 1),
    ((0, 1), 1),
    ((0, -1), -1),
    ((-1, 0), -1),
    ((1, 1), 2),
    ((1, -1), 0),
    ((-1, 1), 0)
  )

  def spec =
    test(&quot;test add function&quot;) {
      assertTrue {
        testData.forall { case ((a, b), expected) =&gt;
          add(a, b) == expected
        }
      }
    }
}
</code></pre><p>This is not a very good approach because it is very hard to find a set of inputs that will cover all possible behaviors of the addition function.</p><p>Instead, in property-based testing, we extract the set of properties that our function must satisfy. So let&#x27;s think about the <code>add</code> function and find out what properties it must satisfy:</p><ol><li><strong>Commutative Property</strong>‚Äî It says that changing the order of addends does not change the result. So for all <code>a</code> and <code>b</code>, <code>add(a, b)</code> must be equal to <code>add(a, b)</code>:</li></ol><pre><code class="language-scala">assertTrue(add(a, b) == add(b, a))
</code></pre><ol start="2"><li><strong>Associative Property</strong>‚Äî This says that changing the grouping of addends does not change the result. So for all <code>a</code>, <code>b</code> and <code>c</code>, the <code>add(add(a, b), c)</code> must be equal to <code>add(a, add(b, c))</code>:</li></ol><pre><code class="language-scala">assertTrue(add(add(a, b), c) == add(a, add(b, c)))
</code></pre><ol start="3"><li><strong>Identity Property</strong>‚Äî For all <code>a</code>, <code>add(a, 0)</code> must be equal to <code>a</code>:</li></ol><pre><code class="language-scala">assertTrue(add(a, 0) == a)
</code></pre><p>If we test all of these properties we can be sure that the <code>add</code> function works as expected, so let&#x27;s see how we can do that using the <code>Gen</code> data type:</p><pre><code class="language-scala">import zio.test._
import zio.test._

object AdditionSpec extends ZIOSpecDefault {

  def add(a: Int, b: Int): Int = ???

  def spec = suite(&quot;Add Spec&quot;)(
    test(&quot;add is commutative&quot;) {
      check(Gen.int, Gen.int) { (a, b) =&gt;
        assertTrue(add(a, b) == add(b, a))
      }
    },
    test(&quot;add is associative&quot;) {
      check(Gen.int, Gen.int, Gen.int) { (a, b, c) =&gt;
        assertTrue(add(add(a, b), c) == add(a, add(b, c)))
      }
    },
    test(&quot;add is identitive&quot;) {
      check(Gen.int) { a =&gt;
        assertTrue(add(a, 0) == a)
      }
    }
  )
}
</code></pre><h2>Generators Are Deterministic by Default</h2><p>The important fact about generators is that they produce deterministic values. This means that if we run the same generator multiple times, it will always produce the same sequence of values. So the let us add some debugging print lines inside a test and see what values are produced:</p><pre><code class="language-scala">import zio.test._
import zio.test.TestAspect._

object ExampleSpec extends ZIOSpecDefault {
  def spec =
    test(&quot;example test&quot;) {
      check(Gen.int(0, 10)) { n =&gt;
        println(n)
        assertTrue(n + n == 2 * n)
      }
    } @@ samples(5)
}
</code></pre><p>We can see, every time we run the test, the generator will produce the same sequence of values:</p><pre><code class="language-scala">runSpec
9
3
0
9
6
+ example test
</code></pre><p>This is due to the fact that the generator uses a pseudo-random number generator which uses a deterministic algorithm. The generator provides a fixed seed number to its underlying deterministic algorithm to generate random numbers. As the seed number is fixed, the generator will always produce the same sequence of values. For more information, there is a separate page about this on <a href="../test/environment/random.md">TestRandom</a> which is the underlying service for generating test values.</p><p>This behavior helps us to have reproducible tests. But, if we might need non-deterministic tests values, we can use the <code>TestAspect.nondeterministic</code> to change the default behavior:</p><pre><code class="language-scala">myspec @@ TestAspect.nondeterministic
</code></pre><h2>Creating a Generator</h2><p>In the companion object of the <code>Gen</code> data type, there are tons of generators for various data types.</p><h3>Primitive Types Generators</h3><p>ZIO Test provides generators for primitive types such as <code>Gen.int</code>, <code>Gen.string</code>, <code>Gen.boolean</code>, <code>Gen.float</code>, <code>Gen.double</code>, <code>Gen.bigInt</code>, <code>Gen.byte</code>, <code>Gen.bigdecimal</code>, <code>Gen.long</code>, <code>Gen.char</code>, and <code>Gen.short</code>.</p><p>Let&#x27;s create an <code>Int</code> generator:</p><pre><code class="language-scala">import zio._
import zio.test._

val intGen: Gen[Any, Int] = Gen.int
</code></pre><h3>Character Generators</h3><p>In addition to <code>Gen.char</code>, ZIO Test offers a variety of specialized character generators:</p><ul><li><code>Gen.alphaChar</code> ‚Äî e.g. <code>Z, z, A, t, o, e, K, E, y, N</code></li><li><code>Gen.alphaNumericChar</code> ‚Äî e.g. <code>b, O, X, B, 4, M, k, 9, a, p</code></li><li><code>Gen.asciiChar</code> ‚Äî e.g. <code>, &gt;, , , , 2, k, , , </code></li><li><code>Gen.unicodeChar</code> ‚Äî e.g. <code>Ô¶∫, Óîø, Ïò∑, Ô®ç, Ó£î, ÎÆ≤, Ôπì, ÁôÆ, Ôò¨, ·ú£)</code></li><li><code>Gen.numericChar</code> ‚Äî e.g. <code>1, 0, 1, 5, 6, 9, 4, 4, 5, 2</code></li><li><code>Gen.printableChar</code> ‚Äî e.g. <code>H, J, (, Q, n, g, 4, G, 9, l</code></li><li><code>Gen.whitespaceChars</code> ‚Äî e.g. <code>, , ‚ÄÜ, , , ‚ÄÉ, ‚ÄÑ,  , ·öÄ, </code></li><li><code>Gen.hexChar</code> ‚Äî e.g. <code>3, F, b, 5, 9, e, 2, 8, b, e</code></li><li><code>Gen.hexCharLower</code> ‚Äî e.g. <code>f, c, 4, 4, c, 2, 5, 4, f, 3</code></li><li><code>Gen.hexCharUpper</code> ‚Äî e.g. <code>4, 8, 9, 8, C, 9, F, A, E, C</code></li></ul><h3>String Generators</h3><p>Besides the primitive string generator, <code>Gen.string</code>, ZIO Test also provides the following specialized generators:</p><ol><li><p><code>Gen.stringBounded</code> ‚Äî A generator of strings whose size falls within the specified bounds:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.stringBounded(1, 5)(Gen.alphaChar)
  .runCollectN(10)
  .debug
// Sample Output: List(b, YJXzY, Aro, y, WMPbj, Abxt, kJep, LKN, kUtr, xJ)
</code></pre></li><li><p><code>Gen.stringN</code> ‚Äî A generator of strings of fixed size:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.stringN(5)(Gen.alphaChar)
  .runCollectN(10)
  .debug
// Sample Output: List(BuywQ, tXCEy, twZli, ffLwI, BPEbz, OKYTi, xeDJW, iDUVn, cuMCr, keQAA)
</code></pre></li><li><p><code>Gen.string1</code> ‚Äî A generator of strings of at least one character.</p></li><li><p><code>Gen.alphaNumericString</code> ‚Äî A generator of alphanumeric characters.</p></li><li><p><code>Gen.alphaNumericStringBounded</code> ‚Äî A generator of alphanumeric strings whose size falls within the specified bounds.</p></li><li><p><code>Gen.iso_8859_1</code> ‚Äî A generator of strings that can be encoded in the ISO-8859-1 character set.</p></li><li><p><code>Gen.asciiString</code> ‚Äî A generator of US-ASCII characters.</p></li></ol><h3>Generating Fixed Values</h3><ol><li><p><code>Gen.const</code> ‚Äî A constant generator of the specified value.</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.const(true).runCollectN(5)
// Output: List(true, true, true, true, true)
</code></pre></li><li><p><code>Gen.constSample</code> ‚Äî A constant generator of the specified sample:</p><pre><code class="language-scala" metastring="mdoc:compile-only"> Gen.constSample(Sample.noShrink(false)).runCollectN(5)
// Output: List(true, true, true, true, true)
</code></pre></li><li><p><code>Gen.unit</code> ‚Äî A constant generator of the unit value.</p></li><li><p><code>Gen.throwable</code> ‚Äî A generator of throwables.</p></li></ol><p>Note that there is an empty generator called <code>Gen.empty</code>, which generates no values and returns nothing. We can think of that as a generator of empty stream, <code>Gen(Stream.empty)</code>.</p><h3>Generating from Fixed Values</h3><ol><li><code>Gen.elements</code> ‚Äî Constructs a non-deterministic generator that only generates randomly from the fixed values:</li></ol><pre><code class="language-scala">import java.time._

Gen.elements(
  DayOfWeek.MONDAY,
  DayOfWeek.TUESDAY,
  DayOfWeek.WEDNESDAY,
  DayOfWeek.THURSDAY,
  DayOfWeek.FRIDAY,
  DayOfWeek.SATURDAY,
  DayOfWeek.SUNDAY
).runCollectN(3).debug
</code></pre><ol start="2"><li><code>Gen.fromIterable</code> ‚Äî Constructs a deterministic generator that only generates the specified fixed values:</li></ol><pre><code class="language-scala">Gen.fromIterable(List(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;))
  .runCollectN(10)
  .debug
</code></pre><h3>Collection Generators</h3><p>ZIO Test has generators for collection data types such as <em>sets</em>, <em>lists</em>, <em>vectors</em>, <em>chunks</em>, and <em>maps</em>. These data types share similar APIs. The following example illustrates how the generator of sets works:</p><pre><code class="language-scala">// A sized generator of sets
Gen.setOf(Gen.alphaChar)
// Sample Output: Set(Y, M, c), Set(), Set(g, x, Q), Set(s), Set(f, J, b, R)

// A sized generator of non-empty sets
Gen.setOf1(Gen.alphaChar)    
// Sample Output: Set(Y), Set(L, S), Set(i), Set(H), Set(r, Z, z)

// A generator of sets whose size falls within the specified bounds.
Gen.setOfBounded(1, 3)(Gen.alphaChar)
// Sample Output: Set(Q), Set(q, J), Set(V, t, h), Set(c), Set(X, O)

// A generator of sets of the specified size.
Gen.setOfN(2)(Gen.alphaChar)
</code></pre><h3>Bounded Generator</h3><p>The <code>Gen.bounded</code> constructor is a generator whose size falls within the specified bounds:</p><pre><code class="language-scala">Gen.bounded(2, 5)(Gen.stringN(_)(Gen.alphaChar))
  .runCollectN(5)
</code></pre><h3>Suspended Generator</h3><p>The <code>Gen.suspend</code> constructs a generator lazily. This is useful to avoid infinite recursion when creating generators that refer to themselves.</p><h3>Unfold Generator</h3><p>The <code>unfoldGen</code> takes the initial state and depending on the previous state, it determines what will be the next generated value:</p><pre><code class="language-scala">def unfoldGen[R &lt;: Sized, S, A](s: S)(f: S =&gt; Gen[R, (S, A)]): Gen[R, List[A]]
</code></pre><p>Assume we want to test the built-in scala stack (<code>scala.collection.mutable.Stack</code>). One way to do that is to create an acceptable series of push and pop commands, and then check that the stack doesn&#x27;t throw any exception by executing these commands:</p><pre><code class="language-scala">sealed trait Command
case object Pop                    extends Command
final case class Push(value: Char) extends Command

val genPop:  Gen[Any, Command]    = Gen.const(Pop)
def genPush: Gen[Any, Command] = Gen.alphaChar.map(Push)

val genCommands: Gen[Sized, List[Command]] =
  Gen.unfoldGen(0) { n =&gt;
    if (n &lt;= 0)
      genPush.map(command =&gt; (n + 1, command))
    else
      Gen.oneOf(
        genPop.map(command =&gt; (n - 1, command)),
        genPush.map(command =&gt; (n + 1, command))
      )
  }
</code></pre><p>We are now ready to test the generated list of commands:</p><pre><code class="language-scala">import zio.test.{ test, _ }

test(&quot;unfoldGen&quot;) {
  check(genCommands) { commands =&gt;
    val stack = scala.collection.mutable.Stack.empty[Int]
    commands.foreach {
      case Pop =&gt; stack.pop()
      case Push(value) =&gt; stack.push(value)
    }
    assertCompletes
  }
}
</code></pre><h3>From a ZIO Effect</h3><ol><li><p><code>Gen.fromZIO</code></p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Any, Int] = Gen.fromZIO(Random.nextInt) 
</code></pre></li><li><p><code>Gen.fromZIOSample</code></p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Any, Int] =
  Gen.fromZIOSample(
    Random.nextInt.map(Sample.shrinkIntegral(0))
  )
</code></pre></li></ol><h3>From a Random Effect</h3><ol start="3"><li><p><code>Gen.fromRandom</code> ‚Äî Constructs a generator from a function that uses randomness:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Any, Int] = Gen.fromRandom(_.nextInt) 
</code></pre></li><li><p><code>Gen.fromRandomSample</code> ‚Äî Constructs a generator from a function that uses randomness to produce a sample:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Any, Int] =
  Gen.fromRandomSample(
    _.nextIntBounded(20).map(Sample.shrinkIntegral(0))
  )
</code></pre></li></ol><h3>Uniform and Non-uniform Generators</h3><ol><li><p><code>Gen.uniform</code> ‚Äî A generator of uniformly distributed doubles between <!-- -->[0, 1]<!-- -->.</p></li><li><p><code>Gen.weighted</code> ‚Äî A generator which chooses one of the given generators according to their weights. For example, the following generator will generate 90% true and 10% false values:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val trueFalse = Gen.weighted((Gen.const(true), 9), (Gen.const(false), 1))
trueFalse.runCollectN(10).debug
// Sample Output: List(false, false, false, false, false, false, false, false, true, false)
</code></pre></li><li><p><code>Gen.exponential</code> ‚Äî A generator of exponentially distributed doubles with mean <code>1</code>:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.exponential.map(x =&gt; math.round(x * 100) / 100.0)
  .runCollectN(10)
  .debug
// Sample Output: List(0.22, 3.02, 1.96, 1.13, 0.81, 0.92, 1.7, 1.47, 1.55, 0.46)
</code></pre></li></ol><h3>Generating Date/Time Types</h3><table><thead><tr><th>Date/Time Types</th><th>Generators</th></tr></thead><tbody><tr><td><code>java.time.DayOfWeek</code></td><td><code>Gen.dayOfWeek</code></td></tr><tr><td><code>java.time.Month</code></td><td><code>Gen.month</code></td></tr><tr><td><code>java.time.Year</code></td><td><code>Gen.year</code></td></tr><tr><td><code>java.time.Instant</code></td><td><code>Gen.instant</code></td></tr><tr><td><code>java.time.MonthDay</code></td><td><code>Gen.monthDay</code></td></tr><tr><td><code>java.time.YearMonth</code></td><td><code>Gen.yearMonth</code></td></tr><tr><td><code>java.time.ZoneId</code></td><td><code>Gen.zoneId</code></td></tr><tr><td><code>java.time.ZoneOffset</code></td><td><code>Gen.zoneOffset</code></td></tr><tr><td><code>java.time.ZonedDateTime</code></td><td><code>Gen.zonedDateTime</code></td></tr><tr><td><code>java.time.OffsetTime</code></td><td><code>Gen.offsetTime</code></td></tr><tr><td><code>java.time.OffsetDateTime</code></td><td><code>Gen.offsetDateTime</code></td></tr><tr><td><code>java.time.Period</code></td><td><code>Gen.period</code></td></tr><tr><td><code>java.time.LocalDate</code></td><td><code>Gen.localDate</code></td></tr><tr><td><code>java.time.LocalDateTime</code></td><td><code>Gen.localDateTime</code></td></tr><tr><td><code>java.time.LocalTime</code></td><td><code>Gen.localTime</code></td></tr><tr><td><code>zio.duration.Duration</code></td><td><code>Gen.finiteDuration</code></td></tr></tbody></table><h3>Function Generators</h3><p>To test some properties, we need to generate functions. There are two types of function generators:</p><ol><li><p><code>Gen.function</code> ‚Äî It takes a generator of type <code>B</code> and produces a generator of functions from <code>A</code> to <code>B</code>:</p><pre><code class="language-scala">def function[R, A, B](gen: Gen[R, B]): Gen[R, A =&gt; B]
</code></pre></li></ol><p>Two <code>A</code> values will be considered to be equal, and thus will be guaranteed to generate the same <code>B</code> value, if they have the same
<code>hashCode</code>.</p><ol start="2"><li><p><code>Gen.functionWith</code> ‚Äî It takes a generator of type <code>B</code> and also a hash function for <code>A</code> values, and produces a generator of functions from <code>A</code> to <code>B</code>:</p><pre><code class="language-scala">def functionWith[R, A, B](gen: Gen[R, B])(hash: A =&gt; Int): Gen[R, A =&gt; B]
</code></pre></li></ol><p>Two <code>A</code> values will be considered to be equal, and thus will be guaranteed to generate the same <code>B</code> value, if they have the same hash. This is useful when <code>A</code> does not implement <code>hashCode</code> in a way that is consistent with equality.</p><p>Accordingly, ZIO Test provides a variety of function generators for <code>Function2</code>, <code>Function3</code>, ..., and also the <code>PartialFunction</code>: </p><ul><li><code>Gen.function2</code> ‚Äî  Gen<!-- -->[R, C]<!-- --> =&gt; Gen<!-- -->[R, (A, B) =&gt; C]</li><li><code>Gen.functionWith2</code> ‚Äî Gen<!-- -->[R, B]<!-- --> =&gt; ((A, B) =&gt; Int) =&gt; Gen<!-- -->[R, (A, B) =&gt; C]</li><li><code>Gen.partialFunction</code> ‚Äî Gen<!-- -->[R, B]<!-- --> =&gt; Gen[R, PartialFunction<!-- -->[A, B]<!-- -->]</li><li><code>Gen.partialFunctionWith</code> ‚Äî Gen<!-- -->[R, B]<!-- --> =&gt; (A =&gt; Int) =&gt; Gen[R, PartialFunction<!-- -->[A, B]<!-- -->]</li></ul><p>Let&#x27;s write a test for <code>ZIO.foldLeft</code> operator. This operator has the following signature:</p><pre><code class="language-scala">def foldLeft[R, E, S, A](in: =&gt; Iterable[A])(zero: =&gt; S)(f: (S, A) =&gt; ZIO[R, E, S]): ZIO[R, E, S]
</code></pre><p>We want to test the following property:</p><pre><code class="language-scala">‚àÄ (in, zero, f) =&gt; ZIO.foldLeft(in)(zero)(f) == ZIO(List.foldLeft(in)(zero)(f))
</code></pre><p>To test this property, we have an input of type <code>(Int, Int) =&gt; Int</code>. So we need a Function2 generator of integers:</p><pre><code class="language-scala">val func2: Gen[Any, (Int, Int) =&gt; Int] = Gen.function2(Gen.int)
</code></pre><p>Now we can test this property:</p><pre><code class="language-scala">import zio._
import zio.test.{test, _}

test(&quot;ZIO.foldLeft should have the same result with List.foldLeft&quot;) {
  check(Gen.listOf(Gen.int), Gen.int, func2) { case (in, zero, f) =&gt;
    assertZIO(
      ZIO.foldLeft(in)(zero)((s, a) =&gt; ZIO.attempt(f(s, a)))
    )(Assertion.equalTo(
      in.foldLeft(zero)((s, a) =&gt; f(s, a)))
    )
  }
}
</code></pre><h3>Generating ZIO Values</h3><ol><li><p>Successful effects (<code>Gen.successes</code>):</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Any, UIO[Int]] = Gen.successes(Gen.int(-10, 10))
</code></pre></li><li><p>Failed effects (<code>Gen.failures</code>):</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Sized, IO[String, Nothing]] = Gen.failures(Gen.string)
</code></pre></li><li><p>Died effects (<code>Gen.died</code>):</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: Gen[Any, UIO[Nothing]] = Gen.died(Gen.throwable)
</code></pre></li><li><p>Cause values (<code>Gen.causes</code>):</p><pre><code class="language-scala" metastring="mdoc:compile-only">val causes: Gen[Sized, Cause[String]] = 
  Gen.causes(Gen.string, Gen.throwable)
</code></pre></li><li><p>Chained effects (<code>Gen.chined</code>, <code>Gen.chainedN</code>): A generator of effects that are the result of chaining the specified effect with itself a random number of times.</p><p>Let&#x27;s see some example of chained ZIO effects:</p><pre><code class="language-scala" metastring="mdoc:compile-only">import zio._
val effect1 = ZIO(2).flatMap(x =&gt; ZIO(x * 2))
val effect2 = ZIO(1) *&gt; ZIO(2)
</code></pre><p>By using <code>Gen.chaned</code> or <code>Gen.chanedN</code> generator, we can create generators of chained effects:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val chained : Gen[Sized, ZIO[Any, Nothing, Int]] = 
  Gen.chained(Gen.successes(Gen.int))
  
val chainedN: Gen[Any, ZIO[Any, Nothing, Int]] = 
  Gen.chainedN(5)(Gen.successes(Gen.int))
</code></pre></li><li><p>Concurrent effects (<code>Gen.concurrent</code>): A generator of effects that are the result of applying concurrency combinators to the specified effect that are guaranteed not to change its value.</p><pre><code class="language-scala" metastring="mdoc:compile-only">val random  : Gen[Any, UIO[Int]] = Gen.successes(Gen.int).flatMap(Gen.concurrent)
val constant: Gen[Any, UIO[Int]]    = Gen.concurrent(ZIO(3))
</code></pre></li><li><p>Parallel effects (<code>Gen.parallel</code>): A generator of effects that are the result of applying parallelism combinators to the specified effect that are guaranteed not to change its value.</p><pre><code class="language-scala" metastring="mdoc:compile-only">val random: Gen[Sized, UIO[String]] =
  Gen.successes(Gen.string).flatMap(Gen.parallel)
  
val constant: Gen[Any, UIO[String]] =
  Gen.parallel(ZIO(&quot;Hello&quot;))
</code></pre></li></ol><h3>Generating Compound Types</h3><ol><li><p>tuples ‚Äî We can combine generators using for-comprehension syntax and tuples:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val tuples: Gen[Any, (Int, Double)] =
  for {
    a &lt;- Gen.int
    b &lt;- Gen.double
  } yield (a, b)
</code></pre></li><li><p><code>Gen.oneOf</code> ‚Äî It takes variable number of generators and select one of them:</p><pre><code class="language-scala" metastring="mdoc:compile-only">sealed trait Color
case object Red extends Color
case object Blue extends Color
case object Green extends Color

Gen.oneOf(Gen.const(Red), Gen.const(Blue), Gen.const(Green))
// Sample Output: Green, Green, Red, Green, Red
</code></pre></li><li><p><code>Gen.option</code> ‚Äî A generator of <em>optional</em> values:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val intOptions: Gen[Any, Option[Int]] = Gen.option(Gen.int)
val someInts:   Gen[Any, Option[Int]] = Gen.some(Gen.int)
val nons:       Gen[Any, Option[Nothing]]     = Gen.none
</code></pre></li><li><p><code>Gen.either</code> ‚Äî A generator of <em>either</em> values:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val char: Gen[Any, Either[Char, Char]] =
  Gen.either(Gen.numericChar, Gen.alphaChar)
</code></pre></li><li><p><code>Gen.collectAll</code> ‚Äî Composes the specified generators to create a <em>cartesian product of elements</em> with the specified function:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: ZIO[Any, Nothing, List[List[Int]]] =
  Gen.collectAll(
    List(
      Gen.fromIterable(List(1, 2)),
      Gen.fromIterable(List(3)),
      Gen.fromIterable(List(4, 5))
    )
  ).runCollect
// Output:
// List(
//  List(1, 3, 4),
//  List(1, 3, 5),
//  List(2, 3, 4),
//  List(2, 3, 5)
//)
</code></pre></li><li><p><code>Gen.concatAll</code> ‚Äî Combines the specified deterministic generators to return a new deterministic generator that generates all the values generated by the specified generators:</p><pre><code class="language-scala" metastring="mdoc:compile-only">val gen: ZIO[Any, Nothing, List[Int]] =
  Gen.concatAll(
    List(
      Gen.fromIterable(List(1, 2)),
      Gen.fromIterable(List(3)),
      Gen.fromIterable(List(4, 5))
    )
  ).runCollect
// Output: List(1, 2, 3, 4, 5)
</code></pre></li></ol><h3>Sized Generators</h3><ol><li><p><code>Gen.sized</code> ‚Äî A sized generator takes a function from <code>Int</code> to <code>Gen[R, A]</code> and creates a generator by applying a size to that function:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.sized(Gen.int(0, _))
  .runCollectN(10)
  .provideCustomLayer(Sized.live(5))
  .debug
// Sample Output: List(5, 4, 1, 2, 0, 4, 2, 0, 1, 2)
</code></pre></li><li><p><code>Gen.size</code> ‚Äî A generator which accesses the <em>size</em> from the environment and generates that:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.size
  .runCollectN(5)
  .provideCustomLayer(Sized.live(100))
  .debug
// Output: List(100, 100, 100, 100, 100)
</code></pre></li></ol><p>There are also three sized generators, named <em>small</em>, <em>medium</em> and <em>large</em>, that use an exponential distribution of size values:</p><ol><li><p><code>Gen.small</code> ‚Äî The values generated will be strongly concentrated towards the lower end of the range but a few larger values will still be generated:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.small(Gen.const(_))
  .runCollectN(10)
  .provideCustomLayer(Sized.live(1000))
  .debug
// Output: List(6, 39, 73, 3, 57, 51, 40, 12, 110, 46)
</code></pre></li><li><p><code>Gen.medium</code> ‚Äî The majority of sizes will be towards the lower end of the range but some larger sizes will be generated as well:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.medium(Gen.const(_))
  .runCollectN(10)
  .provideCustomLayer(Sized.live(1000))
  .debug
// Output: List(93, 42, 58, 228, 42, 5, 12, 214, 106, 79)
</code></pre></li><li><p><code>Gen.large</code> ‚Äî The values generated will be strongly concentrated towards the lower end of the range but a few larger values will still be generated:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.large(Gen.const(_))
  .runCollectN(10)
  .provideCustomLayer(Sized.live(1000))
  .debug
// Output: List(797, 218, 596, 278, 301, 779, 165, 486, 695, 788)
</code></pre></li></ol><h2>Running a Generator</h2><p>To run a generator, we can call <code>runCollect</code> operation:</p><pre><code class="language-scala">val ints: ZIO[Any, Nothing, List[Int]] = intGen.runCollect.debug
// Output: List(-2090696713)
</code></pre><p>This will return a <code>ZIO</code> effect containing all its values in a list, which in this example it contains only one element.</p><p>To create more samples, we can use <code>Gen#runCollectN</code>, which repeatedly runs the generator as much as we need. In this example, it will generate a list of containing 5 integer elements:</p><pre><code class="language-scala">intGen.runCollectN(5).debug
</code></pre><p>In addition, there is an operator called <code>Gen#runHead</code>, which returns the first value generated by the generator.</p><h2>Operators on Generators</h2><ol><li><p><code>Gen#zipWith</code> ‚Äî Composes this generator with the specified generator to create a cartesian product of elements with the specified function:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.elements(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).zipWith(Gen.elements(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))(_ + _)
  .runCollectN(5)
// Sample Output: List(b1, a2, c1, b1, b1)
</code></pre></li><li><p><code>Gen#zip</code> ‚Äî Composes this generator with the specified generator to create a cartesian product of elements.</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.elements(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).zip(Gen.elements(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))
  .runCollectN(5)
(Gen.elements(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) &lt;*&gt; Gen.elements(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;))
  .runCollectN(5)
  
// Sample Output: List((a,3), (a,3), (c,3), (b,3), (c,2))
</code></pre></li><li><p><code>Gen#collect</code> ‚Äî Maps the values produced by this generator with the specified partial function, discarding any values the partial function is not defined at:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.int(-10, +10)
  .collect { case n if n % 2 == 0 =&gt; n }
  .runCollectN(5)
  .debug
// Smaple Output: List(-6, -8, -2, 4, -6)
</code></pre></li><li><p><code>Gen#filter</code> ‚Äî Filters the values produced by this generator, discarding any values that do not meet the specified predicate:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.int(-10, +10).filter(_ % 2 == 0).runCollectN(5) 
// Sample Output: List(-6, 10, 0, -8, 4)
</code></pre><p>Using <code>filter</code> can reduce test performance, especially if many values must be discarded. It is recommended to use combinators such as <code>map</code> and <code>flatMap</code> to create generators of the desired values instead:</p><pre><code class="language-scala" metastring="mdoc:compile-only">Gen.int(-10, +10).map(_ * 2).runCollectN(5)
// Sample Output: List(2, 6, -6, 20, -14)
</code></pre></li></ol><h2>Shrinking</h2><p>In Property-Based Testing, we specify certain properties of a program, then we ask the testing framework to generate random test data to discover counterexamples. The existence of counterexamples shows that our function, which is under the test, is not correct. Unfortunately, in almost all cases, the first counterexample is not the minimal one, and they are fairly large or complex. So it is not a pretty good sample to describe why our test is failing.</p><p>Shrinking is a mechanism that tries to find the smallest counterexample, which is the root cause of the test failure. So it helps a developer to find out why the test is failing.</p><p>Finding the smallest failing case is somehow cumbersome and requires many attempts. As a developer, we do not need to do shrinking ourselves. All generators in ZIO Test have built-in shrinkers, so when we test properties, in case of test failures, the ZIO Test attempts to reduce the counterexamples forward their own zero points.</p><p>Let&#x27;s write a <code>reverse</code> function with an incorrect implementation:</p><pre><code class="language-scala">def reverse[T](list: List[T]): List[T] =
  if (list.length &gt; 6) list.reverse.dropRight(1) else list.reverse
</code></pre><p>We know that if we reverse a list twice, it should give us the original list, so let&#x27;s check this property:</p><pre><code class="language-scala">import zio.test._

suite(&quot;ReverseSpec&quot;){
  // ‚àÄ xs. reverse(reverse(xs)) == xs
  test(&quot;reversing a list twice must give the original list&quot;)(
    check(Gen.listOf(Gen.int)) { list =&gt;
      assertTrue(reverse(reverse(list)) == list)
    }
  )
}
</code></pre><p>The following messages, is a sample output of the test renderer, after running the test:</p><pre><code>- ReverseSpec
  - reversing a list twice must give the original list
    Test failed after 7 iterations with input: List(0, 0, 0, 0, 0, 0, 0)
    Original input before shrinking was: List(724856966, 1976458409, -940069360, -191508820, -291932258, 1296893186, 2010410723, 1134770522, 1260002835)
    ‚úó List(0, 0, 0, 0, 0, 0) was not equal to List(0, 0, 0, 0, 0, 0, 0)
    reverse(reverse(list)) == list
    reverse(reverse(list)) = List(0, 0, 0, 0, 0, 0)
</code></pre><p>The initial failing input discovered by ZIO Test is <code>List(724856966, 1976458409, -940069360, -191508820, -291932258, 1296893186, 2010410723, 1134770522, 1260002835)</code>. The ZIO Test then tries to find the simplest counterexample which is <code>List(0, 0, 0, 0, 0, 0, 0)</code>. So the property still fails with the final shrunk value. The original input is a list of 9 somewhat useless numbers, while after shrinking, we have a list of 7 zero numbers, so we can find the bug faster.</p></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/2-0-0/datatypes/test/gen";window.___webpackCompilationHash="c9a81335e251e70eaae1";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0e4cbbcc00d4e08af0a8.js"],"app":["/app-b67510c2f2944fbdda0c.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-d7ac5bbd88d2967e36ed.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/gatsby-theme-zio/polyfill-0e4cbbcc00d4e08af0a8.js" nomodule=""></script><script src="/gatsby-theme-zio/app-b67510c2f2944fbdda0c.js" async=""></script><script src="/gatsby-theme-zio/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/gatsby-theme-zio/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/gatsby-theme-zio/webpack-runtime-e8cb2cd16229bfcc03b8.js" async=""></script></body></html>