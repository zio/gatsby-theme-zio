<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/gatsby-theme-zio/styles.0d77a1f9790ad3befaea.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><h2>Introduction</h2><p>A <code>ZSink[R, E, I, L, Z]</code> is used to consume elements produced by a <code>ZStream</code>. You can think of a sink as a function that will consume a variable amount of <code>I</code> elements (could be 0, 1, or many!), might fail with an error of type <code>E</code>, and will eventually yield a value of type <code>Z</code> together with a remainder of type <code>L</code> as leftover.</p><p>To consume a stream using <code>ZSink</code> we can pass <code>ZSink</code> to the <code>ZStream#run</code> function:</p><pre><code class="language-scala">import zio._
import zio.stream._

val stream = ZStream.fromIterable(1 to 1000)
val sink   = ZSink.sum[Int]
val sum    = stream.run(sink)
</code></pre><h2>Creating sinks</h2><p>The <code>zio.stream</code> provides numerous kinds of sinks to use.</p><h3>Common Constructors</h3><p><strong>ZSink.head</strong> — It creates a sink containing the first element, returns <code>None</code> for empty streams:</p><pre><code class="language-scala">val sink: ZSink[Any, Nothing, Int, Int, Option[Int]] = ZSink.head[Int]
val head: ZIO[Any, Nothing, Option[Int]]             = ZStream(1, 2, 3, 4).run(sink)
// Result: Some(1)
</code></pre><p><strong>ZSink.last</strong> — It consumes all elements of a stream and returns the last element of the stream:</p><pre><code class="language-scala">val sink: ZSink[Any, Nothing, Int, Int, Option[Int]] = ZSink.last[Int]
val last: ZIO[Any, Nothing, Option[Int]]                 = ZStream(1, 2, 3, 4).run(sink)
// Result: Some(4)
</code></pre><p><strong>ZSink.count</strong> — A sink that consumes all elements of the stream and counts the number of elements fed to it:</p><pre><code class="language-scala">val sink : ZSink[Any, Nothing, Int, Nothing, Int] = ZSink.sum[Int]
val count: ZIO[Any, Nothing, Int]                 = ZStream(1, 2, 3, 4, 5).run(sink)
// Result: 5
</code></pre><p><strong>ZSink.sum</strong> — A sink that consumes all elements of the stream and sums incoming numeric values:</p><pre><code class="language-scala">val sink : ZSink[Any, Nothing, Int, Nothing, Int] = ZSink.sum[Int]
val sum: ZIO[Any, Nothing, Int]                 = ZStream(1, 2, 3, 4, 5).run(sink)
// Result: 15
</code></pre><p><strong>ZSink.take</strong> — A sink that takes the specified number of values and result in a <code>Chunk</code> data type:</p><pre><code class="language-scala">val sink  : ZSink[Any, Nothing, Int, Int, Chunk[Int]] = ZSink.take[Int](3)
val stream: ZIO[Any, Nothing, Chunk[Int]]             = ZStream(1, 2, 3, 4, 5).run(sink)
// Result: Chunk(1, 2, 3)
</code></pre><p><strong>ZSink.drain</strong> — A sink that ignores its inputs:</p><pre><code class="language-scala">val drain: ZSink[Any, Nothing, Any, Nothing, Unit] = ZSink.drain
</code></pre><p><strong>ZSink.timed</strong> — A sink that executes the stream and times its execution:</p><pre><code class="language-scala">val timed: ZSink[Any, Nothing, Any, Nothing, Duration] = ZSink.timed
val stream: ZIO[Any, Nothing, Long] =
  ZStream(1, 2, 3, 4, 5).fixed(2.seconds).run(timed).map(_.getSeconds)
// Result: 10
</code></pre><p><strong>ZSink.foreach</strong> — A sink that executes the provided effectful function for every element fed to it:</p><pre><code class="language-scala">val printer: ZSink[Any, IOException, Int, Int, Unit] =
  ZSink.foreach((i: Int) =&gt; printLine(i))
val stream : ZIO[Any, IOException, Unit]             =
  ZStream(1, 2, 3, 4, 5).run(printer)
</code></pre><h3>From Success and Failure</h3><p>Similar to the <code>ZStream</code> data type, we can create a <code>ZSink</code> using <code>fail</code> and <code>succeed</code> methods.</p><p>A sink that doesn&#x27;t consume any element from its upstream and successes with a value of <code>Int</code> type:</p><pre><code class="language-scala">val succeed: ZSink[Any, Any, Any, Nothing, Int] = ZSink.succeed(5)
</code></pre><p>A sink that doesn&#x27;t consume any element from its upstream and intentionally fails with a message of <code>String</code> type:</p><pre><code class="language-scala">val failed : ZSink[Any, String, Any, Nothing, Nothing] = ZSink.fail(&quot;fail!&quot;)
</code></pre><h3>Collecting</h3><p>To create a sink that collects all elements of a stream into a <code>Chunk[A]</code>, we can use <code>ZSink.collectAll</code>:</p><pre><code class="language-scala">val stream    : UStream[Int]    = ZStream(1, 2, 3, 4, 5)
val collection: UIO[Chunk[Int]] = stream.run(ZSink.collectAll[Int])
// Output: Chunk(1, 2, 3, 4, 5)
</code></pre><p>We can collect all elements into a <code>Set</code>:</p><pre><code class="language-scala">val collectAllToSet: ZSink[Any, Nothing, Int, Nothing, Set[Int]] = ZSink.collectAllToSet[Int]
val stream: ZIO[Any, Nothing, Set[Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToSet)
// Output: Set(1, 3, 2, 5)
</code></pre><p>Or we can collect and merge them into a <code>Map[K, A]</code> using a merge function. In the following example, we use <code>(_:Int) % 3</code> to determine map keys and, we provide <code>_ + _</code> function to merge multiple elements with the same key:</p><pre><code class="language-scala">val collectAllToMap: ZSink[Any, Nothing, Int, Nothing, Map[Int, Int]] = ZSink.collectAllToMap((_: Int) % 3)(_ + _)
val stream: ZIO[Any, Nothing, Map[Int, Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToMap)
// Output: Map(1 -&gt; 3, 0 -&gt; 6, 2 -&gt; 7)
</code></pre><p><strong>ZSink.collectAllN</strong> — Collects incoming values into chunk of maximum size of <code>n</code>:</p><pre><code class="language-scala">ZStream(1, 2, 3, 4, 5).run(
  ZSink.collectAllN(3)
)
// Output: Chunk(1,2,3), Chunk(4,5)
</code></pre><p><strong>ZSink.collectAllWhile</strong> — Accumulates incoming elements into a chunk as long as they verify the given predicate:</p><pre><code class="language-scala">ZStream(1, 2, 0, 4, 0, 6, 7).run(
  ZSink.collectAllWhile(_ != 0)
)
// Output: Chunk(1,2), Chunk(4), Chunk(6,7)
</code></pre><p><strong>ZSink.collectAllToMapN</strong> — Creates a sink accumulating incoming values into maps of up to <code>n</code> keys. Elements are mapped to keys using the function <code>key</code>; elements mapped to the same key will be merged with the function <code>f</code>:</p><pre><code class="language-scala">object ZSink {
  def collectAllToMapN[Err, In, K](
    n: Long
  )(key: In =&gt; K)(f: (In, In) =&gt; In): ZSink[Any, Err, In, Err, In, Map[K, In]]
}
</code></pre><p>Let&#x27;s do an example:</p><pre><code class="language-scala">ZStream(1, 2, 0, 4, 5).run(
  ZSink.collectAllToMapN[Nothing, Int, Int](10)(_ % 3)(_ + _)
)
// Output: Map(1 -&gt; 5, 2 -&gt; 7, 0 -&gt; 0)
</code></pre><p><strong>ZSink.collectAllToSetN</strong> — Creates a sink accumulating incoming values into sets of maximum size <code>n</code>:</p><pre><code class="language-scala">ZStream(1, 2, 1, 2, 1, 3, 0, 5, 0, 2).run(
  ZSink.collectAllToSetN(3)
)
// Output: Set(1,2,3), Set(0,5,2), Set(1)
</code></pre><h3>Folding</h3><p>Basic fold accumulation of received elements:</p><pre><code class="language-scala">ZSink.foldLeft[Int, Int](0)(_ + _)
</code></pre><p>A fold with short-circuiting has a termination predicate that determines the end of the folding process:</p><pre><code class="language-scala">ZStream.iterate(0)(_ + 1).run(
  ZSink.fold(0)(sum =&gt; sum &lt;= 10)((acc, n: Int) =&gt; acc + n)
)
// Output: 15
</code></pre><p><strong>ZSink.foldWeighted</strong> — Creates a sink that folds incoming elements until reaches the <code>max</code> worth of elements determined by the <code>costFn</code>, then the pipeline emits the computed value and restarts the folding process:</p><pre><code class="language-scala">object ZSink {
  def foldWeighted[Err, In, S](z: S)(costFn: (S, In) =&gt; Long, max: Long)(
    f: (S, In) =&gt; S
  ): ZSink[Any, Err, In, Err, In, S] = ???
}
</code></pre><p>In the following example, each time we consume a new element we return one as the weight of that element using cost function. After three times, the sum of the weights reaches to the <code>max</code> number, and the folding process restarted. So we expect this pipeline to group each three elements in one <code>Chunk</code>:</p><pre><code class="language-scala">ZStream(3, 2, 4, 1, 5, 6, 2, 1, 3, 5, 6)
  .transduce(
    ZSink
      .foldWeighted(Chunk[Int]())(
        (_, _: Int) =&gt; 1,
        3
      ) { (acc, el) =&gt;
        acc ++ Chunk(el)
      }
  )
// Output: Chunk(3,2,4),Chunk(1,5,6),Chunk(2,1,3),Chunk(5,6)
</code></pre><p>Another example is when we want to group element which sum of them equal or less than a specific number:</p><pre><code class="language-scala">ZStream(1, 2, 2, 4, 2, 1, 1, 1, 0, 2, 1, 2)
  .transduce(
    ZSink
      .foldWeighted(Chunk[Int]())(
        (_, i: Int) =&gt; i.toLong,
        5
      ) { (acc, el) =&gt;
        acc ++ Chunk(el)
      }
  )
// Output: Chunk(1,2,2),Chunk(4),Chunk(2,1,1,1,0),Chunk(2,1,2)
</code></pre><blockquote><p><strong>Note</strong>:</p><p>The <code>ZSink.foldWeighted</code> cannot decompose elements whose weight is more than the <code>max</code> number. So elements that have an individual cost larger than <code>max</code> will force the pipeline to cross the <code>max</code> cost. In the last example, if the source stream was <code>ZStream(1, 2, 2, 4, 2, 1, 6, 1, 0, 2, 1, 2)</code> the output would be <code>Chunk(1,2,2),Chunk(4),Chunk(2,1),Chunk(6),Chunk(1,0,2,1),Chunk(2)</code>. As we see, the <code>6</code> element crossed the <code>max</code> cost.</p><p>To decompose these elements, we should use <code>ZSink.foldWeightedDecompose</code> function.</p></blockquote><p><strong>ZSink.foldWeightedDecompose</strong> — As we saw in the previous section, we need a way to decompose elements — whose cause the output aggregate cross the <code>max</code> — into smaller elements. This version of fold takes <code>decompose</code> function and enables us to do that:</p><pre><code class="language-scala">object ZSink {
  def foldWeightedDecompose[Err, In, S](
     z: S
   )(costFn: (S, In) =&gt; Long, max: Long, decompose: In =&gt; Chunk[In])(
     f: (S, In) =&gt; S
   ): ZSink[Any, Err, In, Err, In, S] = ???
}
</code></pre><p>In the following example, we are break down elements that are bigger than 5, using <code>decompose</code> function:</p><pre><code class="language-scala">ZStream(1, 2, 2, 2, 1, 6, 1, 7, 2, 1, 2)
  .transduce(
    ZSink
      .foldWeightedDecompose(Chunk[Int]())(
        (_, i: Int) =&gt; i.toLong,
        5,
        (i: Int) =&gt;
          if (i &gt; 5) Chunk(i - 1, 1) else Chunk(i)
      )((acc, el) =&gt; acc ++ Chunk.succeed(el))
  )
// Ouput: Chunk(1,2,2),Chunk(2,1),Chunk(5),Chunk(1,1),Chunk(5),Chunk(1,1,2,1),Chunk(2)
</code></pre><p><strong>ZSink.foldUntil</strong> — Creates a sink that folds incoming element until specific <code>max</code> elements have been folded:</p><pre><code class="language-scala">ZStream(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
  .run(ZSink.foldUntil(0, 3)(_ + _))
// Output: 6, 15, 24, 10
</code></pre><p><strong>ZSink.foldLeft</strong> — This sink will fold the inputs until the stream ends, resulting in one element:</p><pre><code class="language-scala">val stream: ZIO[Any, Nothing, Int] = 
  ZStream(1, 2, 3, 4).run(ZSink.foldLeft[Int, Int](0)(_ + _))
// Output: 10
</code></pre><h3>From Effect</h3><p>The <code>ZSink.fromEffect</code> creates a single-value sink produced from an effect:</p><pre><code class="language-scala">val sink = ZSink.fromZIO(ZIO.succeed(1))
</code></pre><h3>From File</h3><p>The <code>ZSink.fromPath</code> creates a file sink that consumes byte chunks and writes them to the specified file:</p><pre><code class="language-scala">def fileSink(path: Path): ZSink[Any, Throwable, String, Byte, Long] =
  ZSink
    .fromPath(path)
    .contramapChunks[String](_.flatMap(_.getBytes))

val result = ZStream(&quot;Hello&quot;, &quot;ZIO&quot;, &quot;World!&quot;)
  .intersperse(&quot;\n&quot;)
  .run(fileSink(Paths.get(&quot;file.txt&quot;)))
</code></pre><h3>From OutputStream</h3><p>The <code>ZSink.fromOutputStream</code> creates a sink that consumes byte chunks and write them to the <code>OutputStream</code>:</p><pre><code class="language-scala">ZStream(&quot;Application&quot;, &quot;Error&quot;, &quot;Logs&quot;)
  .intersperse(&quot;\n&quot;)
  .run(
    ZSink
      .fromOutputStream(java.lang.System.err)
      .contramapChunks[String](_.flatMap(_.getBytes))
  )
</code></pre><h3>From Queue</h3><p>A queue has a finite or infinite buffer size, so they are useful in situations where we need to consume streams as fast as we can, and then do some batching operations on consumed messages. By using <code>ZSink.fromQueue</code> we can create a sink that is backed by a queue; it enqueues each element into the specified queue:</p><pre><code class="language-scala">val myApp: IO[IOException, Unit] =
  for {
    queue    &lt;- Queue.bounded[Int](32)
    producer &lt;- ZStream
      .iterate(1)(_ + 1)
      .fixed(200.millis)
      .run(ZSink.fromQueue(queue))
      .fork
    consumer &lt;- queue.take.flatMap(printLine(_)).forever
    _        &lt;- producer.zip(consumer).join
  } yield ()
</code></pre><h3>From Hub</h3><p><code>Hub</code> is an asynchronous data type in which publisher can publish their messages to that and subscribers can subscribe to take messages from the <code>Hub</code>. The <code>ZSink.fromHub</code> takes a <code>Hub</code> and returns a <code>ZSink</code> which publishes each element to that <code>Hub</code>.</p><p>In the following example, the <code>sink</code> consumes elements of the <code>producer</code> stream and publishes them to the <code>hub</code>. We have two consumers that are subscribed to that hub and they are taking its elements forever:</p><pre><code class="language-scala">val myApp: ZIO[Any, IOException, Unit] =
  for {
    promise &lt;- Promise.make[Nothing, Unit]
    hub &lt;- Hub.bounded[Int](1)
    sink &lt;- ZIO.succeed(ZSink.fromHub(hub))
    producer &lt;- ZStream.iterate(0)(_ + 1).fixed(1.seconds).run(sink).fork
    consumers &lt;- ZIO.scoped {
      hub.subscribe.zip(hub.subscribe).flatMap { case (left, right) =&gt;
        for {
          _ &lt;- promise.succeed(())
          f1 &lt;- left.take.flatMap(e =&gt; printLine(s&quot;Left Queue: $e&quot;)).forever.fork
          f2 &lt;- right.take.flatMap(e =&gt; printLine(s&quot;Right Queue: $e&quot;)).forever.fork
          _ &lt;- f1.zip(f2).join
        } yield ()
      }
    }.fork
    _ &lt;- promise.await
    _ &lt;- producer.zip(consumers).join
  } yield ()
</code></pre><h2>Operations</h2><p>Having created the sink, we can transform it with provided operations.</p><h3>contramap</h3><p>Contramap is a simple combinator to change the domain of an existing function. While <em>map</em> changes the co-domain of a function, the <em>contramap</em> changes the domain of a function. So the <em>contramap</em> takes a function and maps over its input.</p><p>This is useful when we have a fixed output, and our existing function cannot consume those outputs. So we can use <em>contramap</em> to create a new function that can consume that fixed output. Assume we have a <code>ZSink.sum</code> that sums incoming numeric values, but we have a <code>ZStream</code> of <code>String</code> values. We can convert the <code>ZSink.sum</code> to a sink that can consume <code>String</code> values;</p><pre><code class="language-scala">val numericSum: ZSink[Any, Nothing, Int, Nothing, Int]    = 
  ZSink.sum[Int]
val stringSum : ZSink[Any, Nothing, String, Nothing, Int] = 
  numericSum.contramap((x: String) =&gt; x.toInt)

val sum: ZIO[Any, Nothing, Int] =
  ZStream(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;).run(stringSum)
// Output: 15
</code></pre><h3>dimap</h3><p>A <code>dimap</code> is an extended <code>contramap</code> that additionally transforms sink&#x27;s output:</p><pre><code class="language-scala">// Convert its input to integers, do the computation and then convert them back to a string
val sumSink: ZSink[Any, Nothing, String, Nothing, String] =
  numericSum.dimap[String, String](_.toInt, _.toString)
  
val sum: ZIO[Any, Nothing, String] =
  ZStream(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;).run(sumSink)
// Output: 15
</code></pre><h3>Filtering</h3><p>Sinks have <code>ZSink#filterInput</code> for filtering incoming elements:</p><pre><code class="language-scala">ZStream(1, -2, 0, 1, 3, -3, 4, 2, 0, 1, -3, 1, 1, 6)
  .transduce(
    ZSink
      .collectAllN[Int](3)
      .filterInput[Int](_ &gt; 0)
  )
// Output: Chunk(Chunk(1,1,3),Chunk(4,2,1),Chunk(1,1,6),Chunk())
</code></pre><h2>Concurrency and Parallelism</h2><h3>Parallel Zipping</h3><p>Like <code>ZStream</code>, two <code>ZSink</code> can be zipped together. Both of them will be run in parallel, and their results will be combined in a tuple:</p><pre><code class="language-scala">val kafkaSink: ZSink[Any, Throwable, Record, Record, Unit] =
  ZSink.foreach[Any, Throwable, Record](record =&gt; ZIO.attempt(???))

val pulsarSink: ZSink[Any, Throwable, Record, Record, Unit] =
  ZSink.foreach[Any, Throwable, Record](record =&gt; ZIO.attempt(???))

val stream: ZSink[Any, Throwable, Record, Record, Unit] =
  kafkaSink zipPar pulsarSink 
</code></pre><h3>Racing</h3><p>We are able to <code>race</code> multiple sinks, they will run in parallel, and the one that wins will provide the result of our program:</p><pre><code class="language-scala">val stream: ZSink[Any, Throwable, Record, Record, Unit] =
  kafkaSink race pulsarSink 
</code></pre><p>To determine which one succeeded, we should use the <code>ZSink#raceBoth</code> combinator, it returns an <code>Either</code> result.</p><h2>Leftovers</h2><h3>Exposing Leftovers</h3><p>A sink consumes a variable amount of <code>I</code> elements (zero or more) from the upstream. If the upstream is finite, we can expose leftover values by calling <code>ZSink#exposeLeftOver</code>. It returns a tuple that contains the result of the previous sink and its leftovers:</p><pre><code class="language-scala">val s1: ZIO[Any, Nothing, (Chunk[Int], Chunk[Int])] =
  ZStream(1, 2, 3, 4, 5).run(
    ZSink.take(3).exposeLeftover
  )
// Output: (Chunk(1, 2, 3), Chunk(4, 5))


val s2: ZIO[Any, Nothing, (Option[Int], Chunk[Int])] =
  ZStream(1, 2, 3, 4, 5).run(
    ZSink.head[Int].exposeLeftover
  )
// Output: (Some(1), Chunk(2, 3, 4, 5))
</code></pre><h3>Dropping Leftovers</h3><p>If we don&#x27;t need leftovers, we can drop them by using <code>ZSink#dropLeftover</code>:</p><pre><code class="language-scala">ZSink.take[Int](3).dropLeftover
</code></pre></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/2-0-0/datatypes/stream/zsink";window.___webpackCompilationHash="629750c28ce5e2d26819";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0704c8948e63b1196955.js"],"app":["/app-5bc2dca3fcd03febe812.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-d0913b8933fa48a45475.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/gatsby-theme-zio/polyfill-0704c8948e63b1196955.js" nomodule=""></script><script src="/gatsby-theme-zio/app-5bc2dca3fcd03febe812.js" async=""></script><script src="/gatsby-theme-zio/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/gatsby-theme-zio/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/gatsby-theme-zio/webpack-runtime-7117cab68cf800d067d6.js" async=""></script></body></html>