<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/gatsby-theme-zio/styles.0d77a1f9790ad3befaea.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><h2>How to test interactions between services?</h2><p>Whenever possible, we should strive to make our functions pure, which makes testing such function easy - you just need to assert on the return value.
However in larger applications there is a need for intermediate layers that delegate the work to specialized services.</p><p>For example, in a HTTP server the first layer of indirection are so called <em>routes</em>, whose job is to match the request and delegate the processing to
downstream layers. Often below there is a second layer of indirection, so called <em>controllers</em>, which consist of several business logic units grouped
by their domain. In a RESTful API that would be all operations on a certain model. The <em>controller</em> to perform its job might call on further
specialized services for communicating with the database, sending email, logging, et cetera.</p><p>If the job of the <em>capability</em> is to call on another <em>capability</em>, how should we test it?</p><h2>Hidden outputs</h2><p>A pure function is such a function which operates only on its inputs and produces only its output. Command-like methods, by definition are impure, as
their job is to change state of the collaborating object (performing a <em>side effect</em>). For example:</p><pre><code class="language-scala">import scala.concurrent.Future

def processEvent(event: Event): Future[Unit] = Future(println(s&quot;Got $event&quot;))
</code></pre><p>The signature of this method <code>Event =&gt; Future[Unit]</code> hints us we&#x27;re dealing with a command. It returns <code>Unit</code> (well, wrapped in future, but it does
not matter here), you can&#x27;t do anything useful with <code>Unit</code> and it does not contain any information. It is the equivalent of returning nothing. It is
also an unreliable return type, as when Scala expects the return type to be <code>Unit</code> it will discard whatever value it had (for details see
<a href="https://scala-lang.org/files/archive/spec/2.13/06-expressions.html#value-conversions">Section 6.26.1</a> of the Scala Language Specification), which may shadow the fact that the final value produced (and discarded) was
not the one you expected.</p><p>Inside the future there may be happening any side effects. It may open a file, print to console, connect to databases. We simply don&#x27;t know. Let&#x27;s have a look how this problem would be solved using ZIO&#x27;s effect system:</p><pre><code class="language-scala">import zio._
import zio.console.Console

def processEvent(event: Event): URIO[Console, Unit] =
  console.putStrLn(s&quot;Got $event&quot;).orDie
</code></pre><p>With ZIO, we&#x27;ve regained to ability to reason about the effects called. We know that <code>processEvent</code> can only call on <em>capabilities</em> of <code>Console</code>, so even though we still have <code>Unit</code> as the result, we have narrowed the possible effects space to a few.</p><blockquote><p><strong>Note:</strong> this is true assuming the programmer disciplines themselves to only perform effects expressed in the type signature.
There is no way (at the moment) to enforce this by the compiler. There is some research done in this space, perhaps future programming languages
will enable us to further constrain side effects.</p></blockquote><p>However, the same method could be implemented as:</p><pre><code class="language-scala">def processEvent2(event: Event): URIO[Console, Unit] =
  ZIO.unit
</code></pre><p>How can we test it did exactly what we expected it to do?</p><h2>Mocking</h2><p>In this sort of situations we need mock implementations of our collaborator service. As <em>Martin Fowler</em> puts it in his excellent article
<a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren&#x27;t Stubs</a>:</p><blockquote><p><strong>Mocks</strong> are (...) objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</p></blockquote><p>ZIO Test provides a framework for mocking your modules.</p><h2>Creating a mock service</h2><p>We&#x27;ll be assuming you&#x27;ve read about modules and layers in the <a href="../datatypes/contextual/index.md">contextual types</a> guide. In the main sources we define the <em>service</em>, a module alias and <em>capability accessors</em>. In test sources we&#x27;re defining the <em>mock object</em> which extends <code>zio.test.mock.Mock</code> which holds <em>capability tags</em> and <em>compose layer</em>.</p><pre><code class="language-scala">// main sources

import zio.stream.{ ZSink, ZStream }
import zio.test.mock._

type Example = Has[Example.Service]

object Example {
  trait Service {
    val static                                 : UIO[String]
    def zeroArgs                               : UIO[Int]
    def zeroArgsWithParens()                   : UIO[Long]
    def singleArg(arg1: Int)                   : UIO[String]
    def multiArgs(arg1: Int, arg2: Long)       : UIO[String]
    def multiParamLists(arg1: Int)(arg2: Long) : UIO[String]
    def command(arg1: Int)                     : UIO[Unit]
    def overloaded(arg1: Int)                  : UIO[String]
    def overloaded(arg1: Long)                 : UIO[String]
    def function(arg1: Int)                    : String
    def sink(a: Int)                           : ZSink[Any, String, Int, Int, List[Int]]
    def stream(a: Int)                         : ZStream[Any, String, Int]
  }
}
</code></pre><pre><code class="language-scala">// test sources

object ExampleMock extends Mock[Example] {
  object Static             extends Effect[Unit, Nothing, String]
  object ZeroArgs           extends Effect[Unit, Nothing, Int]
  object ZeroArgsWithParens extends Effect[Unit, Nothing, Long]
  object SingleArg          extends Effect[Int, Nothing, String]
  object MultiArgs          extends Effect[(Int, Long), Nothing, String]
  object MultiParamLists    extends Effect[(Int, Long), Nothing, String]
  object Command            extends Effect[Int, Nothing, Unit]
  object Overloaded {
    object _0 extends Effect[Int, Nothing, String]
    object _1 extends Effect[Long, Nothing, String]
  }
  object Function extends Method[Int, Throwable, String]
  object Sink     extends Sink[Any, String, Int, Int, List[Int]]
  object Stream   extends Stream[Any, String, Int]

  val compose: URLayer[Has[Proxy], Example] = ???
}
</code></pre><p>A <em>capability tag</em> is just a value which extends the <code>zio.test.mock.Capability[R &lt;: Has[_], I, E, A]</code> type constructor, where:</p><ul><li><code>R</code> is the type of environment the method belongs to</li><li><code>I</code> is the type of methods input arguments</li><li><code>E</code> is the type of error it can fail with</li><li><code>A</code> is the type of return value it can produce</li></ul><p>The <code>Capability</code> type is not publicly available, instead you have to extend <code>Mock</code> dependent types <code>Effect</code>, <code>Method</code>, <code>Sink</code> or <code>Stream</code>.</p><p>We model input arguments according to following scheme:</p><ul><li>for zero arguments the type is <code>Unit</code></li><li>for one or more arguments, regardless in how many parameter lists, the type is a <code>TupleN</code> where <code>N</code> is the size of arguments list</li></ul><blockquote><p><strong>Note:</strong> we&#x27;re using tuples to represent multiple argument methods, which follows with a limit to max 22 arguments, as is Scala itself limited.</p></blockquote><p>For overloaded methods we nest a list of numbered objects, each representing subsequent overloads.</p><p>Finally we need to define a <em>compose layer</em> that can create our environment from a <code>Proxy</code>.
A <code>Proxy</code> holds the mock state and serves predefined responses to calls.</p><pre><code class="language-scala">import ExampleMock._

val compose: URLayer[Has[Proxy], Example] =
  ZLayer.fromServiceM { proxy =&gt;
    withRuntime.map { rts =&gt;
      new Example.Service {
        val static                                 = proxy(Static)
        def zeroArgs                               = proxy(ZeroArgs)
        def zeroArgsWithParens()                   = proxy(ZeroArgsWithParens)
        def singleArg(arg1: Int)                   = proxy(SingleArg, arg1)
        def multiArgs(arg1: Int, arg2: Long)       = proxy(MultiArgs, arg1, arg2)
        def multiParamLists(arg1: Int)(arg2: Long) = proxy(MultiParamLists, arg1, arg2)
        def command(arg1: Int)                     = proxy(Command, arg1)
        def overloaded(arg1: Int)                  = proxy(Overloaded._0, arg1)
        def overloaded(arg1: Long)                 = proxy(Overloaded._1, arg1)
        def function(arg1: Int)                    = rts.unsafeRunTask(proxy(Function, arg1))
        def sink(a: Int)                           = rts.unsafeRun(proxy(Sink, a).catchAll(error =&gt; UIO(ZSink.fail[String, Int](error))))
        def stream(a: Int)                         = rts.unsafeRun(proxy(Stream, a))
      }
    }
  }
</code></pre><blockquote><p><strong>Note:</strong> The <code>withRuntime</code> helper is defined in <code>Mock</code>. It accesses the Runtime via <code>ZIO.runtime</code> and if you&#x27;re on JS platform, it will replace the executor to an unyielding one.</p></blockquote><p>A reference to this layer is passed to <em>capability tags</em> so it can be used to automatically build environment for composed expectations on
multiple services.</p><blockquote><p><strong>Note:</strong> for non-effectful capabilities you need to unsafely run the final effect to satisfy the required interface. For <code>ZSink</code> you also need to map the error into a failed sink as demonstrated above.</p></blockquote><h2>Complete example</h2><pre><code class="language-scala">// main sources

import zio._
import zio.console.Console
import zio.test.mock._

type AccountObserver = Has[AccountObserver.Service]

object AccountObserver {
  trait Service {
    def processEvent(event: AccountEvent): UIO[Unit]
    def runCommand(): UIO[Unit]
  }

  def processEvent(event: AccountEvent) =
    ZIO.accessM[AccountObserver](_.get.processEvent(event))

  def runCommand() =
    ZIO.accessM[AccountObserver](_.get.runCommand)

  val live: ZLayer[Console, Nothing, AccountObserver] =
    ZLayer.fromService[Console.Service, Service] { console =&gt;
      new Service {
        def processEvent(event: AccountEvent): UIO[Unit] =
          for {
            _    &lt;- console.putStrLn(s&quot;Got $event&quot;).orDie
            line &lt;- console.getStrLn.orDie
            _    &lt;- console.putStrLn(s&quot;You entered: $line&quot;).orDie
          } yield ()

        def runCommand(): UIO[Unit] =
          console.putStrLn(&quot;Done!&quot;).orDie
      }
    }
}
</code></pre><pre><code class="language-scala">// test sources

object AccountObserverMock extends Mock[AccountObserver] {

  object ProcessEvent extends Effect[AccountEvent, Nothing, Unit]
  object RunCommand   extends Effect[Unit, Nothing, Unit]

  val compose: URLayer[Has[Proxy], AccountObserver] =
    ZLayer.fromService { proxy =&gt;
      new AccountObserver.Service {
        def processEvent(event: AccountEvent) = proxy(ProcessEvent, event)
        def runCommand(): UIO[Unit]           = proxy(RunCommand)
      }
    }
}
</code></pre><blockquote><p><strong>Note:</strong> ZIO provides some useful macros to help you generate repetitive code, see <a href="howto-macros.md">Scrapping the boilerplate with macros</a>.</p></blockquote><h2>Provided ZIO services</h2><p>For each built-in ZIO service you will find their mockable counterparts in <code>zio.test.mock</code> package:</p><ul><li><code>MockClock</code> for <code>zio.clock.Clock</code></li><li><code>MockConsole</code> for <code>zio.console.Console</code></li><li><code>MockRandom</code> for <code>zio.random.Random</code></li><li><code>MockSystem</code> for <code>zio.system.System</code></li></ul><h2>Setting up expectations</h2><p>To create expectations we use the previously defined <em>capability tags</em>:</p><pre><code class="language-scala">import zio.test.Assertion._
import zio.test.mock.Expectation._
import zio.test.mock.MockSystem

val exp01 = ExampleMock.SingleArg( // capability to build an expectation for
  equalTo(42), // assertion of the expected input argument
  value(&quot;bar&quot;) // result, that will be returned
)
</code></pre><p>For methods that take input, the first argument will be an assertion on input, and the second the predefined result.</p><p>In the most robust example, the result can be either a successful value or a failure. To construct either we must use
one of following combinators from <code>zio.test.mock.Expectation</code> companion object:</p><ul><li><code>failure[E](failure: E)</code> Expectation result failing with <code>E</code></li><li><code>failureF[I, E](f: I =&gt; E)</code> Maps the input arguments <code>I</code> to expectation result failing with <code>E</code>.</li><li><code>failureM[I, E](f: I =&gt; IO[E, Nothing])</code> Effectfully maps the input arguments <code>I</code> to expectation result failing with <code>E</code>.</li><li><code>never</code> Expectation result computing forever.</li><li><code>unit</code> Expectation result succeeding with <code>Unit</code>.</li><li><code>value[A](value: A)</code> Expectation result succeeding with <code>A</code>.</li><li><code>valueF[I, A](f: I =&gt; A)</code> Maps the input arguments <code>I</code> to expectation result succeeding with <code>A</code>.</li><li><code>valueM[I, A](f: I =&gt; IO[Nothing, A])</code> Effectfully maps the input arguments <code>I</code> expectation result succeeding with <code>A</code>.</li></ul><p>For methods that take no input, we only define the expected output.</p><pre><code class="language-scala">val exp02 = ExampleMock.ZeroArgs(value(42))
</code></pre><p>For methods that may return <code>Unit</code>, we may skip the predefined result (it will default to successful value) or use <code>unit</code> helper.</p><pre><code class="language-scala">import zio.test.mock.MockConsole

val exp03 = MockConsole.PutStrLn(equalTo(&quot;Welcome to ZIO!&quot;))
val exp04 = MockConsole.PutStrLn(equalTo(&quot;Welcome to ZIO!&quot;), unit)
</code></pre><p>For methods that may return <code>Unit</code> and take no input we can skip both:</p><pre><code class="language-scala">val exp05 = AccountObserverMock.RunCommand()
</code></pre><p>Finally we&#x27;re all set and can create ad-hoc mock environments with our services.</p><pre><code class="language-scala">import zio.test._

val event = new AccountEvent {}
val app: URIO[AccountObserver, Unit] = AccountObserver.processEvent(event)
val mockEnv: ULayer[Console] = (
  MockConsole.PutStrLn(equalTo(s&quot;Got $event&quot;), unit) ++
  MockConsole.GetStrLn(value(&quot;42&quot;)) ++
  MockConsole.PutStrLn(equalTo(&quot;You entered: 42&quot;))
)
</code></pre><p>We can combine our expectation to build complex scenarios using combinators defined in <code>zio.test.mock.Expectation</code>:</p><ul><li><code>andThen</code> (alias <code>++</code>) Compose two expectations, producing a new expectation to <strong>satisfy both sequentially</strong>.</li><li><code>and</code> (alias <code>&amp;&amp;</code>) Compose two expectations, producing a new expectation to <strong>satisfy both in any order</strong>.</li><li><code>or</code> (alias <code>||</code>) Compose two expectations, producing a new expectation to <strong>satisfy only one of them</strong>.</li><li><code>repeated</code> Repeat expectation within given bounds, produces a new expectation to <strong>satisfy itself sequentially given number of times</strong>.</li><li><code>atLeast</code> Lower-bounded variant of <code>repeated</code>, produces a new expectation to satisfy <strong>itself sequentially at least given number of times</strong>.</li><li><code>atMost</code> Upper-bounded variant of <code>repeated</code>, produces a new expectation to satisfy <strong>itself sequentially at most given number of times</strong>.</li><li><code>optional</code> Alias for <code>atMost(1)</code>, produces a new expectation to satisfy <strong>itself at most once</strong>.</li></ul><h2>Providing mocked environment</h2><pre><code class="language-scala">object AccountObserverSpec extends DefaultRunnableSpec {
  def spec = suite(&quot;processEvent&quot;)(
    testM(&quot;calls putStrLn &gt; getStrLn &gt; putStrLn and returns unit&quot;) {
      val result = app.provideLayer(mockEnv &gt;&gt;&gt; AccountObserver.live)
      assertM(result)(isUnit)
    }
  )
}
</code></pre><h2>Mocking unused collaborators</h2><p>Often the dependency on a collaborator is only in some branches of the code. To test the correct behaviour of branches without depedencies, we still have to provide it to the environment, but we would like to assert it was never called. With the <code>Mock.empty</code> method you can obtain a <code>ZLayer</code> with an empty service (no calls expected).</p><pre><code class="language-scala">object MaybeConsoleSpec extends DefaultRunnableSpec {
  def spec = suite(&quot;processEvent&quot;)(
    testM(&quot;expect no call&quot;) {
      def maybeConsole(invokeConsole: Boolean) =
        ZIO.when(invokeConsole)(console.putStrLn(&quot;foo&quot;))

      val maybeTest1 = maybeConsole(false).provideLayer(MockConsole.empty)
      val maybeTest2 = maybeConsole(true).provideLayer(MockConsole.PutStrLn(equalTo(&quot;foo&quot;)))
      assertM(maybeTest1)(isUnit) *&gt; assertM(maybeTest2)(isUnit)
    }
  )
}
</code></pre><h2>Mocking multiple collaborators</h2><p>In some cases we have more than one collaborating service being called. You can create mocks for rich environments and as you enrich the environment by using <em>capability tags</em> from another service, the underlaying mocked layer will be updated.</p><pre><code class="language-scala">import zio.console.Console
import zio.random.Random
import zio.test.mock.MockRandom

val combinedEnv: ULayer[Console with Random] = (
  MockConsole.PutStrLn(equalTo(&quot;What is your name?&quot;)) ++
  MockConsole.GetStrLn(value(&quot;Mike&quot;)) ++
  MockRandom.NextInt(value(42)) ++
  MockConsole.PutStrLn(equalTo(&quot;Mike, your lucky number today is 42!&quot;))
)

val combinedApp =
  for {
    _    &lt;- console.putStrLn(&quot;What is your name?&quot;)
    name &lt;- console.getStrLn.orDie
    num  &lt;- random.nextInt
    _    &lt;- console.putStrLn(s&quot;$name, your lucky number today is $num!&quot;)
  } yield ()

val result = combinedApp.provideLayer(combinedEnv)
assertM(result)(isUnit)
</code></pre><h2>Polymorphic capabilities</h2><p>Mocking polymorphic methods is also supported, but the interface must require <code>zio.Tag</code> implicit evidence for each type parameter.</p><pre><code class="language-scala">// main sources
type PolyExample = Has[PolyExample.Service]

object PolyExample {
  trait Service {
    def polyInput[I: Tag](input: I): Task[String]
    def polyError[E: Tag](input: Int): IO[E, String]
    def polyOutput[A: Tag](input: Int): Task[A]
    def polyAll[I: Tag, E: Tag, A: Tag](input: I): IO[E, A]
  }
}
</code></pre><p>In the test sources we construct partially applied <em>capability tags</em> by extending <code>Method.Poly</code> family. The unknown types
must be provided at call site. To produce a final monomorphic <code>Method</code> tag we must use the <code>of</code> combinator and pass the
missing types.</p><pre><code class="language-scala">// test sources
object PolyExampleMock extends Mock[PolyExample] {

  object PolyInput  extends Poly.Effect.Input[Throwable, String]
  object PolyError  extends Poly.Effect.Error[Int, String]
  object PolyOutput extends Poly.Effect.Output[Int, Throwable]
  object PolyAll    extends Poly.Effect.InputErrorOutput

  val compose: URLayer[Has[Proxy], PolyExample] =
    ZLayer.fromServiceM { proxy =&gt;
      withRuntime.map { rts =&gt;
        new PolyExample.Service {
          def polyInput[I: Tag](input: I)                     = proxy(PolyInput.of[I], input)
          def polyError[E: Tag](input: Int)                   = proxy(PolyError.of[E], input)
          def polyOutput[A: Tag](input: Int)                  = proxy(PolyOutput.of[A], input)
          def polyAll[I: Tag, E: Tag, A: Tag](input: I) = proxy(PolyAll.of[I, E, A], input)
        }
      }
    }
}
</code></pre><p>Similarly, we use the same <code>of</code> combinator to refer to concrete monomorphic call in our test suite when building expectations:</p><pre><code class="language-scala">import PolyExampleMock._

val exp06 = PolyInput.of[String](equalTo(&quot;foo&quot;), value(&quot;bar&quot;))
val exp07 = PolyInput.of[Int](equalTo(42), failure(new Exception))
val exp08 = PolyInput.of[Long](equalTo(42L), value(&quot;baz&quot;))

val exp09 = PolyAll.of[Int, Throwable, String](equalTo(42), value(&quot;foo&quot;))
val exp10 = PolyAll.of[Int, Throwable, String](equalTo(42), failure(new Exception))
</code></pre><h2>More examples</h2><p>You can find more examples in the <code>examples</code> and <code>test-tests</code> subproject:</p><ul><li><a href="https://github.com/zio/zio/blob/master/examples/shared/src/test/scala/zio/examples/test/MockExampleSpec.scala">MockExampleSpec</a></li><li><a href="https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/EmptyMockSpec.scala">EmptyMockSpec</a></li><li><a href="https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/ComposedMockSpec.scala">ComposedMockSpec</a></li><li><a href="https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/ComposedEmptyMockSpec.scala">ComposedEmptyMockSpec</a></li><li><a href="https://github.com/zio/zio/blob/master/test-tests/shared/src/test/scala/zio/test/mock/PolyMockSpec.scala">PolyMockSpec</a></li></ul></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/1-0-0/guides/mock-services";window.___webpackCompilationHash="629750c28ce5e2d26819";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0704c8948e63b1196955.js"],"app":["/app-5bc2dca3fcd03febe812.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-d0913b8933fa48a45475.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/gatsby-theme-zio/polyfill-0704c8948e63b1196955.js" nomodule=""></script><script src="/gatsby-theme-zio/app-5bc2dca3fcd03febe812.js" async=""></script><script src="/gatsby-theme-zio/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/gatsby-theme-zio/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/gatsby-theme-zio/webpack-runtime-7117cab68cf800d067d6.js" async=""></script></body></html>