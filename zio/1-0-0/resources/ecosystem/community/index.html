<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.17.2"/><style data-href="/gatsby-theme-zio/styles.0d77a1f9790ad3befaea.css" data-identity="gatsby-global-css">/*
! tailwindcss v3.1.4 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{color:inherit;font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.invisible{visibility:hidden}.absolute{position:absolute}.relative{position:relative}.left-0{left:0}.top-1\/2{top:50%}.z-10{z-index:10}.m-4{margin:1rem}.m-auto{margin:auto}.my-2{margin-bottom:.5rem;margin-top:.5rem}.my-auto{margin-bottom:auto;margin-top:auto}.mx-auto{margin-left:auto;margin-right:auto}.mx-1{margin-right:.25rem}.ml-1,.mx-1{margin-left:.25rem}.mr-8{margin-right:2rem}.mt-4{margin-top:1rem}.mt-2{margin-top:.5rem}.ml-2{margin-left:.5rem}.mb-2{margin-bottom:.5rem}.ml-5{margin-left:1.25rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-8{height:2rem}.h-0{height:0}.h-40{height:10rem}.h-auto{height:auto}.w-full{width:100%}.w-auto{width:auto}.w-80{width:20rem}.w-8{width:2rem}.w-11\/12{width:91.666667%}.max-w-full{max-width:100%}.flex-initial{flex:0 1 auto}.flex-none{flex:none}.flex-grow{flex-grow:1}.list-outside{list-style-position:outside}.list-disc{list-style-type:disc}.list-decimal{list-style-type:decimal}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.place-content-center{place-content:center}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-sm{border-radius:.125rem}.border-2{border-width:2px}.border-r-2{border-right-width:2px}.border-solid{border-style:solid}.border-primary-50{--tw-border-opacity:1;border-color:rgb(250 250 249/var(--tw-border-opacity))}.bg-primary-700{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.bg-primary-900{--tw-bg-opacity:1;background-color:rgb(28 25 23/var(--tw-bg-opacity))}.bg-primary-100{--tw-bg-opacity:1;background-color:rgb(245 245 244/var(--tw-bg-opacity))}.bg-primary-300{--tw-bg-opacity:1;background-color:rgb(214 211 209/var(--tw-bg-opacity))}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0/var(--tw-bg-opacity))}.p-4{padding:1rem}.p-2{padding:.5rem}.p-8{padding:2rem}.px-1{padding-left:.25rem;padding-right:.25rem}.pb-4{padding-bottom:1rem}.pr-2{padding-right:.5rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.text-sm{font-size:.875rem;line-height:1.25rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-2xl{font-size:1.5rem;line-height:2rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-primary-50{--tw-text-opacity:1;color:rgb(250 250 249/var(--tw-text-opacity))}.text-secondary-600{--tw-text-opacity:1;color:rgb(220 38 38/var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.hover\:rounded-md:hover{border-radius:.375rem}.hover\:bg-primary-700:hover{--tw-bg-opacity:1;background-color:rgb(68 64 60/var(--tw-bg-opacity))}.hover\:bg-primary-600:hover{--tw-bg-opacity:1;background-color:rgb(87 83 78/var(--tw-bg-opacity))}@media (min-width:768px){.md\:visible{visibility:visible}.md\:h-auto{height:auto}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}}@media (min-width:1024px){.lg\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:#2f2f2f;color:#eee;font-family:Roboto Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#363636}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#363636}:not(pre)>code[class*=language-]{border-radius:.2em;padding:.1em;white-space:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1.25em 1em;position:relative}.language-css>code,.language-sass>code,.language-scss>code{color:#fd9170}[class*=language-] .namespace{opacity:.7}.token.atrule{color:#c792ea}.token.attr-name{color:#ffcb6b}.token.attr-value,.token.attribute{color:#a5e844}.token.boolean{color:#c792ea}.token.builtin{color:#ffcb6b}.token.cdata,.token.char{color:#80cbc4}.token.class{color:#ffcb6b}.token.class-name{color:#f2ff00}.token.comment{color:#616161}.token.constant{color:#c792ea}.token.deleted{color:#f66}.token.doctype{color:#616161}.token.entity{color:#f66}.token.function{color:#c792ea}.token.hexcode{color:#f2ff00}.token.id,.token.important{color:#c792ea;font-weight:700}.token.inserted{color:#80cbc4}.token.keyword{color:#c792ea}.token.number{color:#fd9170}.token.operator{color:#89ddff}.token.prolog{color:#616161}.token.property{color:#80cbc4}.token.pseudo-class,.token.pseudo-element{color:#a5e844}.token.punctuation{color:#89ddff}.token.regex{color:#f2ff00}.token.selector{color:#f66}.token.string{color:#a5e844}.token.symbol{color:#c792ea}.token.tag{color:#f66}.token.unit{color:#fd9170}.token.url,.token.variable{color:#f66}</style><title data-react-helmet="true"></title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="container mx-auto"><p>In this section we are going to introduce some of the most important libraries that have first-class ZIO support from the community.</p><p>If you know a useful library that has first-class ZIO support, please consider <a href="https://github.com/zio/zio/pulls">submitting a pull request</a> to add it to this list.</p><h2>Caliban</h2><p><a href="https://ghostdogpr.github.io/caliban/">Caliban</a> is a purely functional library for creating GraphQL servers and clients in Scala.</p><h3>Introduction</h3><p>Key features of Caliban</p><ul><li><strong>Purely Functional</strong> — All interfaces are pure and types are referentially transparent.</li><li><strong>Type Safety</strong> — Schemas are type safe and derived at compile time.</li><li><strong>Minimal Boilerplate</strong> — No need to manually define a schema for every type in your API.</li><li><strong>Excellent Interoperability</strong> — Out-of-the-box support for major HTTP server libraries, effect types, JSON libraries, and more.</li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban&quot; % &quot;1.1.0&quot;
</code></pre><p>Caliban also have lots of optional modules to inter-operate with other various libraries:</p><pre><code class="language-scala">libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-http4s&quot;     % &quot;1.1.0&quot; // routes for http4s
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-akka-http&quot;  % &quot;1.1.0&quot; // routes for akka-http
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-play&quot;       % &quot;1.1.0&quot; // routes for play
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-finch&quot;      % &quot;1.1.0&quot; // routes for finch
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-zio-http&quot;   % &quot;1.1.0&quot; // routes for zio-http
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-cats&quot;       % &quot;1.1.0&quot; // interop with cats effect
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-monix&quot;      % &quot;1.1.0&quot; // interop with monix
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-tapir&quot;      % &quot;1.1.0&quot; // interop with tapir
libraryDependencies += &quot;com.github.ghostdogpr&quot; %% &quot;caliban-federation&quot; % &quot;1.1.0&quot; // interop with apollo federation
</code></pre><h3>Example</h3><p>First, to define Caliban API, we should define data models using case classes and ADTs. Then the Caliban can derive the whole GraphQL schema from these data models:</p><pre><code class="language-scala" metastring="modc:silent:nest">import caliban.GraphQL.graphQL
import caliban.schema.Annotations.GQLDescription
import caliban.{RootResolver, ZHttpAdapter}
import zhttp.http._
import zhttp.service.Server
import zio.{ExitCode, ZEnv, ZIO}

import scala.language.postfixOps

sealed trait Role

object Role {
  case object SoftwareDeveloper       extends Role
  case object SiteReliabilityEngineer extends Role
  case object DevOps                  extends Role
}

case class Employee(
    name: String,
    role: Role
)

case class EmployeesArgs(role: Role)
case class EmployeeArgs(name: String)

case class Queries(
    @GQLDescription(&quot;Return all employees with specific role&quot;)
    employees: EmployeesArgs =&gt; List[Employee],
    @GQLDescription(&quot;Find an employee by its name&quot;)
    employee: EmployeeArgs =&gt; Option[Employee]
)
object CalibanExample extends zio.App {

  val employees = List(
    Employee(&quot;Alex&quot;, Role.DevOps),
    Employee(&quot;Maria&quot;, Role.SoftwareDeveloper),
    Employee(&quot;James&quot;, Role.SiteReliabilityEngineer),
    Employee(&quot;Peter&quot;, Role.SoftwareDeveloper),
    Employee(&quot;Julia&quot;, Role.SiteReliabilityEngineer),
    Employee(&quot;Roberta&quot;, Role.DevOps)
  )

  val myApp = for {
    interpreter &lt;- graphQL(
      RootResolver(
        Queries(
          args =&gt; employees.filter(e =&gt; args.role == e.role),
          args =&gt; employees.find(e =&gt; e.name == args.name)
        )
      )
    ).interpreter
    _ &lt;- Server
      .start(
        port = 8088,
        http = Http.route { case _ -&gt; Root / &quot;api&quot; / &quot;graphql&quot; =&gt;
          ZHttpAdapter.makeHttpService(interpreter)
        }
      )
      .forever
  } yield ()

  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =
    myApp.exitCode

}
</code></pre><p>Now let&#x27;s query all software developers using GraphQL query language:</p><pre><code class="language-graphql">query{
  employees(role: SoftwareDeveloper){
    name
    role
  }
}
</code></pre><p>Here is the <em>curl</em> request of this query:</p><pre><code class="language-bash">curl &#x27;http://localhost:8088/api/graphql&#x27; --data-binary &#x27;{&quot;query&quot;:&quot;query{\n employees(role: SoftwareDeveloper){\n name\n role\n}\n}&quot;}&#x27;
</code></pre><p>And the response:</p><pre><code class="language-json">{
  &quot;data&quot; : {
    &quot;employees&quot; : [
      {
        &quot;name&quot; : &quot;Maria&quot;,
        &quot;role&quot; : &quot;SoftwareDeveloper&quot;
      },
      {
        &quot;name&quot; : &quot;Peter&quot;,
        &quot;role&quot; : &quot;SoftwareDeveloper&quot;
      }
    ]
  }
}
</code></pre><h2>ZIO gRPC</h2><p><a href="https://scalapb.github.io/zio-grpc/">ZIO-gRPC</a> lets us write purely functional gRPC servers and clients.</p><h3>Introduction</h3><p>Key features of ZIO gRPC:</p><ul><li><strong>Functional and Type-safe</strong> — Use the power of Functional Programming and the Scala compiler to build robust, correct and fully featured gRPC servers.</li><li><strong>Support for Streaming</strong> — Use ZIO&#x27;s feature-rich <code>ZStream</code>s to create server-streaming, client-streaming, and bi-directionally streaming RPC endpoints.</li><li><strong>Highly Concurrent</strong> — Leverage the power of ZIO to build asynchronous clients and servers without deadlocks and race conditions.</li><li><strong>Resource Safety</strong> — Safely cancel an RPC call by interrupting the effect. Resources on the server will never leak!</li><li><strong>Scala.js Support</strong> — ZIO gRPC comes with Scala.js support, so we can send RPCs to our service from the browser.</li></ul><h3>Installation</h3><p>First of all we need to add following lines to the <code>project/plugins.sbt</code> file:</p><pre><code class="language-scala">addSbtPlugin(&quot;com.thesamet&quot; % &quot;sbt-protoc&quot; % &quot;1.0.2&quot;)

libraryDependencies +=
  &quot;com.thesamet.scalapb.zio-grpc&quot; %% &quot;zio-grpc-codegen&quot; % &quot;0.5.0&quot;
</code></pre><p>Then in order to use this library, we need should add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">PB.targets in Compile := Seq(
  scalapb.gen(grpc = true) -&gt; (sourceManaged in Compile).value / &quot;scalapb&quot;,
  scalapb.zio_grpc.ZioCodeGenerator -&gt; (sourceManaged in Compile).value / &quot;scalapb&quot;
)

libraryDependencies ++= Seq(
  &quot;io.grpc&quot; % &quot;grpc-netty&quot; % &quot;1.39.0&quot;,
  &quot;com.thesamet.scalapb&quot; %% &quot;scalapb-runtime-grpc&quot; % scalapb.compiler.Version.scalapbVersion
)
</code></pre><h3>Example</h3><p>In this section, we are going to implement a simple server and client for the following gRPC <em>proto</em> file:</p><pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;io.grpc.examples.helloworld&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;
option objc_class_prefix = &quot;HLW&quot;;

package helloworld;

// The greeting service definition.
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user&#x27;s name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
</code></pre><p>The hello world server would be like this:</p><pre><code class="language-scala">import io.grpc.ServerBuilder
import io.grpc.examples.helloworld.helloworld.ZioHelloworld.ZGreeter
import io.grpc.examples.helloworld.helloworld.{HelloReply, HelloRequest}
import io.grpc.protobuf.services.ProtoReflectionService
import scalapb.zio_grpc.{ServerLayer, ServiceList}
import zio.console.putStrLn
import zio.{ExitCode, URIO, ZEnv, ZIO}

object HelloWorldServer extends zio.App {

  val helloService: ZGreeter[ZEnv, Any] =
    (request: HelloRequest) =&gt;
      putStrLn(s&quot;Got request: $request&quot;) *&gt;
        ZIO.succeed(HelloReply(s&quot;Hello, ${request.name}&quot;))


  val myApp = for {
    _ &lt;- putStrLn(&quot;Server is running. Press Ctrl-C to stop.&quot;)
    _ &lt;- ServerLayer
      .fromServiceList(
        ServerBuilder
          .forPort(9000)
          .addService(ProtoReflectionService.newInstance()),
        ServiceList.add(helloService))
      .build.useForever
  } yield ()

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.exitCode
}
</code></pre><p>And this is an example of using its client:</p><pre><code class="language-scala">import io.grpc.ManagedChannelBuilder
import io.grpc.examples.helloworld.helloworld.HelloRequest
import io.grpc.examples.helloworld.helloworld.ZioHelloworld.GreeterClient
import scalapb.zio_grpc.ZManagedChannel
import zio.console._
import zio.{ExitCode, URIO}

object HelloWorldClient extends zio.App {
  def myApp =
    for {
      r &lt;- GreeterClient.sayHello(HelloRequest(&quot;World&quot;))
      _ &lt;- putStrLn(r.message)
    } yield ()

  val clientLayer =
    GreeterClient.live(
      ZManagedChannel(
        ManagedChannelBuilder.forAddress(&quot;localhost&quot;, 9000).usePlaintext()
      )
    )

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.provideCustomLayer(clientLayer).exitCode
}
</code></pre><h2>Distage</h2><p><a href="https://izumi.7mind.io/distage/">Distage</a> is a compile-time safe, transparent, and debuggable Dependency Injection framework for pure FP Scala.</p><h3>Introduction</h3><p>By using <em>Distage</em> we can auto-wire all components of our application.</p><ul><li>We don&#x27;t need to manually link components together</li><li>We don&#x27;t need to manually specify the order of allocation and allocation of dependencies. This will be derived automatically from the dependency order.</li><li>We can override any component within the dependency graph.</li><li>It helps us to create different configurations of our components for different use cases.</li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;io.7mind.izumi&quot; %% &quot;distage-core&quot; % &quot;1.0.8&quot;
</code></pre><h3>Example</h3><p>In this example we create a <code>RandomApp</code> comprising two <code>Random</code> and <code>Logger</code> services. By using <code>ModuleDef</code> we <em>bind</em> services to their implementations:</p><pre><code class="language-scala">import distage.{Activation, Injector, ModuleDef, Roots}
import izumi.distage.model.Locator
import izumi.distage.model.definition.Lifecycle
import zio.{ExitCode, Task, UIO, URIO, ZIO}

import java.time.LocalDateTime

trait Random {
  def nextInteger: UIO[Int]
}

final class ScalaRandom extends Random {
  override def nextInteger: UIO[Int] =
    ZIO.effectTotal(scala.util.Random.nextInt())
}

trait Logger {
  def log(name: String): Task[Unit]
}

final class ConsoleLogger extends Logger {
  override def log(line: String): Task[Unit] = {
    val timeStamp = LocalDateTime.now()
    ZIO.effect(println(s&quot;$timeStamp: $line&quot;))
  }
}

final class RandomApp(random: Random, logger: Logger) {
  def run: Task[Unit] = for {
    random &lt;- random.nextInteger
    _ &lt;- logger.log(s&quot;random number generated: $random&quot;)
  } yield ()
}

object DistageExample extends zio.App {
  def RandomAppModule: ModuleDef = new ModuleDef {
    make[Random].from[ScalaRandom]
    make[Logger].from[ConsoleLogger]
    make[RandomApp] // `.from` is not required for concrete classes
  }
  
  val resource: Lifecycle[Task, Locator] = Injector[Task]().produce(
    plan = Injector[Task]().plan(
      bindings = RandomAppModule,
      activation = Activation.empty,
      roots = Roots.target[RandomApp]
    )
  )

  val myApp: Task[Unit] = resource.use(locator =&gt; locator.get[RandomApp].run)

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.exitCode
}
</code></pre><h2>LogStage</h2><p><a href="https://izumi.7mind.io/logstage/">LogStage</a> is a zero-cost structural logging framework for Scala &amp; Scala.js.</p><h3>Introduction</h3><p>Some key features of <em>LogStage</em>:</p><ol><li>LogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code.</li><li>LogStage uses macros to extract log structure, it is faster at runtime than a typical reflective structural logging frameworks</li><li>Log contexts</li><li>Console, File, and SLF4J sinks included, File sink supports log rotation,</li><li>Human-readable output and JSON output included,</li><li>Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently,</li><li>Slf4J adapters: route legacy Slf4J logs into LogStage router</li></ol><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">// LogStage core library
libraryDependencies += &quot;io.7mind.izumi&quot; %% &quot;logstage-core&quot; % &quot;1.0.8&quot;
</code></pre><p>There are also some optional modules:</p><pre><code class="language-scala">libraryDependencies ++= Seq(
  // Json output
  &quot;io.7mind.izumi&quot; %% &quot;logstage-rendering-circe&quot; % &quot;1.0.8&quot;,
  // Router from Slf4j to LogStage
  &quot;io.7mind.izumi&quot; %% &quot;logstage-adapter-slf4j&quot; % &quot;1.0.8&quot;,
  // LogStage integration with DIStage
  &quot;io.7mind.izumi&quot; %% &quot;distage-extension-logstage&quot; % &quot;1.0.8&quot;,
  // Router from LogStage to Slf4J
  &quot;io.7mind.izumi&quot; %% &quot;logstage-sink-slf4j &quot; % &quot;1.0.8&quot;,
)
</code></pre><h3>Example</h3><p>Let&#x27;s try a simple example of using <em>LogStage</em>:</p><pre><code class="language-scala">import izumi.fundamentals.platform.uuid.UUIDGen
import logstage.LogZIO.log
import logstage.{IzLogger, LogIO2, LogZIO}
import zio.{Has, URIO, _}

object LogStageExample extends zio.App {
  val myApp = for {
    _ &lt;- log.info(&quot;I&#x27;m logging with logstage!&quot;)
    userId = UUIDGen.getTimeUUID()
    _ &lt;- log.info(s&quot;Current $userId&quot;)
    _ &lt;- log.info(&quot;I&#x27;m logging within the same fiber!&quot;)
    f &lt;- log.info(&quot;I&#x27;m logging within a new fiber!&quot;).fork
    _ &lt;- f.join
  } yield ()

  val loggerLayer: ULayer[Has[LogIO2[IO]]] =
    ZLayer.succeed(LogZIO.withFiberId(IzLogger()))

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.provideLayer(loggerLayer).exitCode
}
</code></pre><p>The output of this program would be something like this:</p><pre><code>I 2021-07-26T21:27:35.164 (LogStageExample.scala:8)  …mpty&gt;.LogStageExample.myApp [14:zio-default-async-1] fiberId=Id(1627318654646,1) I&#x27;m logging with logstage!
I 2021-07-26T21:27:35.252 (LogStageExample.scala:10)  &lt;.LogStageExample.myApp.8 [14:zio-default-async-1] fiberId=Id(1627318654646,1) Current userId=93546810-ee32-11eb-a393-11bc5b145beb
I 2021-07-26T21:27:35.266 (LogStageExample.scala:11)  &lt;.L.myApp.8.10 [14:zio-default-async-1] fiberId=Id(1627318654646,1) I&#x27;m logging within the same fiber!
I 2021-07-26T21:27:35.270 (LogStageExample.scala:12)  &lt;.L.m.8.10.11 [16:zio-default-async-2] fiberId=Id(1627318655269,2) I&#x27;m logging within a new fiber!
</code></pre><h2>MUnit ZIO</h2><p><a href="https://github.com/poslegm/munit-zio">MUnit ZIO</a> is an integration library between MUnit and ZIO.</p><h3>Introduction</h3><p><a href="https://scalameta.org/munit/">MUnit</a> is a Scala testing library that is implemented as a JUnit runner. It has <em>actionable errors</em>, so the test reports are colorfully pretty-printed, stack traces are highlighted, error messages are pointed to the source code location where the failure happened.</p><p>The MUnit ZIO enables us to write tests that return <code>ZIO</code> values without needing to call any unsafe methods (e.g. <code>Runtime#unsafeRun</code>).</p><h3>Installation</h3><p>In order to use this library, we need to add the following lines in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;org.scalameta&quot; %% &quot;munit&quot; % &quot;0.7.27&quot; % Test
libraryDependencies += &quot;com.github.poslegm&quot; %% &quot;munit-zio&quot; % &quot;0.0.2&quot; % Test
</code></pre><p>If we are using a version of sbt lower than 1.5.0, we will also need to add:</p><pre><code class="language-scala">testFrameworks += new TestFramework(&quot;munit.Framework&quot;)
</code></pre><h3>Example</h3><p>Here is a simple MUnit spec that is integrated with the <code>ZIO</code> effect:</p><pre><code class="language-scala">import munit._
import zio._

class SimpleZIOSpec extends ZSuite {
  testZ(&quot;1 + 1 = 2&quot;) {
    for {
      a &lt;- ZIO(1)
      b &lt;- ZIO(1)
    }
    yield assertEquals(a + b, 2)
  }
}
</code></pre><h2>Rezilience</h2><p><a href="https://github.com/svroonland/rezilience">Rezilience</a> is a ZIO-native library for making resilient distributed systems.</p><h3>Introduction</h3><p>Rezilience is a ZIO-native fault tolerance library with a collection of policies for making asynchronous systems more resilient to failures inspired by Polly, Resilience4J, and Akka. It does not have external library dependencies other than ZIO.</p><p>It comprises these policies:</p><ul><li><strong>CircuitBreaker</strong> — Temporarily prevent trying calls after too many failures</li><li><strong>RateLimiter</strong> — Limit the rate of calls to a system</li><li><strong>Bulkhead</strong> — Limit the number of in-flight calls to a system</li><li><strong>Retry</strong> — Try again after transient failures</li><li><strong>Timeout</strong> — Interrupt execution if a call does not complete in time</li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;nl.vroste&quot; %% &quot;rezilience&quot; % &quot;0.7.0&quot;
</code></pre><h3>Example</h3><p>Let&#x27;s try an example of writing <em>Circuit Breaker</em> policy for calling an external API:</p><pre><code class="language-scala">import nl.vroste.rezilience.CircuitBreaker.{CircuitBreakerCallError, State}
import nl.vroste.rezilience._
import zio._
import zio.clock.Clock
import zio.console.{Console, putStrLn}
import zio.duration._

object CircuitBreakerExample extends zio.App {

  def callExternalSystem: ZIO[Console, String, Nothing] =
    putStrLn(&quot;External service called, but failed!&quot;).orDie *&gt;
      ZIO.fail(&quot;External service failed!&quot;)

  val myApp: ZIO[Console with Clock, Nothing, Unit] =
    CircuitBreaker.withMaxFailures(
      maxFailures = 10,
      resetPolicy = Schedule.exponential(1.second),
      onStateChange = (state: State) =&gt;
        ZIO(println(s&quot;State changed to $state&quot;)).orDie
    ).use { cb =&gt;
      for {
        _ &lt;- ZIO.foreach_(1 to 10)(_ =&gt; cb(callExternalSystem).either)
        _ &lt;- cb(callExternalSystem).catchAll(errorHandler)
        _ &lt;- ZIO.sleep(2.seconds)
        _ &lt;- cb(callExternalSystem).catchAll(errorHandler)
      } yield ()
    }

  def errorHandler: CircuitBreakerCallError[String] =&gt; URIO[Console, Unit] = {
    case CircuitBreaker.CircuitBreakerOpen =&gt;
      putStrLn(&quot;Circuit breaker blocked the call to our external system&quot;).orDie
    case CircuitBreaker.WrappedError(error) =&gt;
      putStrLn(s&quot;External system threw an exception: $error&quot;).orDie
  }
  
  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.exitCode
}
</code></pre><h2>Tamer</h2><p><a href="https://github.com/laserdisc-io/tamer">Tamer</a> is a multi-functional Kafka connector for producing data based on <a href="https://github.com/zio/zio-kafka">ZIO Kafka</a>.</p><h3>Introduction</h3><p>Tamer is a completely customizable source connector that produces to Kafka. It ships with preconfigured modules for SQL, cloud storage and REST API, but you can provide your own functions and Tamer will take care of the rest.</p><h3>Installation</h3><p>Depending on the source you have at hand you can add the correct dependency in your <code>build.sbt</code>:</p><pre><code class="language-scala">libraryDependencies += &quot;io.laserdisc&quot; %% &quot;tamer-db&quot;                % &quot;0.16.1&quot;
libraryDependencies += &quot;io.laserdisc&quot; %% &quot;tamer-oci-objectstorage&quot; % &quot;0.16.1&quot;
libraryDependencies += &quot;io.laserdisc&quot; %% &quot;tamer-rest&quot;              % &quot;0.16.1&quot;
libraryDependencies += &quot;io.laserdisc&quot; %% &quot;tamer-s3&quot;                % &quot;0.16.1&quot;
</code></pre><h3>Example</h3><p>Let&#x27;s say you have a inventory DB that&#x27;s compatible with <a href="https://github.com/tpolecat/doobie">Doobie</a>, you can get all of your items with just a few lines of code:</p><pre><code class="language-scala">import tamer._
import tamer.db._

import doobie.implicits.legacy.instant._
import doobie.syntax.string._
import zio._
import zio.duration._
import zio.json._

import java.time.Instant

case class Row(id: String, name: String, description: Option[String], modifiedAt: Instant)
    extends tamer.db.Timestamped(modifiedAt)

object Row {
  implicit val rowJsonCodec = DeriveJsonCodec.gen[Row]
}

object DatabaseSimple extends zio.App {
  // Here we&#x27;ll go with zio-json codec, you can use avro, circe and jsoniter
  // out-of-the box or plug yours!
  implicit val stateKeyJsonCodec = DeriveJsonCodec.gen[tamer.Tamer.StateKey]
  implicit val windowJsonCodec = DeriveJsonCodec.gen[tamer.db.Window]

  val program: RIO[ZEnv, Unit] = tamer.db.DbSetup
    .tumbling(window =&gt;
      sql&quot;&quot;&quot;SELECT id, name, description, modified_at 
           |FROM users 
           |WHERE modified_at &gt; ${window.from} AND modified_at &lt;= ${window.to}&quot;&quot;&quot;.stripMargin
        .query[Row]
    )(
      recordKey = (_, v) =&gt; v.id,
      from = Instant.parse(&quot;2020-01-01T00:00:00.00Z&quot;),
      tumblingStep = 5.days
    )
    .runWith(dbLayerFromEnvironment ++ tamer.kafkaConfigFromEnvironment)

  override final def run(args: List[String]): URIO[ZEnv, ExitCode] =
    program.exitCode

  // If you have other codecs like circe in the classpath you have to disambiguate
  implicit lazy val stateKeyCodec: Codec[Tamer.StateKey] = Codec.optionalZioJsonCodec
  implicit lazy val windowCodec: Codec[tamer.db.Window] = Codec.optionalZioJsonCodec
  implicit lazy val stringCodec: Codec[String] = Codec.optionalZioJsonCodec
}
</code></pre><p>See full example <a href="https://github.com/laserdisc-io/tamer/blob/4e1a7646fb44041648d9aa3ba089decb81ebe487/example/src/main/scala/tamer/db/DatabaseSimple.scala">on the GitHub repo</a></p><h2>TranzactIO</h2><p><a href="https://github.com/gaelrenoux/tranzactio">TranzactIO</a> is a ZIO wrapper for some Scala database access libraries, currently for <a href="https://github.com/tpolecat/doobie">Doobie</a> and <a href="https://github.com/playframework/anorm">Anorm</a>.</p><h3>Introduction</h3><p>Using functional effect database access libraries like <em>Doobie</em> enforces us to use their specialized monads like <code>ConnectionIO</code> for <em>Doobie</em>. The goal of <em>TranzactIO</em> is to provide seamless integration with these libraries to help us to stay in the <code>ZIO</code> world.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;io.github.gaelrenoux&quot; %% &quot;tranzactio&quot; % &quot;2.1.0&quot;
</code></pre><p>In addition, we need to declare the database access library we are using. For example, for the next example we need to add following dependencies for <em>Doobie</em> integration:</p><pre><code class="language-scala">libraryDependencies += &quot;org.tpolecat&quot; %% &quot;doobie-core&quot; % &quot;0.13.4&quot;
libraryDependencies += &quot;org.tpolecat&quot; %% &quot;doobie-h2&quot;   % &quot;0.13.4&quot;
</code></pre><h3>Example</h3><p>Let&#x27;s try an example of simple <em>Doobie</em> program:</p><pre><code class="language-scala">import doobie.implicits._
import io.github.gaelrenoux.tranzactio.doobie
import io.github.gaelrenoux.tranzactio.doobie.{Connection, Database, TranzactIO, tzio}
import org.h2.jdbcx.JdbcDataSource
import zio.blocking.Blocking
import zio.clock.Clock
import zio.console.{Console, putStrLn}
import zio.{ExitCode, Has, URIO, ZIO, ZLayer, blocking}

import javax.sql.DataSource

object TranzactIOExample extends zio.App {

  val query: ZIO[Connection with Console, Throwable, Unit] = for {
    _ &lt;- PersonQuery.setup
    _ &lt;- PersonQuery.insert(Person(&quot;William&quot;, &quot;Stewart&quot;))
    _ &lt;- PersonQuery.insert(Person(&quot;Michelle&quot;, &quot;Streeter&quot;))
    _ &lt;- PersonQuery.insert(Person(&quot;Johnathon&quot;, &quot;Martinez&quot;))
    users &lt;- PersonQuery.list
    _ &lt;- putStrLn(users.toString)
  } yield ()

  val myApp: ZIO[zio.ZEnv, Throwable, Unit] =
    Database.transactionOrWidenR(query).provideCustomLayer(services.database)

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.exitCode
}

case class Person(firstName: String, lastName: String)

object PersonQuery {
  def list: TranzactIO[List[Person]] = tzio {
    sql&quot;&quot;&quot;SELECT first_name, last_name FROM person&quot;&quot;&quot;.query[Person].to[List]
  }

  def setup: TranzactIO[Unit] = tzio {
    sql&quot;&quot;&quot;
        CREATE TABLE person (
          first_name VARCHAR NOT NULL,
          last_name VARCHAR NOT NULL
        )
        &quot;&quot;&quot;.update.run.map(_ =&gt; ())
  }

  def insert(p: Person): TranzactIO[Unit] = tzio {
    sql&quot;&quot;&quot;INSERT INTO person (first_name, last_name) VALUES (${p.firstName}, ${p.lastName})&quot;&quot;&quot;.update.run
      .map(_ =&gt; ())
  }
}

object services {
  val datasource: ZLayer[Blocking, Throwable, Has[DataSource]] =
    ZLayer.fromEffect(
      blocking.effectBlocking {
        val ds = new JdbcDataSource
        ds.setURL(s&quot;jdbc:h2:mem:mydb;DB_CLOSE_DELAY=10&quot;)
        ds.setUser(&quot;sa&quot;)
        ds.setPassword(&quot;sa&quot;)
        ds
      }
    )

  val database: ZLayer[Any, Throwable, doobie.Database.Database] =
    (Blocking.live &gt;&gt;&gt; datasource ++ Blocking.live ++ Clock.live) &gt;&gt;&gt; Database.fromDatasource
}
</code></pre><h2>ZIO Arrow</h2><p><a href="https://github.com/zio-mesh/zio-arrow/">ZIO Arrow</a> provides the <code>ZArrow</code> effect, which is a high-performance composition effect for the ZIO ecosystem.</p><h3>Introduction</h3><p><code>ZArrow[E, A, B]</code> is an effect representing a computation parametrized over the input (<code>A</code>), and the output (<code>B</code>) that may fail with an <code>E</code>. Arrows focus on <strong>composition</strong> and <strong>high-performance computation</strong>. They are like simple functions, but they are lifted into the <code>ZArrow</code> context.</p><p><code>ZArrow</code> delivers three main capabilities:</p><ul><li><p><strong> High-Performance</strong> — <code>ZArrow</code> exploits <code>JVM</code> internals to dramatically decrease the number of allocations and dispatches, yielding an unprecedented runtime performance.</p></li><li><p><strong>Abstract interface</strong> — <code>Arrow</code> is a more abstract data type, than ZIO Monad. It&#x27;s more abstract than ZIO Streams. In a nutshell, <code>ZArrow</code> allows a function-like interface that can have both different inputs and different outputs.</p></li><li><p><strong>Easy Integration</strong> — <code>ZArrow</code> can both input and output <code>ZIO Monad</code> and <code>ZIO Stream</code>, simplifying application development with different ZIO Effect types.</p></li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;io.github.neurodyne&quot; %% &quot;zio-arrow&quot; % &quot;0.2.1&quot;
</code></pre><h3>Example</h3><p>In this example we are going to write a repetitive task of reading a number from standard input and then power by 2 and then print the result:</p><pre><code class="language-scala">import zio.arrow.ZArrow
import zio.arrow.ZArrow._
import zio.console._
import zio.{ExitCode, URIO}

import java.io.IOException

object ArrowExample extends zio.App {

  val isPositive : ZArrow[Nothing, Int, Boolean]     = ZArrow((_: Int) &gt; 0)
  val toStr      : ZArrow[Nothing, Any, String]      = ZArrow((i: Any) =&gt; i.toString)
  val toInt      : ZArrow[Nothing, String, Int]      = ZArrow((i: String) =&gt; i.toInt)
  val getLine    : ZArrow[IOException, Any, String]  = ZArrow.liftM((_: Any) =&gt; getStrLn.provideLayer(Console.live))
  val printStr   : ZArrow[IOException, String, Unit] = ZArrow.liftM((line: String) =&gt; putStr(line).provideLayer(Console.live))
  val printLine  : ZArrow[IOException, String, Unit] = ZArrow.liftM((line: String) =&gt; putStrLn(line).provideLayer(Console.live))
  val power2     : ZArrow[Nothing, Int, Double]      = ZArrow((i: Int) =&gt; Math.pow(i, 2))
  val enterNumber: ZArrow[Nothing, Unit, String]     = ZArrow((_: Unit) =&gt; &quot;Enter positive number (-1 to exit): &quot;)
  val goodbye    : ZArrow[Nothing, Any, String]      = ZArrow((_: Any) =&gt; &quot;Goodbye!&quot;)

  val app: ZArrow[IOException, Unit, Boolean] =
    enterNumber &gt;&gt;&gt; printStr &gt;&gt;&gt; getLine &gt;&gt;&gt; toInt &gt;&gt;&gt;
      ifThenElse(isPositive)(
        power2 &gt;&gt;&gt; toStr &gt;&gt;&gt; printLine &gt;&gt;&gt; ZArrow((_: Any) =&gt; true)
      )(
        ZArrow((_: Any) =&gt; false)
      )

  val myApp = whileDo(app)(ZArrow(_ =&gt; ())) &gt;&gt;&gt; goodbye &gt;&gt;&gt; printLine

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.run(()).exitCode
}
</code></pre><p>Let&#x27;s see an example of running this program:</p><pre><code>Enter positive number (-1 to exit): 25
625.0
Enter positive number (-1 to exit): 8
64.0
Enter positive number (-1 to exit): -1
Goodbye!
</code></pre><h2>ZIO AMQP</h2><p><a href="https://github.com/svroonland/zio-amqp">ZIO AMQP</a> is a ZIO-based AMQP client for Scala.</p><h3>Introduction</h3><p>ZIO AMQP is a ZIO-based wrapper around the RabbitMQ client. It provides a streaming interface to AMQP queues and helps to prevent us from shooting ourselves in the foot with thread-safety issues.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;nl.vroste&quot; %% &quot;zio-amqp&quot; % &quot;0.2.0&quot;
</code></pre><h3>Example</h3><p>First, let&#x27;s create an instance of RabbitMQ:</p><pre><code>docker run -d --name some-rabbit -p 5672:5672 -p 5673:5673 -p 15672:15672 rabbitmq:3-management
</code></pre><p>Then we need to create <code>my_exchange</code> and <code>my_queue</code> and bind the queue to the exchange via the RabbitMQ management dashboard (<code>localhost:15672</code>).</p><p>Now we can run the example below:</p><pre><code class="language-scala">import nl.vroste.zio.amqp._
import zio._
import zio.blocking._
import zio.clock.Clock
import zio.console._
import zio.duration.durationInt
import zio.random.Random

import java.net.URI

object ZIOAMQPExample extends zio.App {

  val channelM: ZManaged[Blocking, Throwable, Channel] = for {
    connection &lt;- Amqp.connect(URI.create(&quot;amqp://localhost:5672&quot;))
    channel &lt;- Amqp.createChannel(connection)
  } yield channel

  val myApp: ZIO[Blocking with Console with Clock with Random, Throwable, Unit] =
    channelM.use { channel =&gt;
      val producer: ZIO[Blocking with Random with Clock, Throwable, Long] =
        zio.random.nextUUID
          .flatMap(uuid =&gt;
            channel.publish(&quot;my_exchange&quot;, uuid.toString.getBytes)
              .map(_ =&gt; ())
          ).schedule(Schedule.spaced(1.seconds))

      val consumer: ZIO[Blocking with Console, Throwable, Unit] = channel
        .consume(queue = &quot;my_queue&quot;, consumerTag = &quot;my_consumer&quot;)
        .mapM { record =&gt;
          val deliveryTag = record.getEnvelope.getDeliveryTag
          putStrLn(s&quot;Received $deliveryTag: ${new String(record.getBody)}&quot;) *&gt;
            channel.ack(deliveryTag)
        }
        .runDrain

      for {
        p &lt;- producer.fork
        c &lt;- consumer.fork
        _ &lt;- p.zip(c).join
      } yield ()
    }

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.exitCode
}
</code></pre><h2>ZIO AWS</h2><p><a href="https://github.com/vigoo/zio-aws">ZIO AWS</a> is a low-level AWS wrapper for ZIO for all the AWS services using the AWS Java SDK v2.</p><h3>Introduction</h3><p>The goal is to have access to all AWS functionality for cases when only simple, direct access is needed from a ZIO application, or to be used as a building block for higher-level wrappers around specific services.</p><p>Key features of ZIO AWS:</p><ul><li>Common configuration layer</li><li>ZIO module layer per AWS service</li><li>Wrapper for all operations on all services</li><li>HTTP service implementations for functional Scala HTTP libraries, injected through ZIO’s module system</li><li>ZStream wrapper around paginated operations</li><li>Service-specific extra configuration</li><li>More idiomatic Scala request and response types wrapping the Java classes</li></ul><h3>Installation</h3><p>There are tones of artifacts <a href="https://vigoo.github.io/zio-aws/docs/artifacts.html">published</a> for each AWS service. We can pick whichever services we need.</p><h3>Example</h3><p>The following example uses the <em>ElasticBeanstalk</em> and <em>EC2</em> APIs:</p><pre><code class="language-scala">libraryDependencies += &quot;io.github.vigoo&quot; %% &quot;zio-aws-core&quot;             % &quot;3.17.8.4&quot;,
libraryDependencies += &quot;io.github.vigoo&quot; %% &quot;zio-aws-ec2&quot;              % &quot;3.17.8.4&quot;,
libraryDependencies += &quot;io.github.vigoo&quot; %% &quot;zio-aws-elasticbeanstalk&quot; % &quot;3.17.8.4&quot;,
libraryDependencies += &quot;io.github.vigoo&quot; %% &quot;zio-aws-netty&quot;            % &quot;3.17.8.4&quot;
</code></pre><p>And here is the example code:</p><pre><code class="language-scala">import io.github.vigoo.zioaws.core.AwsError
import io.github.vigoo.zioaws.ec2.Ec2
import io.github.vigoo.zioaws.ec2.model._
import io.github.vigoo.zioaws.elasticbeanstalk.ElasticBeanstalk
import io.github.vigoo.zioaws.elasticbeanstalk.model._
import io.github.vigoo.zioaws.{core, ec2, elasticbeanstalk, netty}
import zio.console._
import zio.stream._
import zio.{console, _}

object ZIOAWSExample extends zio.App {
  val program: ZIO[Console with Ec2 with ElasticBeanstalk, AwsError, Unit] =
    for {
      appsResult &lt;- elasticbeanstalk.describeApplications(
        DescribeApplicationsRequest(applicationNames = Some(List(&quot;my-service&quot;)))
      )
      app &lt;- appsResult.applications.map(_.headOption)
      _ &lt;- app match {
        case Some(appDescription) =&gt;
          for {
            applicationName &lt;- appDescription.applicationName
            _ &lt;- console.putStrLn(
              s&quot;Got application description for $applicationName&quot;
            ).ignore

            envStream = elasticbeanstalk.describeEnvironments(
              DescribeEnvironmentsRequest(applicationName =
                Some(applicationName)
              )
            )

            _ &lt;- envStream.run(Sink.foreach { env =&gt;
              env.environmentName.flatMap { environmentName =&gt;
                (for {
                  environmentId &lt;- env.environmentId
                  _ &lt;- console.putStrLn(
                    s&quot;Getting the EB resources of $environmentName&quot;
                  ).ignore

                  resourcesResult &lt;-
                    elasticbeanstalk.describeEnvironmentResources(
                      DescribeEnvironmentResourcesRequest(environmentId =
                        Some(environmentId)
                      )
                    )
                  resources &lt;- resourcesResult.environmentResources
                  _ &lt;- console.putStrLn(
                    s&quot;Getting the EC2 instances in $environmentName&quot;
                  ).ignore
                  instances &lt;- resources.instances
                  instanceIds &lt;- ZIO.foreach(instances)(_.id)
                  _ &lt;- console.putStrLn(
                    s&quot;Instance IDs are ${instanceIds.mkString(&quot;, &quot;)}&quot;
                  ).ignore

                  reservationsStream = ec2.describeInstances(
                    DescribeInstancesRequest(instanceIds = Some(instanceIds))
                  )
                  _ &lt;- reservationsStream.run(Sink.foreach { reservation =&gt;
                    reservation.instances
                      .flatMap { instances =&gt;
                        ZIO.foreach(instances) { instance =&gt;
                          for {
                            id &lt;- instance.instanceId
                            typ &lt;- instance.instanceType
                            launchTime &lt;- instance.launchTime
                            _ &lt;- console.putStrLn(s&quot;  instance $id:&quot;).ignore
                            _ &lt;- console.putStrLn(s&quot;    type: $typ&quot;).ignore
                            _ &lt;- console.putStrLn(
                              s&quot;    launched at: $launchTime&quot;
                            ).ignore
                          } yield ()
                        }
                      }
                  })
                } yield ()).catchAll { error =&gt;
                  console.putStrLnErr(
                    s&quot;Failed to get info for $environmentName: $error&quot;
                  ).ignore
                }
              }
            })
          } yield ()
        case None =&gt;
          ZIO.unit
      }
    } yield ()

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = { //
    val httpClient = netty.default
    val awsConfig  = httpClient &gt;&gt;&gt; core.config.default
    val aws        = awsConfig &gt;&gt;&gt; (ec2.live ++ elasticbeanstalk.live)

    program
      .provideCustomLayer(aws)
      .either
      .flatMap {
        case Left(error) =&gt;
          console.putStrErr(s&quot;AWS error: $error&quot;).ignore.as(ExitCode.failure)
        case Right(_) =&gt;
          ZIO.unit.as(ExitCode.success)
      }
  }
}
</code></pre><h2>ZIO AWS S3</h2><p><a href="https://github.com/zio-mesh/zio-aws-s3">ZIO AWS S3</a> is a ZIO integration with AWS S3 SDK.</p><h3>Introduction</h3><p>This project aims to ease ZIO integration with AWS S3, providing a clean, simple and efficient API.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;io.github.neurodyne&quot; %% &quot;zio-aws-s3&quot; % &quot;0.4.13&quot;
</code></pre><h3>Example</h3><pre><code class="language-scala">import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.s3.S3AsyncClient
import zio.{ExitCode, URIO, _}
import zio_aws_s3.AwsApp.AwsLink
import zio_aws_s3.{AwsAgent, AwsApp}

import scala.jdk.CollectionConverters._

object ZIOAWSS3Example extends zio.App {
  val BUCKET = &quot;&lt;bucket name&gt;&quot;

  val awsEnv: ZLayer[S3AsyncClient, Throwable, AwsLink] =
    AwsApp.ExtDeps.live &gt;&gt;&gt; AwsApp.AwsLink.live

  val app: ZIO[Any, Throwable, Unit] = for {
    s3 &lt;- AwsAgent.createClient(Region.US_WEST_2, &quot;&lt;endpoint&gt;&quot;)
    response &lt;- AwsApp.listBuckets().provideLayer(awsEnv).provide(s3)
    buckets &lt;- Task(response.buckets.asScala.toList.map(_.name))
    _ = buckets.foreach(println)
  } yield ()

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    app.exitCode
}
</code></pre><h2>ZIO HTTP</h2><p><a href="https://github.com/dream11/zio-http">ZIO HTTP</a> is a scala library to write HTTP applications.</p><h3>Introduction</h3><p>ZIO HTTP is a Scala library for building HTTP applications. It is powered by ZIO and netty and aims at being the defacto solution for writing, highly scalable, and performant web applications using idiomatic scala.</p><h3>Installation</h3><p>In order to use this library, we need to add the following lines in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;io.d11&quot; %% &quot;zhttp&quot;      % &quot;1.0.0.0-RC13&quot;
libraryDependencies += &quot;io.d11&quot; %% &quot;zhttp-test&quot; % &quot;1.0.0.0-RC13&quot; % Test
</code></pre><h3>Example</h3><pre><code class="language-scala">import zhttp.http._
import zhttp.service.Server
import zio._

object ZIOHTTPExample extends zio.App {

  // Create HTTP route
  val app: HttpApp[Any, Nothing] = HttpApp.collect {
    case Method.GET -&gt; Root / &quot;text&quot; =&gt; Response.text(&quot;Hello World!&quot;)
    case Method.GET -&gt; Root / &quot;json&quot; =&gt; Response.jsonString(&quot;&quot;&quot;{&quot;greetings&quot;: &quot;Hello World!&quot;}&quot;&quot;&quot;)
  }

  // Run it like any simple app
  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    Server.start(8090, app.silent).exitCode
}
</code></pre><h2>ZIO K8s</h2><p><a href="https://github.com/coralogix/zio-k8s">ZIO K8S</a> is an idiomatic ZIO client for the Kubernetes API.</p><h3>Introduction</h3><p>This library provides a client for the full Kubernetes API as well as providing code generator support for custom resources and higher-level concepts such as operators, taking full advantage of the ZIO library.</p><p>Using ZIO K8S we can talk to the Kubernetes API that helps us to:</p><ul><li>Write an operator for our custom resource types</li><li>Schedule some jobs in our cluster</li><li>Query the cluster for monitoring purposes</li><li>Write some cluster management tools</li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;com.coralogix&quot; %% &quot;zio-k8s-client&quot; % &quot;1.3.3&quot;
</code></pre><p>And then we need to choose the proper sttp backend:</p><pre><code class="language-scala">&quot;com.softwaremill.sttp.client3&quot; %% &quot;httpclient-backend-zio&quot; % &quot;3.1.1&quot;,
&quot;com.softwaremill.sttp.client3&quot; %% &quot;slf4j-backend&quot;          % &quot;3.1.1&quot;
</code></pre><p>Or the asynchronous version:</p><pre><code class="language-scala">&quot;com.softwaremill.sttp.client3&quot; %% &quot;async-http-client-backend-zio&quot; % &quot;3.1.1&quot;
&quot;com.softwaremill.sttp.client3&quot; %% &quot;slf4j-backend&quot;                 % &quot;3.1.1&quot;
</code></pre><h3>Example</h3><p>This is an example of printing the tail logs of a container:</p><pre><code class="language-scala">import com.coralogix.zio.k8s.client.K8sFailure
import com.coralogix.zio.k8s.client.config.httpclient._
import com.coralogix.zio.k8s.client.model.K8sNamespace
import com.coralogix.zio.k8s.client.v1.pods
import com.coralogix.zio.k8s.client.v1.pods.Pods
import zio._
import zio.console.Console

import scala.languageFeature.implicitConversions

object ZIOK8sLogsExample extends zio.App {
  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = (args match {
    case List(podName) =&gt; tailLogs(podName, None)
    case List(podName, containerName) =&gt; tailLogs(podName, Some(containerName))
    case _ =&gt; console.putStrLnErr(&quot;Usage: &lt;podname&gt; [containername]&quot;)
  })
    .provideCustomLayer(k8sDefault &gt;&gt;&gt; Pods.live)
    .exitCode

  def tailLogs(podName: String,
               containerName: Option[String]
              ): ZIO[Pods with Console, K8sFailure, Unit] =
    pods
      .getLog(
        name = podName,
        namespace = K8sNamespace.default,
        container = containerName,
        follow = Some(true)
      )
      .tap { line: String =&gt;
        console.putStrLn(line).ignore
      }
      .runDrain
}
</code></pre><h2>ZIO Kinesis</h2><p><a href="https://github.com/svroonland/zio-kinesis">ZIO Kinesis</a> is a ZIO-based AWS Kinesis client for Scala.</p><h3>Introduction</h3><p>ZIO Kinesis is an interface to Amazon Kinesis Data Streams for consuming and producing data. This library is built on top of <a href="https://github.com/vigoo/zio-aws">ZIO AWS</a>, a library of automatically generated ZIO wrappers around AWS SDK methods.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;nl.vroste&quot; %% &quot;zio-kinesis&quot; % &quot;0.20.0&quot;
</code></pre><h3>Example</h3><p>This is an example of consuming a stream from Amazon Kinesis:</p><pre><code class="language-scala" metastring="mdoc:silent:reset">import nl.vroste.zio.kinesis.client.serde.Serde
import nl.vroste.zio.kinesis.client.zionative.Consumer
import zio.clock.Clock
import zio.console.{Console, putStrLn}
import zio.duration._
import zio.logging.Logging
import zio.{ExitCode, URIO, _}

object ZIOKinesisConsumerExample extends zio.App {
  val loggingLayer: ZLayer[Any, Nothing, Logging] =
    (Console.live ++ Clock.live) &gt;&gt;&gt;
      Logging.console() &gt;&gt;&gt;
      Logging.withRootLoggerName(getClass.getName)

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    Consumer
      .consumeWith(
        streamName = &quot;my-stream&quot;,
        applicationName = &quot;my-application&quot;,
        deserializer = Serde.asciiString,
        workerIdentifier = &quot;worker1&quot;,
        checkpointBatchSize = 1000L,
        checkpointDuration = 5.minutes
      )(record =&gt; putStrLn(s&quot;Processing record $record&quot;))
      .provideCustomLayer(Consumer.defaultEnvironment ++ loggingLayer)
      .exitCode
}
</code></pre><h2>ZIO Pulsar</h2><p><a href="https://github.com/apache/pulsar">ZIO Pulsar</a> is the <em>Apache Pulsar</em> client for Scala with ZIO and ZIO Streams integration.</p><h3>Introduction</h3><p>ZIO Pulsar is a purely functional Scala wrapper over the official Pulsar client. Some key features of this library:</p><ul><li><strong>Type-safe</strong> — Utilizes Scala type system to reduce runtime exceptions present in the official Java client.</li><li><strong>Streaming-enabled</strong> — Naturally integrates with ZIO Streams.</li><li><strong>ZIO integrated</strong> — Uses common ZIO primitives like ZIO effect and <code>ZManaged</code> to reduce the boilerplate and increase expressiveness.</li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file for <em>Scala 3</em>:</p><pre><code class="language-scala">libraryDependencies += &quot;com.github.jczuchnowski&quot; %% &quot;zio-pulsar&quot; % &quot;0.1&quot;
</code></pre><h3>Example</h3><p>First of all we need to create an instance of <em>Apache Pulsar</em> and run that:</p><pre><code>docker run -it \
  -p 6650:6650 \
  -p 8080:8080 \
  --mount source=pulsardata,target=/pulsar/data \
  --mount source=pulsarconf,target=/pulsar/conf \
  --network pulsar \
  apachepulsar/pulsar:2.7.0 \
  bin/pulsar standalone
</code></pre><p>Now we can run the following example:</p><pre><code class="language-scala">import org.apache.pulsar.client.api.{PulsarClientException, Schema}
import zio._
import zio.blocking._
import zio.clock._
import zio.console._
import zio.pulsar._
import zio.stream._

import java.nio.charset.StandardCharsets

object StreamingExample extends zio.App {
  val topic = &quot;my-topic&quot;

  val producer: ZManaged[Has[PulsarClient], PulsarClientException, Unit] =
    for {
      sink &lt;- Producer.make(topic, Schema.STRING).map(_.asSink)
      _ &lt;- Stream.fromIterable(0 to 100).map(i =&gt; s&quot;Message $i&quot;).run(sink).toManaged_
    } yield ()

  val consumer: ZManaged[Has[PulsarClient] with Blocking with Console, PulsarClientException, Unit] =
    for {
      builder &lt;- ConsumerBuilder.make(Schema.STRING).toManaged_
      consumer &lt;- builder
        .subscription(Subscription(&quot;my-subscription&quot;, SubscriptionType.Exclusive))
        .topic(topic)
        .build
      _ &lt;- consumer.receiveStream.take(10).foreach { e =&gt;
        consumer.acknowledge(e.getMessageId) *&gt;
          putStrLn(new String(e.getData, StandardCharsets.UTF_8)).orDie
      }.toManaged_
    } yield ()

  val myApp =
    for {
      f &lt;- consumer.fork
      _ &lt;- producer
      _ &lt;- f.join.toManaged_
    } yield ()

  def run(args: List[String]): URIO[ZEnv, ExitCode] =
    myApp
      .provideCustomLayer(
        (Console.live ++ Clock.live) &gt;+&gt;
          PulsarClient.live(&quot;localhost&quot;, 6650)
      ).useNow.exitCode
}
</code></pre><h2>ZIO Saga</h2><p><a href="https://github.com/VladKopanev/zio-saga">ZIO Saga</a> is a distributed transaction manager using Saga Pattern.</p><h3>Introduction</h3><p>Sometimes when we are architecting the business logic using microservice architecture we need distributed transactions that are across services. </p><p>The <em>Saga Pattern</em> lets us manage distributed transactions by sequencing local transactions with their corresponding compensating actions. A <em>Saga Pattern</em> runs all operations. In the case of failure, it guarantees us to undo all previous works by running the compensating actions.</p><p>ZIO Saga allows us to compose our requests and compensating actions from the Saga pattern in one transaction with no boilerplate.</p><p>ZIO Saga adds a simple abstraction called <code>Saga</code> that takes the responsibility of proper composition of effects and associated compensating actions.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;com.vladkopanev&quot; %% &quot;zio-saga-core&quot; % &quot;0.4.0&quot;
</code></pre><h3>Example</h3><p>In the following example, all API requests have a compensating action. We compose all them together and then run the whole as one transaction:</p><pre><code class="language-scala">import com.vladkopanev.zio.saga.Saga
import zio.{IO, UIO, URIO, ZIO}

import com.vladkopanev.zio.saga.Saga._

val transaction: Saga[Any, String, Unit] =
  for {
    _ &lt;- bookHotel compensate cancelHotel
    _ &lt;- bookTaxi compensate cancelTaxi
    _ &lt;- bookFlight compensate cancelFlight
  } yield ()

val myApp: ZIO[Any, String, Unit] = transaction.transact
</code></pre><h2>ZIO Slick Interop</h2><p><a href="https://github.com/ScalaConsultants/zio-slick-interop">ZIO Slick Interop</a> is a small library, that provides interop between Slick and ZIO.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;io.scalac&quot; %% &quot;zio-slick-interop&quot; % &quot;0.4.0&quot;
</code></pre><h3>Example</h3><p>To run this example we should also add the <em>HikariCP integration for Slick</em> in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;com.typesafe.slick&quot; %% &quot;slick-hikaricp&quot; % &quot;3.3.3&quot;
</code></pre><p>Here is a full working example of creating database-agnostic Slick repository:</p><pre><code class="language-scala">import com.typesafe.config.ConfigFactory
import slick.interop.zio.DatabaseProvider
import slick.interop.zio.syntax._
import slick.jdbc.H2Profile.api._
import slick.jdbc.JdbcProfile
import zio.console.Console
import zio.interop.console.cats.putStrLn
import zio.{ExitCode, Has, IO, URIO, ZIO, ZLayer}

import scala.jdk.CollectionConverters._

case class Item(id: Long, name: String)

trait ItemRepository {
  def add(name: String): IO[Throwable, Long]

  def getById(id: Long): IO[Throwable, Option[Item]]

  def upsert(name: String): IO[Throwable, Long]
}

object ItemsTable {
  class Items(tag: Tag) extends Table[Item](
    _tableTag = tag,
    _tableName = &quot;ITEMS&quot;
  ) {
    def id = column[Long](&quot;ID&quot;, O.PrimaryKey, O.AutoInc)

    def name = column[String](&quot;NAME&quot;)

    def * = (id, name) &lt;&gt; ((Item.apply _).tupled, Item.unapply _)
  }

  val table = TableQuery[ItemsTable.Items]
}

object SlickItemRepository {
  val live: ZLayer[Has[DatabaseProvider], Throwable, Has[ItemRepository]] =
    ZLayer.fromServiceM { db =&gt;
      db.profile.flatMap { profile =&gt;
        import profile.api._

        val initialize = ZIO.fromDBIO(ItemsTable.table.schema.createIfNotExists)

        val repository = new ItemRepository {
          private val items = ItemsTable.table

          def add(name: String): IO[Throwable, Long] =
            ZIO
              .fromDBIO((items returning items.map(_.id)) += Item(0L, name))
              .provide(Has(db))

          def getById(id: Long): IO[Throwable, Option[Item]] = {
            val query = items.filter(_.id === id).result

            ZIO.fromDBIO(query).map(_.headOption).provide(Has(db))
          }

          def upsert(name: String): IO[Throwable, Long] =
            ZIO
              .fromDBIO { implicit ec =&gt;
                (for {
                  itemOpt &lt;- items.filter(_.name === name).result.headOption
                  id &lt;- itemOpt.fold[DBIOAction[Long, NoStream, Effect.Write]](
                    (items returning items.map(_.id)) += Item(0L, name)
                  )(item =&gt; (items.map(_.name) update name).map(_ =&gt; item.id))
                } yield id).transactionally
              }
              .provide(Has(db))
        }

        initialize.as(repository).provide(Has(db))
      }
    }
}


object Main extends zio.App {

  private val config = ConfigFactory.parseMap(
    Map(
      &quot;url&quot; -&gt; &quot;jdbc:h2:mem:test1;DB_CLOSE_DELAY=-1&quot;,
      &quot;driver&quot; -&gt; &quot;org.h2.Driver&quot;,
      &quot;connectionPool&quot; -&gt; &quot;disabled&quot;
    ).asJava
  )

  private val env: ZLayer[Any, Throwable, Has[ItemRepository]] =
    (ZLayer.succeed(config) ++ ZLayer.succeed[JdbcProfile](
      slick.jdbc.H2Profile
    )) &gt;&gt;&gt; DatabaseProvider.live &gt;&gt;&gt; SlickItemRepository.live

  val myApp: ZIO[Console with Has[ItemRepository], Throwable, Unit] =
    for {
      repo &lt;- ZIO.service[ItemRepository]
      aId1 &lt;- repo.add(&quot;A&quot;)
      _ &lt;- repo.add(&quot;B&quot;)
      a &lt;- repo.getById(1L)
      b &lt;- repo.getById(2L)
      aId2 &lt;- repo.upsert(&quot;A&quot;)
      _ &lt;- putStrLn(s&quot;$aId1 == $aId2&quot;)
      _ &lt;- putStrLn(s&quot;A item: $a&quot;)
      _ &lt;- putStrLn(s&quot;B item: $b&quot;)
    } yield ()

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp.provideCustomLayer(env).exitCode
}
</code></pre><h2>ZIO Test Akka HTTP</h2><p><a href="https://github.com/senia-psm/zio-test-akka-http">ZIO Test Akka HTTP</a> is an Akka-HTTP Route TestKit for zio-test.</p><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;info.senia&quot; %% &quot;zio-test-akka-http&quot; % &quot;1.0.2&quot;
</code></pre><h3>Example</h3><p>An example of writing Akka HTTP Route test spec:</p><pre><code class="language-scala">import akka.http.scaladsl.model.HttpResponse
import akka.http.scaladsl.server.Directives.complete
import zio.test.Assertion._
import zio.test._
import zio.test.akkahttp.DefaultAkkaRunnableSpec

object MySpec extends DefaultAkkaRunnableSpec {
  def spec =
    suite(&quot;MySpec&quot;)(
      testM(&quot;my test&quot;) {
        assertM(Get() ~&gt; complete(HttpResponse()))(
          handled(
            response(equalTo(HttpResponse()))
          )
        )
      }
    )
}
</code></pre><h2>ZparkIO</h2><p><a href="https://github.com/leobenkel/ZparkIO">ZParkIO</a> is a boilerplate framework to use <em>Spark</em> and <em>ZIO</em> together.</p><h3>Introduction</h3><p><em>ZparkIO</em> enables us to:</p><ul><li>Wrap asynchronous and synchronous operations smoothly. So everything is wrapped in ZIO.</li><li>Have ZIO features in our spark jobs, like forking and joining fibers, parallelizing tasks, retrying, and timing-out.</li><li>Make our spark job much easier to debug</li></ul><h3>Installation</h3><p>In order to use this library, we need to add the following line in our <code>build.sbt</code> file:</p><pre><code class="language-scala">libraryDependencies += &quot;com.leobenkel&quot; %% &quot;zparkio&quot; % &quot;[SPARK_VERSION]_[VERSION]&quot;
</code></pre><h3>Example</h3><p>Using <em>ZparkIO</em> we can write jobs like the following example:</p><pre><code class="language-scala">import com.leobenkel.zparkio.Services.SparkModule
import com.leobenkel.zparkio.Services.SparkModule.SparkModule
import com.leobenkel.zparkio.ZparkioApplicationTimeoutException
import org.apache.spark.sql.DataFrame
import zio.clock.Clock
import zio.duration.durationInt
import zio.{Schedule, Task, ZIO}

def readParquetFile[A](parquetPath: String): ZIO[Clock with SparkModule, Throwable, DataFrame] =
  for {
    spark &lt;- SparkModule()
    dataset &lt;- Task(spark.read.parquet(parquetPath))
      .retry(
        Schedule.recurs(3) &amp;&amp; Schedule.exponential(2.seconds)
      )
      .timeoutFail(ZparkioApplicationTimeoutException())(5.minutes)
  } yield dataset
</code></pre><h2>Quill</h2><p><a href="https://github.com/getquill/quill">Quil</a> is a Compile-time Language Integrated Queries for Scala.</p><h3>Introduction</h3><p>Quill allows us to create SQL out of a Scala code during the <strong>compile-time</strong>. It provides the <em>Quoted Domain Specific Language (QDSL)</em> to express queries in Scala and execute them in a target language.</p><ul><li><strong>Boilerplate-free mapping</strong> — The database schema is mapped using simple case classes.</li><li><strong>Quoted DSL</strong> — Queries are defined inside a quote block. Quill parses each quoted block of code (quotation) at compile-time and translates them to an internal Abstract Syntax Tree (AST)</li><li><strong>Compile-time query generation</strong> — The <code>ctx.run</code> call reads the quotation’s AST and translates it to the target language at compile-time, emitting the query string as a compilation message. As the query string is known at compile-time, the runtime overhead is very low and similar to using the database driver directly.</li><li><strong>Compile-time query validation</strong> — If configured, the query is verified against the database at compile-time and the compilation fails if it is not valid. The query validation does not alter the database state.</li></ul><h3>Installation</h3><p>In order to use this library with ZIO, we need to add the following lines in our <code>build.sbt</code> file:</p><pre><code class="language-scala">// Provides Quill contexts for ZIO.
libraryDependencies += &quot;io.getquill&quot; %% &quot;quill-zio&quot; % &quot;3.9.0&quot;

// Provides Quill context that execute MySQL, PostgreSQL, SQLite, H2, SQL Server and Oracle queries inside of ZIO.
libraryDependencies += &quot;io.getquill&quot; %% &quot;quill-jdbc-zio&quot; % &quot;3.9.0&quot; 

// Provides Quill context that executes Cassandra queries inside of ZIO.
libraryDependencies += &quot;io.getquill&quot; %% &quot;quill-cassandra-zio&quot; % &quot;3.9.0&quot;
</code></pre><h3>Example</h3><p>First, to run this example, we should create the <code>Person</code> table at the database initialization. Let&#x27;s put the following lines into the <code>h2-schema.sql</code> file at the<code>src/main/resources</code> path:</p><pre><code class="language-sql">CREATE TABLE IF NOT EXISTS Person(
    name VARCHAR(255),
    age int
);
</code></pre><p>In this example, we use in-memory database as our data source. So we just put these lines into the <code>application.conf</code> at the <code>src/main/resources</code> path:</p><pre><code class="language-hocon">myH2DB {
  dataSourceClassName = org.h2.jdbcx.JdbcDataSource
  dataSource {
    url = &quot;jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;INIT=RUNSCRIPT FROM &#x27;classpath:h2-schema.sql&#x27;&quot;
    user = sa
  }
}
</code></pre><p>Now we are ready to run the example below:</p><pre><code class="language-scala">import io.getquill._
import io.getquill.context.ZioJdbc._
import zio.console.{Console, putStrLn}
import zio.{ExitCode, Has, URIO, ZIO}

import java.io.Closeable
import javax.sql

object QuillZIOExample extends zio.App {
  val ctx = new H2ZioJdbcContext(Literal)

  import ctx._

  case class Person(name: String, age: Int)

  val myApp: ZIO[Console with Has[sql.DataSource with Closeable], Exception, Unit] =
    for {
      _ &lt;- ctx.run(
        quote {
          liftQuery(List(Person(&quot;Alex&quot;, 25), Person(&quot;Sarah&quot;, 23)))
            .foreach(r =&gt;
              query[Person].insert(r)
            )
        }
      ).onDS
      result &lt;- ctx.run(
        quote(query[Person].filter(p =&gt; p.name == &quot;Sarah&quot;))
      ).onDS
      _ &lt;- putStrLn(result.toString)
    } yield ()

  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =
    myApp
      .provideCustomLayer(DataSourceLayer.fromPrefix(&quot;myH2DB&quot;))
      .exitCode
}
</code></pre></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/zio/1-0-0/resources/ecosystem/community";window.___webpackCompilationHash="629750c28ce5e2d26819";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-0704c8948e63b1196955.js"],"app":["/app-5bc2dca3fcd03febe812.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-components-simple-js-900cac777aa246c3185a.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-404-js-b44617773e223797ea52.js"],"component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js":["/component---node-modules-atooni-gatsby-theme-ziodoc-src-pages-index-js-d0913b8933fa48a45475.js"],"component---src-pages-foo-md":["/component---src-pages-foo-md-3c304a0b5d5a13435790.js"]};/*]]>*/</script><script src="/gatsby-theme-zio/polyfill-0704c8948e63b1196955.js" nomodule=""></script><script src="/gatsby-theme-zio/app-5bc2dca3fcd03febe812.js" async=""></script><script src="/gatsby-theme-zio/1a48c3c1-3aa89e0c36dddf1a6d26.js" async=""></script><script src="/gatsby-theme-zio/framework-ef126061ffea8930f2ad.js" async=""></script><script src="/gatsby-theme-zio/webpack-runtime-7117cab68cf800d067d6.js" async=""></script></body></html>