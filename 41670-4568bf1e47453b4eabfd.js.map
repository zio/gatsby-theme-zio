{"version":3,"file":"41670-4568bf1e47453b4eabfd.js","mappings":"wGAAAA,MAAMC,UAAUC,QAAU,CACxB,QAAW,MACX,YAAe,CACbC,QAAS,mEACTC,QAAQ,EACRC,MAAO,SACPC,OAAQ,CACN,oBAAqB,CACnBH,QAAS,kCACTI,YAAY,EACZD,OAAQN,MAAMC,UAAUO,YAI9B,OAAU,CACRL,QAAS,iDACTC,QAAQ,GAEV,OAAU,2CACV,QAAW,qBACX,SAAY,eACZ,UAAa,CACXD,QAAS,cACTE,MAAO,YAET,YAAa,CACXF,QAAS,iEACTC,QAAQ,GAEV,aAAc,CACZD,QAAS,oBACTE,MAAO,cAET,OAAU,sCACV,SAAY,qBACZ,aAAc,CACZF,QAAS,kFACTI,YAAY,GAEd,SAAY,CACVJ,QAAS,+CACTI,YAAY,EACZF,MAAO,YAET,sBAAuB,CACrBF,QAAS,8BACTI,YAAY,EACZF,MAAO,YAET,mBAAoB,CAClBF,QAAS,2BACTI,YAAY,EACZF,MAAO,YAET,QAAW,uIACX,SAAY,eACZ,iBAAkB,eAClB,OAAU,eACV,YAAe,iBACf,SAAY,OAEdL,MAAMS,MAAMC,IAAI,kBAAkB,SAA8BC,GAC9D,GAAqB,YAAjBA,EAAIC,SAuGR,IA5FA,IAAIC,EAAcF,EAAIG,OAAOC,QAAO,SAAUC,GAC5C,MAAwB,iBAAVA,GAAqC,YAAfA,EAAMC,MAAqC,WAAfD,EAAMC,QAEpEC,EAAe,EAyFZA,EAAeL,EAAYM,QAAS,CACzC,IAAIC,EAAaP,EAAYK,KAE7B,GAAwB,YAApBE,EAAWH,MAA6C,aAAvBG,EAAWC,QAAwB,CAEtE,IAAIC,EAAiB,GAErB,GAAIC,EAAY,CAAC,sBAAuB,iBAA2C,MAAxBC,EAAS,GAAGH,QAAiB,CAEtFH,GAAgB,EAEhB,IAAIO,EAAgBC,EAAmB,OAAQ,QAE/C,IAAuB,IAAnBD,EACF,SAIF,KAAOP,EAAeO,EAAeP,IAAgB,CACnD,IAAIS,EAAIH,EAAS,GAEF,aAAXG,EAAEV,OACJW,EAASD,EAAG,kBACZL,EAAeO,KAAKF,EAAEN,UAI1BH,EAAeO,EAAgB,EAGjC,GAAIF,EAAY,CAAC,cAAe,oBAA8C,MAAxBC,EAAS,GAAGH,UAChEH,IAEAU,EAASJ,EAAS,GAAI,qBAElBF,EAAeH,OAAS,GAAG,CAC7B,IAAIW,EAAcJ,EAAmB,OAAQ,QAE7C,IAAqB,IAAjBI,EACF,SAIF,IAAK,IAAIC,EAAIb,EAAca,EAAID,EAAaC,IAAK,CAC/C,IAAIC,EAAWnB,EAAYkB,GAEL,aAAlBC,EAASf,MAAuBK,EAAeW,QAAQD,EAASX,UAAY,GAC9EO,EAASI,EAAU,qBAhI/B,SAASR,EAASU,GAChB,OAAOrB,EAAYK,EAAegB,GAWpC,SAASX,EAAYY,EAAOD,GAC1BA,EAASA,GAAU,EAEnB,IAAK,IAAIH,EAAI,EAAGA,EAAII,EAAMhB,OAAQY,IAAK,CACrC,IAAIf,EAAQQ,EAASO,EAAIG,GAEzB,IAAKlB,GAASA,EAAMC,OAASkB,EAAMJ,GACjC,OAAO,EAIX,OAAO,EAeT,SAASL,EAAmBU,EAAMC,GAGhC,IAFA,IAAIC,EAAc,EAETP,EAAIb,EAAca,EAAIlB,EAAYM,OAAQY,IAAK,CACtD,IAAIf,EAAQH,EAAYkB,GACpBV,EAAUL,EAAMK,QAEpB,GAAmB,gBAAfL,EAAMC,MAA6C,iBAAZI,EACzC,GAAIe,EAAKG,KAAKlB,GACZiB,SACK,GAAID,EAAME,KAAKlB,IAGA,MAFpBiB,EAGE,OAAOP,EAMf,OAAQ,EAWV,SAASH,EAASZ,EAAOX,GACvB,IAAImC,EAAUxB,EAAMX,MAEfmC,EAEOC,MAAMC,QAAQF,KACxBxB,EAAMX,MAAQmC,EAAU,CAACA,IAFzBxB,EAAMX,MAAQmC,EAAU,GAK1BA,EAAQX,KAAKxB","sources":["webpack://zio-sample-site/./node_modules/prismjs/components/prism-graphql.js"],"sourcesContent":["Prism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: Prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:false|true)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /\\b[A-Z]\\w*Input\\b/,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n\n\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n\n\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n\n\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n\n\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n        if (definitionEnd === -1) {\n          continue;\n        } // find all input variables\n\n\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n          if (mutationEnd === -1) {\n            continue;\n          } // give references to input variables a special alias\n\n\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});"],"names":["Prism","languages","graphql","pattern","greedy","alias","inside","lookbehind","markdown","hooks","add","env","language","validTokens","tokens","filter","token","type","currentIndex","length","startToken","content","inputVariables","isTokenType","getToken","definitionEnd","findClosingBracket","t","addAlias","push","mutationEnd","i","varToken","indexOf","offset","types","open","close","stackHeight","test","aliases","Array","isArray"],"sourceRoot":""}